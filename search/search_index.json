{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scaphoid Examples","text":"<p>This page provides practical examples of using Hands Scaphoid in real-world scenarios.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Hands Scaphoid is a powerful tool for securely executing shell commands in Python. Below are several example scripts demonstrating its capabilities in various contexts, including deployment, development workflows, DevOps automation, and file processing.</p> <p>Learn more about the items and objects in Operations Summary and get started with the basics.</p> <p>Already a pro, go to Getting Started)</p>"},{"location":"#example-deployment-scripts","title":"Example: Deployment scripts","text":"<p>More examples can be found in Examples.</p>"},{"location":"#simple-web-app-deployment","title":"Simple web app deployment","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nDeploy a web application using Hands Scaphoid.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport sys\n\ndef deploy_web_app(branch=\"main\", environment=\"production\"):\n    \"\"\"Deploy web application.\"\"\"\n\n    print(f\"\ud83d\ude80 Deploying from branch '{branch}' to '{environment}'...\")\n\n    with ShellContext(cwd=\"/app\") as shell:\n        # Allow required commands\n        required_commands = [\"git\", \"docker\", \"docker-compose\", \"echo\"]\n        for cmd in required_commands:\n            if not shell.allow(cmd):\n                print(f\"\u274c Required command '{cmd}' not found\")\n                return False\n\n        try:\n            # Pull latest code\n            print(\"\ud83d\udce5 Pulling latest code...\")\n            shell.run(f\"git pull origin {branch}\")\n\n            # Build new Docker image\n            print(\"\ud83d\udd28 Building Docker image...\")\n            shell.run(\"docker build -t myapp:latest .\")\n\n            # Stop old containers\n            print(\"\ud83d\uded1 Stopping old containers...\")\n            shell.run(\"docker-compose down\")\n\n            # Start new containers\n            print(\"\u25b6\ufe0f Starting new containers...\")\n            shell.run(\"docker-compose up -d\")\n\n            # Verify deployment\n            print(\"\u2705 Verifying deployment...\")\n            result = shell.run(\"docker-compose ps\")\n            if \"Up\" in result.stdout:\n                print(\"\u2705 Deployment successful!\")\n                return True\n            else:\n                print(\"\u274c Deployment verification failed\")\n                return False\n\n        except Exception as e:\n            print(f\"\u274c Deployment failed: {e}\")\n            return False\n\nif __name__ == \"__main__\":\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Deploy web application\")\n    parser.add_argument(\"--branch\", default=\"main\", help=\"Git branch to deploy\")\n    parser.add_argument(\"--env\", default=\"production\", help=\"Environment\")\n\n    args = parser.parse_args()\n\n    if not deploy_web_app(args.branch, args.env):\n        sys.exit(1)\n</code></pre>"},{"location":"#database-migration-script","title":"Database Migration Script","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nDatabase migration script with backup.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nfrom datetime import datetime\nimport sys\n\ndef migrate_database():\n    \"\"\"Run database migrations with backup.\"\"\"\n\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    backup_file = f\"backup_{timestamp}.sql\"\n\n    with ShellContext() as shell:\n        # Allow database commands\n        for cmd in [\"pg_dump\", \"psql\", \"echo\"]:\n            if not shell.allow(cmd):\n                print(f\"\u274c Database command '{cmd}' not available\")\n                return False\n\n        try:\n            # Create backup\n            print(\"\ud83d\udcbe Creating database backup...\")\n            shell.run(f\"pg_dump myapp_prod &gt; {backup_file}\")\n\n            # Run migrations\n            print(\"\ud83d\udd04 Running migrations...\")\n            shell.run(\"psql myapp_prod &lt; migrations/latest.sql\")\n\n            # Verify migration\n            print(\"\u2705 Migration completed successfully!\")\n            print(f\"\ud83d\udcbe Backup saved as: {backup_file}\")\n            return True\n\n        except Exception as e:\n            print(f\"\u274c Migration failed: {e}\")\n            print(f\"\ud83d\udd04 Restoring from backup: {backup_file}\")\n            try:\n                shell.run(f\"psql myapp_prod &lt; {backup_file}\")\n                print(\"\u2705 Database restored from backup\")\n            except Exception as restore_error:\n                print(f\"\u274c Backup restoration failed: {restore_error}\")\n            return False\n\nif __name__ == \"__main__\":\n    if not migrate_database():\n        sys.exit(1)\n</code></pre>"},{"location":"#development-workflows","title":"Development Workflows","text":""},{"location":"#project-setup-automation","title":"Project Setup Automation","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nAutomated project setup script.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport sys\nimport os\n\ndef setup_project(project_name: str, template: str = \"python\"):\n    \"\"\"Set up a new project from template.\"\"\"\n\n    project_dir = f\"/workspace/{project_name}\"\n\n    with ShellContext() as shell:\n        # Allow development tools\n        dev_tools = [\"git\", \"python\", \"pip\", \"npm\", \"mkdir\", \"cp\", \"echo\"]\n        for tool in dev_tools:\n            shell.allow(tool)\n\n        try:\n            # Create project directory\n            print(f\"\ud83d\udcc1 Creating project directory: {project_dir}\")\n            shell.run(f\"mkdir -p {project_dir}\")\n            shell.cd(project_dir)\n\n            # Initialize git repository\n            print(\"\ud83d\udd27 Initializing Git repository...\")\n            shell.run(\"git init\")\n\n            if template == \"python\":\n                setup_python_project(shell, project_name)\n            elif template == \"node\":\n                setup_node_project(shell, project_name)\n            else:\n                print(f\"\u274c Unknown template: {template}\")\n                return False\n\n            # Create initial commit\n            print(\"\ud83d\udcbe Creating initial commit...\")\n            shell.run(\"git add .\")\n            shell.run(f\"git commit -m 'Initial commit for {project_name}'\")\n\n            print(f\"\u2705 Project '{project_name}' set up successfully!\")\n            print(f\"\ud83d\udcc1 Location: {project_dir}\")\n            return True\n\n        except Exception as e:\n            print(f\"\u274c Project setup failed: {e}\")\n            return False\n\ndef setup_python_project(shell, project_name):\n    \"\"\"Set up Python project structure.\"\"\"\n    print(\"\ud83d\udc0d Setting up Python project...\")\n\n    # Create Python project structure\n    shell.run(f\"mkdir -p {project_name}\")\n    shell.run(f\"mkdir -p tests\")\n    shell.run(f\"mkdir -p docs\")\n\n    # Create basic files\n    pyproject_content = f'''[project]\nname = \"{project_name}\"\nversion = \"0.1.0\"\ndescription = \"\"\nrequires-python = \"&gt;=3.11\"\ndependencies = []\n'''\n\n    with open(\"pyproject.toml\", \"w\") as f:\n        f.write(pyproject_content)\n\n    # Create virtual environment\n    shell.run(\"python -m venv .venv\")\n\n    print(\"\u2705 Python project structure created\")\n\ndef setup_node_project(shell, project_name):\n    \"\"\"Set up Node.js project structure.\"\"\"\n    print(\"\ud83d\udce6 Setting up Node.js project...\")\n\n    # Initialize npm project\n    shell.run(\"npm init -y\")\n\n    # Create basic structure\n    shell.run(\"mkdir -p src\")\n    shell.run(\"mkdir -p tests\")\n    shell.run(\"mkdir -p docs\")\n\n    print(\"\u2705 Node.js project structure created\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) &lt; 2:\n        print(\"Usage: setup_project.py &lt;project_name&gt; [template]\")\n        sys.exit(1)\n\n    project_name = sys.argv[1]\n    template = sys.argv[2] if len(sys.argv) &gt; 2 else \"python\"\n\n    if not setup_project(project_name, template):\n        sys.exit(1)\n</code></pre>"},{"location":"#automated-testing-pipeline","title":"Automated Testing Pipeline","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComprehensive testing pipeline.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport sys\n\ndef run_test_pipeline():\n    \"\"\"Run complete testing pipeline.\"\"\"\n\n    with ShellContext() as shell:\n        # Allow testing tools\n        test_tools = [\"python\", \"pytest\", \"flake8\", \"mypy\", \"black\", \"echo\"]\n        for tool in test_tools:\n            if not shell.allow(tool):\n                print(f\"\u26a0\ufe0f Testing tool '{tool}' not available\")\n\n        tests_passed = True\n\n        # Code formatting check\n        print(\"\ud83c\udfa8 Checking code formatting...\")\n        try:\n            shell.run(\"black --check src tests\")\n            print(\"\u2705 Code formatting OK\")\n        except Exception:\n            print(\"\u274c Code formatting issues found\")\n            tests_passed = False\n\n        # Linting\n        print(\"\ud83d\udd0d Running linter...\")\n        try:\n            shell.run(\"flake8 src tests\")\n            print(\"\u2705 Linting passed\")\n        except Exception:\n            print(\"\u274c Linting issues found\")\n            tests_passed = False\n\n        # Type checking\n        print(\"\ud83d\udd2c Type checking...\")\n        try:\n            shell.run(\"mypy src\")\n            print(\"\u2705 Type checking passed\")\n        except Exception:\n            print(\"\u274c Type checking issues found\")\n            tests_passed = False\n\n        # Unit tests\n        print(\"\ud83e\uddea Running unit tests...\")\n        try:\n            result = shell.run(\"pytest tests/ -v --cov\")\n            print(\"\u2705 Unit tests passed\")\n\n            # Extract coverage percentage\n            coverage_line = [line for line in result.stdout.split('\\n') \n                           if 'TOTAL' in line and '%' in line]\n            if coverage_line:\n                print(f\"\ud83d\udcca {coverage_line[0]}\")\n\n        except Exception:\n            print(\"\u274c Unit tests failed\")\n            tests_passed = False\n\n        if tests_passed:\n            print(\"\\n\ud83c\udf89 All tests passed! Ready for deployment.\")\n            return True\n        else:\n            print(\"\\n\u274c Some tests failed. Please fix issues before deployment.\")\n            return False\n\nif __name__ == \"__main__\":\n    if not run_test_pipeline():\n        sys.exit(1)\n</code></pre>"},{"location":"#devops-automation","title":"DevOps Automation","text":""},{"location":"#container-management","title":"Container Management","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nDocker container management utilities.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport json\nimport sys\n\ndef manage_containers(action: str, service: str = None):\n    \"\"\"Manage Docker containers.\"\"\"\n\n    with ShellContext() as shell:\n        shell.allow(\"docker\")\n        shell.allow(\"docker-compose\")\n\n        try:\n            if action == \"status\":\n                show_container_status(shell)\n            elif action == \"logs\":\n                show_container_logs(shell, service)\n            elif action == \"restart\":\n                restart_service(shell, service)\n            elif action == \"health\":\n                check_health(shell)\n            else:\n                print(f\"\u274c Unknown action: {action}\")\n                return False\n\n            return True\n\n        except Exception as e:\n            print(f\"\u274c Container management failed: {e}\")\n            return False\n\ndef show_container_status(shell):\n    \"\"\"Show status of all containers.\"\"\"\n    print(\"\ud83d\udcca Container Status:\")\n    print(\"-\" * 50)\n\n    result = shell.run(\"docker-compose ps\")\n    print(result.stdout)\n\ndef show_container_logs(shell, service):\n    \"\"\"Show logs for a specific service.\"\"\"\n    if not service:\n        print(\"\u274c Service name required for logs\")\n        return\n\n    print(f\"\ud83d\udcdd Logs for {service}:\")\n    print(\"-\" * 50)\n\n    result = shell.run(f\"docker-compose logs --tail=50 {service}\")\n    print(result.stdout)\n\ndef restart_service(shell, service):\n    \"\"\"Restart a specific service.\"\"\"\n    if not service:\n        print(\"\u274c Service name required for restart\")\n        return\n\n    print(f\"\ud83d\udd04 Restarting {service}...\")\n    shell.run(f\"docker-compose restart {service}\")\n    print(f\"\u2705 {service} restarted\")\n\ndef check_health(shell):\n    \"\"\"Check health of all services.\"\"\"\n    print(\"\ud83c\udfe5 Health Check:\")\n    print(\"-\" * 50)\n\n    # Get container info\n    result = shell.run(\"docker ps --format '{{.Names}}\\t{{.Status}}'\")\n\n    for line in result.stdout.strip().split('\\n'):\n        if line:\n            name, status = line.split('\\t', 1)\n            if 'healthy' in status.lower():\n                print(f\"\u2705 {name}: {status}\")\n            elif 'unhealthy' in status.lower():\n                print(f\"\u274c {name}: {status}\")\n            else:\n                print(f\"\u26a0\ufe0f {name}: {status}\")\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Container management\")\n    parser.add_argument(\"action\", choices=[\"status\", \"logs\", \"restart\", \"health\"])\n    parser.add_argument(\"--service\", help=\"Service name\")\n\n    args = parser.parse_args()\n\n    if not manage_containers(args.action, args.service):\n        sys.exit(1)\n</code></pre>"},{"location":"#system-monitoring","title":"System Monitoring","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSystem monitoring and alerts.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport time\nimport sys\n\ndef monitor_system(duration_minutes: int = 5):\n    \"\"\"Monitor system resources and services.\"\"\"\n\n    end_time = time.time() + (duration_minutes * 60)\n\n    with ShellContext() as shell:\n        # Allow monitoring commands\n        monitor_commands = [\"ps\", \"df\", \"free\", \"top\", \"docker\", \"curl\"]\n        for cmd in monitor_commands:\n            shell.allow(cmd)\n\n        print(f\"\ud83d\udd0d Starting system monitoring for {duration_minutes} minutes...\")\n\n        while time.time() &lt; end_time:\n            print(f\"\\n\ud83d\udcca System Check - {time.strftime('%H:%M:%S')}\")\n            print(\"-\" * 50)\n\n            # Check disk usage\n            check_disk_usage(shell)\n\n            # Check memory usage\n            check_memory_usage(shell)\n\n            # Check running services\n            check_services(shell)\n\n            # Check application health\n            check_application_health(shell)\n\n            # Wait before next check\n            time.sleep(30)\n\n        print(\"\\n\u2705 Monitoring completed\")\n\ndef check_disk_usage(shell):\n    \"\"\"Check disk usage.\"\"\"\n    result = shell.run(\"df -h /\")\n    lines = result.stdout.strip().split('\\n')\n    if len(lines) &gt; 1:\n        usage_line = lines[1].split()\n        usage_percent = usage_line[4].rstrip('%')\n\n        if int(usage_percent) &gt; 90:\n            print(f\"\ud83d\udd34 Disk usage: {usage_percent}% (CRITICAL)\")\n        elif int(usage_percent) &gt; 80:\n            print(f\"\ud83d\udfe1 Disk usage: {usage_percent}% (WARNING)\")\n        else:\n            print(f\"\ud83d\udfe2 Disk usage: {usage_percent}% (OK)\")\n\ndef check_memory_usage(shell):\n    \"\"\"Check memory usage.\"\"\"\n    result = shell.run(\"free -m\")\n    lines = result.stdout.strip().split('\\n')\n    if len(lines) &gt; 1:\n        mem_line = lines[1].split()\n        total = int(mem_line[1])\n        used = int(mem_line[2])\n        usage_percent = (used / total) * 100\n\n        if usage_percent &gt; 90:\n            print(f\"\ud83d\udd34 Memory usage: {usage_percent:.1f}% (CRITICAL)\")\n        elif usage_percent &gt; 80:\n            print(f\"\ud83d\udfe1 Memory usage: {usage_percent:.1f}% (WARNING)\")\n        else:\n            print(f\"\ud83d\udfe2 Memory usage: {usage_percent:.1f}% (OK)\")\n\ndef check_services(shell):\n    \"\"\"Check running services.\"\"\"\n    try:\n        result = shell.run(\"docker-compose ps\", check=False)\n        if result.returncode == 0:\n            # Count running containers\n            running = result.stdout.count(\"Up\")\n            total = len([line for line in result.stdout.split('\\n') \n                        if line and not line.startswith('Name')])\n\n            if running == total:\n                print(f\"\ud83d\udfe2 Services: {running}/{total} running (OK)\")\n            else:\n                print(f\"\ud83d\udd34 Services: {running}/{total} running (ISSUES)\")\n        else:\n            print(\"\u26a0\ufe0f Could not check services\")\n    except Exception:\n        print(\"\u26a0\ufe0f Service check failed\")\n\ndef check_application_health(shell):\n    \"\"\"Check application health endpoints.\"\"\"\n    try:\n        result = shell.run(\"curl -s -o /dev/null -w '%{http_code}' http://localhost:8080/health\", \n                          check=False)\n        status_code = result.stdout.strip()\n\n        if status_code == \"200\":\n            print(\"\ud83d\udfe2 Application health: OK\")\n        else:\n            print(f\"\ud83d\udd34 Application health: HTTP {status_code}\")\n    except Exception:\n        print(\"\ud83d\udd34 Application health: UNREACHABLE\")\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"System monitoring\")\n    parser.add_argument(\"--duration\", type=int, default=5, \n                       help=\"Monitoring duration in minutes\")\n\n    args = parser.parse_args()\n\n    try:\n        monitor_system(args.duration)\n    except KeyboardInterrupt:\n        print(\"\\n\u23f9\ufe0f Monitoring stopped by user\")\n</code></pre>"},{"location":"#file-processing","title":"File Processing","text":""},{"location":"#batch-image-processing","title":"Batch Image Processing","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nBatch image processing with ImageMagick.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport os\nimport sys\n\ndef process_images(input_dir: str, output_dir: str, \n                  width: int = 800, height: int = 600, quality: int = 85):\n    \"\"\"Process images in batch.\"\"\"\n\n    with ShellContext(cwd=input_dir) as shell:\n        # Allow image processing commands\n        shell.allow(\"find\")\n        shell.allow(\"convert\")  # ImageMagick\n        shell.allow(\"mkdir\")\n        shell.allow(\"identify\")\n\n        try:\n            # Create output directory\n            shell.run(f\"mkdir -p {output_dir}\")\n\n            # Find image files\n            result = shell.run(\"find . -type f \\\\( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' \\\\)\")\n\n            image_files = [f.strip() for f in result.stdout.split('\\n') if f.strip()]\n\n            if not image_files:\n                print(\"\u274c No image files found\")\n                return False\n\n            print(f\"\ud83d\udcf7 Found {len(image_files)} images to process\")\n\n            processed = 0\n            for image_file in image_files:\n                try:\n                    # Get original image info\n                    info_result = shell.run(f\"identify -format '%wx%h' '{image_file}'\")\n                    original_size = info_result.stdout.strip()\n\n                    # Generate output filename\n                    output_file = os.path.join(output_dir, \n                                             os.path.basename(image_file))\n\n                    # Process image\n                    convert_cmd = (f\"convert '{image_file}' \"\n                                 f\"-resize {width}x{height}&gt; \"\n                                 f\"-quality {quality} \"\n                                 f\"'{output_file}'\")\n\n                    shell.run(convert_cmd)\n\n                    # Get new image info\n                    new_info_result = shell.run(f\"identify -format '%wx%h' '{output_file}'\")\n                    new_size = new_info_result.stdout.strip()\n\n                    print(f\"\u2705 {image_file}: {original_size} \u2192 {new_size}\")\n                    processed += 1\n\n                except Exception as e:\n                    print(f\"\u274c Failed to process {image_file}: {e}\")\n\n            print(f\"\\n\ud83c\udf89 Processed {processed}/{len(image_files)} images\")\n            return processed &gt; 0\n\n        except Exception as e:\n            print(f\"\u274c Image processing failed: {e}\")\n            return False\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Batch image processing\")\n    parser.add_argument(\"input_dir\", help=\"Input directory\")\n    parser.add_argument(\"output_dir\", help=\"Output directory\")\n    parser.add_argument(\"--width\", type=int, default=800, help=\"Max width\")\n    parser.add_argument(\"--height\", type=int, default=600, help=\"Max height\")\n    parser.add_argument(\"--quality\", type=int, default=85, help=\"JPEG quality\")\n\n    args = parser.parse_args()\n\n    if not os.path.exists(args.input_dir):\n        print(f\"\u274c Input directory does not exist: {args.input_dir}\")\n        sys.exit(1)\n\n    if not process_images(args.input_dir, args.output_dir, \n                         args.width, args.height, args.quality):\n        sys.exit(1)\n</code></pre> <p>These examples demonstrate the flexibility and power of Hands Scaphoid for various automation tasks while maintaining security through command allowlisting.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Welcome to Hands Scaphoid! This guide will help you get up and running quickly with secure shell command execution in Python.</p>"},{"location":"#what-is-hands-scaphoid","title":"What is Hands Scaphoid?","text":"<p>Hands Scaphoid is a Python library that provides a secure and convenient way to execute shell commands with:</p> <ul> <li>Security: Command allowlisting prevents execution of unauthorized commands</li> <li>Environment Management: Load environment variables from files</li> <li>Docker Integration: Execute commands in Docker containers</li> <li>Clean API: Both object-oriented and script-like interfaces</li> </ul>"},{"location":"#basic-concepts","title":"Basic Concepts","text":""},{"location":"#shell-class","title":"Shell Class","text":"<p>The <code>Shell</code> class is the core of Hands Scaphoid. It provides secure command execution with environment management.</p> <pre><code>from hands_scaphoid import Shell\n\n# Create a shell instance\nshell = Shell(cwd=\"/path/to/working/dir\")\n\n# Allow commands before executing them\nshell.allow(\"echo\")\nshell.allow(\"ls\")\n\n# Execute commands\nresult = shell.run(\"echo 'Hello, World!'\")\nprint(result.stdout)  # Output: Hello, World!\n</code></pre>"},{"location":"#shellcontext-manager","title":"ShellContext Manager","text":"<p>The <code>ShellContext</code> provides a more convenient way to use Shell functionality with automatic cleanup.</p> <pre><code>from hands_scaphoid import ShellContext\n\nwith ShellContext(cwd=\"/tmp\") as shell:\n    shell.allow(\"pwd\")\n    result = shell.run(\"pwd\")\n    print(result.stdout)  # Output: /tmp\n</code></pre>"},{"location":"#global-functions","title":"Global Functions","text":"<p>For script-like usage, ShellContext can inject functions globally:</p> <pre><code>from hands_scaphoid import ShellContext\n\nwith ShellContext():\n    # These functions are now available globally\n    allow(\"echo\")\n    allow(\"git\")\n\n    cd(\"/path/to/project\")\n    run(\"git status\")\n    run(\"echo 'Done!'\")\n</code></pre>"},{"location":"#your-first-script","title":"Your First Script","text":"<p>Let's create a simple script that demonstrates the key features:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nSimple deployment script using Hands Scaphoid\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\n\ndef deploy_app():\n    with ShellContext(cwd=\"/app\") as shell:\n        # Allow the commands we need\n        shell.allow(\"git\")\n        shell.allow(\"docker\")\n        shell.allow(\"echo\")\n\n        try:\n            # Pull latest code\n            print(\"Pulling latest code...\")\n            shell.run(\"git pull origin main\")\n\n            # Build Docker image\n            print(\"Building Docker image...\")\n            shell.run(\"docker build -t myapp:latest .\")\n\n            # Check if container is running\n            print(\"Checking dependencies...\")\n            shell.depends_on([\"database\", \"redis\"])\n\n            # Deploy new version\n            print(\"Deploying new version...\")\n            shell.run(\"docker run -d --name myapp myapp:latest\")\n\n            print(\"Deployment complete!\")\n\n        except Exception as e:\n            print(f\"Deployment failed: {e}\")\n            return False\n\n    return True\n\nif __name__ == \"__main__\":\n    deploy_app()\n</code></pre>"},{"location":"#security-model","title":"Security Model","text":"<p>Hands Scaphoid uses an allowlist-based security model:</p> <ol> <li>No commands are allowed by default</li> <li>Commands must be explicitly allowed using <code>allow()</code></li> <li>Only the command name is checked, not arguments</li> <li>Commands are validated to exist on the system</li> </ol> <pre><code>with ShellContext() as shell:\n    # This will fail - command not allowed\n    try:\n        shell.run(\"rm -rf /\")\n    except PermissionError:\n        print(\"Security working!\")\n\n    # Allow the command first\n    shell.allow(\"echo\")\n    shell.run(\"echo 'This works!'\")  # This succeeds\n</code></pre>"},{"location":"#environment-management","title":"Environment Management","text":"<p>Load environment variables from files:</p> <pre><code># Create an .env file\nwith open(\".env\", \"w\") as f:\n    f.write(\"DATABASE_URL=postgresql://localhost/mydb\\n\")\n    f.write(\"API_KEY=secret123\\n\")\n\n# Use the environment file\nwith ShellContext(env_file=\".env\") as shell:\n    db_url = shell.get_env_var(\"DATABASE_URL\")\n    print(f\"Database URL: {db_url}\")\n\n    # Set additional variables\n    shell.set_env_var(\"DEPLOYMENT\", \"production\")\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<p>Hands Scaphoid provides detailed error handling:</p> <pre><code>from hands_scaphoid import ShellContext\nimport subprocess\n\nwith ShellContext() as shell:\n    shell.allow(\"ls\")\n\n    try:\n        # This will fail if directory doesn't exist\n        result = shell.run(\"ls /nonexistent\", check=True)\n    except subprocess.CalledProcessError as e:\n        print(f\"Command failed with exit code {e.returncode}\")\n        print(f\"Error output: {e.stderr}\")\n    except PermissionError as e:\n        print(f\"Security error: {e}\")\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore these advanced topics:</p> <ul> <li>Basic Usage - Detailed usage examples</li> <li>Windows Shells - Windows PowerShell and WSL support</li> <li>API Reference - Complete API documentation</li> <li>Shell Object - Complete API documentation</li> </ul>"},{"location":"#hands-scaphoid","title":"Hands Scaphoid","text":"<p>A secure shell execution context manager for Python that provides controlled command execution with environment management, command allowlisting, and Docker integration.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Secure Command Execution: Allowlist-based command execution for enhanced security</li> <li>Environment Management: Load and manage environment variables from files</li> <li>Docker Integration: Execute commands inside Docker containers</li> <li>Context Management: Clean global function injection for script-like usage</li> <li>Rich Output: Beautiful console output using Rich library</li> <li>Type Safety: Full type hints for better development experience</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from hands_scaphoid import ShellContext\n\n# Basic usage with context manager\nwith ShellContext() as shell:\n    # Allow specific commands\n    shell.allow(\"echo\")\n    shell.allow(\"ls\")\n\n    # Execute commands securely\n    result = shell.run(\"echo 'Hello, World!'\")\n    print(result.stdout)\n\n    # Change directory\n    shell.cd(\"/tmp\")\n\n    # List files\n    result = shell.run(\"ls -la\")\n    print(result.stdout)\n</code></pre>"},{"location":"#global-function-style","title":"Global Function Style","text":"<pre><code>from hands_scaphoid import ShellContext\n\n# Use global functions for script-like experience\nwith ShellContext():\n    allow(\"git\")\n    allow(\"echo\")\n\n    # Functions are available globally within the context\n    cd(\"/path/to/project\")\n    run(\"git status\")\n    run(\"echo 'Build complete'\")\n</code></pre>"},{"location":"#docker-integration","title":"Docker Integration","text":"<pre><code>from hands_scaphoid import ShellContext\n\nwith ShellContext() as shell:\n    shell.allow(\"docker\")\n\n    # Execute commands in containers\n    result = shell.run_in(\"mycontainer\", \"ls /app\")\n\n    # Check if containers are running\n    shell.depends_on([\"web\", \"database\"])\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install hands-trapezium\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> <li>Rich library for console output</li> <li>Click for CLI interface</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>For comprehensive documentation, visit: https://42sol-eu.github.io/hands_scaphoid</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.</p>"},{"location":"#author","title":"Author","text":"<p>Andreas H\u00e4berle - 42sol-eu</p>"},{"location":"examples/","title":"Examples","text":"<p>This page provides practical examples of using Hands Scaphoid in real-world scenarios.</p>"},{"location":"examples/#deployment-scripts","title":"Deployment Scripts","text":"<p>Note</p> <p>Deployment scripts </p>"},{"location":"examples/#simple-web-app-deployment","title":"Simple Web App Deployment","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nDeploy a web application using Hands Scaphoid.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport sys\n\ndef deploy_web_app(branch=\"main\", environment=\"production\"):\n    \"\"\"Deploy web application.\"\"\"\n\n    print(f\"\ud83d\ude80 Deploying from branch '{branch}' to '{environment}'...\")\n\n    with ShellContext(cwd=\"/app\") as shell:\n        # Allow required commands\n        required_commands = [\"git\", \"docker\", \"docker-compose\", \"echo\"]\n        for cmd in required_commands:\n            if not shell.allow(cmd):\n                print(f\"\u274c Required command '{cmd}' not found\")\n                return False\n\n        try:\n            # Pull latest code\n            print(\"\ud83d\udce5 Pulling latest code...\")\n            shell.run(f\"git pull origin {branch}\")\n\n            # Build new Docker image\n            print(\"\ud83d\udd28 Building Docker image...\")\n            shell.run(\"docker build -t myapp:latest .\")\n\n            # Stop old containers\n            print(\"\ud83d\uded1 Stopping old containers...\")\n            shell.run(\"docker-compose down\")\n\n            # Start new containers\n            print(\"\u25b6\ufe0f Starting new containers...\")\n            shell.run(\"docker-compose up -d\")\n\n            # Verify deployment\n            print(\"\u2705 Verifying deployment...\")\n            result = shell.run(\"docker-compose ps\")\n            if \"Up\" in result.stdout:\n                print(\"\u2705 Deployment successful!\")\n                return True\n            else:\n                print(\"\u274c Deployment verification failed\")\n                return False\n\n        except Exception as e:\n            print(f\"\u274c Deployment failed: {e}\")\n            return False\n\nif __name__ == \"__main__\":\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Deploy web application\")\n    parser.add_argument(\"--branch\", default=\"main\", help=\"Git branch to deploy\")\n    parser.add_argument(\"--env\", default=\"production\", help=\"Environment\")\n\n    args = parser.parse_args()\n\n    if not deploy_web_app(args.branch, args.env):\n        sys.exit(1)\n</code></pre>"},{"location":"examples/#database-migration-script","title":"Database Migration Script","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nDatabase migration script with backup.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nfrom datetime import datetime\nimport sys\n\ndef migrate_database():\n    \"\"\"Run database migrations with backup.\"\"\"\n\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    backup_file = f\"backup_{timestamp}.sql\"\n\n    with ShellContext() as shell:\n        # Allow database commands\n        for cmd in [\"pg_dump\", \"psql\", \"echo\"]:\n            if not shell.allow(cmd):\n                print(f\"\u274c Database command '{cmd}' not available\")\n                return False\n\n        try:\n            # Create backup\n            print(\"\ud83d\udcbe Creating database backup...\")\n            shell.run(f\"pg_dump myapp_prod &gt; {backup_file}\")\n\n            # Run migrations\n            print(\"\ud83d\udd04 Running migrations...\")\n            shell.run(\"psql myapp_prod &lt; migrations/latest.sql\")\n\n            # Verify migration\n            print(\"\u2705 Migration completed successfully!\")\n            print(f\"\ud83d\udcbe Backup saved as: {backup_file}\")\n            return True\n\n        except Exception as e:\n            print(f\"\u274c Migration failed: {e}\")\n            print(f\"\ud83d\udd04 Restoring from backup: {backup_file}\")\n            try:\n                shell.run(f\"psql myapp_prod &lt; {backup_file}\")\n                print(\"\u2705 Database restored from backup\")\n            except Exception as restore_error:\n                print(f\"\u274c Backup restoration failed: {restore_error}\")\n            return False\n\nif __name__ == \"__main__\":\n    if not migrate_database():\n        sys.exit(1)\n</code></pre>"},{"location":"examples/#development-workflows","title":"Development Workflows","text":""},{"location":"examples/#project-setup-automation","title":"Project Setup Automation","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nAutomated project setup script.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport sys\nimport os\n\ndef setup_project(project_name: str, template: str = \"python\"):\n    \"\"\"Set up a new project from template.\"\"\"\n\n    project_dir = f\"/workspace/{project_name}\"\n\n    with ShellContext() as shell:\n        # Allow development tools\n        dev_tools = [\"git\", \"python\", \"pip\", \"npm\", \"mkdir\", \"cp\", \"echo\"]\n        for tool in dev_tools:\n            shell.allow(tool)\n\n        try:\n            # Create project directory\n            print(f\"\ud83d\udcc1 Creating project directory: {project_dir}\")\n            shell.run(f\"mkdir -p {project_dir}\")\n            shell.cd(project_dir)\n\n            # Initialize git repository\n            print(\"\ud83d\udd27 Initializing Git repository...\")\n            shell.run(\"git init\")\n\n            if template == \"python\":\n                setup_python_project(shell, project_name)\n            elif template == \"node\":\n                setup_node_project(shell, project_name)\n            else:\n                print(f\"\u274c Unknown template: {template}\")\n                return False\n\n            # Create initial commit\n            print(\"\ud83d\udcbe Creating initial commit...\")\n            shell.run(\"git add .\")\n            shell.run(f\"git commit -m 'Initial commit for {project_name}'\")\n\n            print(f\"\u2705 Project '{project_name}' set up successfully!\")\n            print(f\"\ud83d\udcc1 Location: {project_dir}\")\n            return True\n\n        except Exception as e:\n            print(f\"\u274c Project setup failed: {e}\")\n            return False\n\ndef setup_python_project(shell, project_name):\n    \"\"\"Set up Python project structure.\"\"\"\n    print(\"\ud83d\udc0d Setting up Python project...\")\n\n    # Create Python project structure\n    shell.run(f\"mkdir -p {project_name}\")\n    shell.run(f\"mkdir -p tests\")\n    shell.run(f\"mkdir -p docs\")\n\n    # Create basic files\n    pyproject_content = f'''[project]\nname = \"{project_name}\"\nversion = \"0.1.0\"\ndescription = \"\"\nrequires-python = \"&gt;=3.11\"\ndependencies = []\n'''\n\n    with open(\"pyproject.toml\", \"w\") as f:\n        f.write(pyproject_content)\n\n    # Create virtual environment\n    shell.run(\"python -m venv .venv\")\n\n    print(\"\u2705 Python project structure created\")\n\ndef setup_node_project(shell, project_name):\n    \"\"\"Set up Node.js project structure.\"\"\"\n    print(\"\ud83d\udce6 Setting up Node.js project...\")\n\n    # Initialize npm project\n    shell.run(\"npm init -y\")\n\n    # Create basic structure\n    shell.run(\"mkdir -p src\")\n    shell.run(\"mkdir -p tests\")\n    shell.run(\"mkdir -p docs\")\n\n    print(\"\u2705 Node.js project structure created\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) &lt; 2:\n        print(\"Usage: setup_project.py &lt;project_name&gt; [template]\")\n        sys.exit(1)\n\n    project_name = sys.argv[1]\n    template = sys.argv[2] if len(sys.argv) &gt; 2 else \"python\"\n\n    if not setup_project(project_name, template):\n        sys.exit(1)\n</code></pre>"},{"location":"examples/#automated-testing-pipeline","title":"Automated Testing Pipeline","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComprehensive testing pipeline.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport sys\n\ndef run_test_pipeline():\n    \"\"\"Run complete testing pipeline.\"\"\"\n\n    with ShellContext() as shell:\n        # Allow testing tools\n        test_tools = [\"python\", \"pytest\", \"flake8\", \"mypy\", \"black\", \"echo\"]\n        for tool in test_tools:\n            if not shell.allow(tool):\n                print(f\"\u26a0\ufe0f Testing tool '{tool}' not available\")\n\n        tests_passed = True\n\n        # Code formatting check\n        print(\"\ud83c\udfa8 Checking code formatting...\")\n        try:\n            shell.run(\"black --check src tests\")\n            print(\"\u2705 Code formatting OK\")\n        except Exception:\n            print(\"\u274c Code formatting issues found\")\n            tests_passed = False\n\n        # Linting\n        print(\"\ud83d\udd0d Running linter...\")\n        try:\n            shell.run(\"flake8 src tests\")\n            print(\"\u2705 Linting passed\")\n        except Exception:\n            print(\"\u274c Linting issues found\")\n            tests_passed = False\n\n        # Type checking\n        print(\"\ud83d\udd2c Type checking...\")\n        try:\n            shell.run(\"mypy src\")\n            print(\"\u2705 Type checking passed\")\n        except Exception:\n            print(\"\u274c Type checking issues found\")\n            tests_passed = False\n\n        # Unit tests\n        print(\"\ud83e\uddea Running unit tests...\")\n        try:\n            result = shell.run(\"pytest tests/ -v --cov\")\n            print(\"\u2705 Unit tests passed\")\n\n            # Extract coverage percentage\n            coverage_line = [line for line in result.stdout.split('\\n') \n                           if 'TOTAL' in line and '%' in line]\n            if coverage_line:\n                print(f\"\ud83d\udcca {coverage_line[0]}\")\n\n        except Exception:\n            print(\"\u274c Unit tests failed\")\n            tests_passed = False\n\n        if tests_passed:\n            print(\"\\n\ud83c\udf89 All tests passed! Ready for deployment.\")\n            return True\n        else:\n            print(\"\\n\u274c Some tests failed. Please fix issues before deployment.\")\n            return False\n\nif __name__ == \"__main__\":\n    if not run_test_pipeline():\n        sys.exit(1)\n</code></pre>"},{"location":"examples/#devops-automation","title":"DevOps Automation","text":""},{"location":"examples/#container-management","title":"Container Management","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nDocker container management utilities.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport json\nimport sys\n\ndef manage_containers(action: str, service: str = None):\n    \"\"\"Manage Docker containers.\"\"\"\n\n    with ShellContext() as shell:\n        shell.allow(\"docker\")\n        shell.allow(\"docker-compose\")\n\n        try:\n            if action == \"status\":\n                show_container_status(shell)\n            elif action == \"logs\":\n                show_container_logs(shell, service)\n            elif action == \"restart\":\n                restart_service(shell, service)\n            elif action == \"health\":\n                check_health(shell)\n            else:\n                print(f\"\u274c Unknown action: {action}\")\n                return False\n\n            return True\n\n        except Exception as e:\n            print(f\"\u274c Container management failed: {e}\")\n            return False\n\ndef show_container_status(shell):\n    \"\"\"Show status of all containers.\"\"\"\n    print(\"\ud83d\udcca Container Status:\")\n    print(\"-\" * 50)\n\n    result = shell.run(\"docker-compose ps\")\n    print(result.stdout)\n\ndef show_container_logs(shell, service):\n    \"\"\"Show logs for a specific service.\"\"\"\n    if not service:\n        print(\"\u274c Service name required for logs\")\n        return\n\n    print(f\"\ud83d\udcdd Logs for {service}:\")\n    print(\"-\" * 50)\n\n    result = shell.run(f\"docker-compose logs --tail=50 {service}\")\n    print(result.stdout)\n\ndef restart_service(shell, service):\n    \"\"\"Restart a specific service.\"\"\"\n    if not service:\n        print(\"\u274c Service name required for restart\")\n        return\n\n    print(f\"\ud83d\udd04 Restarting {service}...\")\n    shell.run(f\"docker-compose restart {service}\")\n    print(f\"\u2705 {service} restarted\")\n\ndef check_health(shell):\n    \"\"\"Check health of all services.\"\"\"\n    print(\"\ud83c\udfe5 Health Check:\")\n    print(\"-\" * 50)\n\n    # Get container info\n    result = shell.run(\"docker ps --format '{{.Names}}\\t{{.Status}}'\")\n\n    for line in result.stdout.strip().split('\\n'):\n        if line:\n            name, status = line.split('\\t', 1)\n            if 'healthy' in status.lower():\n                print(f\"\u2705 {name}: {status}\")\n            elif 'unhealthy' in status.lower():\n                print(f\"\u274c {name}: {status}\")\n            else:\n                print(f\"\u26a0\ufe0f {name}: {status}\")\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Container management\")\n    parser.add_argument(\"action\", choices=[\"status\", \"logs\", \"restart\", \"health\"])\n    parser.add_argument(\"--service\", help=\"Service name\")\n\n    args = parser.parse_args()\n\n    if not manage_containers(args.action, args.service):\n        sys.exit(1)\n</code></pre>"},{"location":"examples/#system-monitoring","title":"System Monitoring","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSystem monitoring and alerts.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport time\nimport sys\n\ndef monitor_system(duration_minutes: int = 5):\n    \"\"\"Monitor system resources and services.\"\"\"\n\n    end_time = time.time() + (duration_minutes * 60)\n\n    with ShellContext() as shell:\n        # Allow monitoring commands\n        monitor_commands = [\"ps\", \"df\", \"free\", \"top\", \"docker\", \"curl\"]\n        for cmd in monitor_commands:\n            shell.allow(cmd)\n\n        print(f\"\ud83d\udd0d Starting system monitoring for {duration_minutes} minutes...\")\n\n        while time.time() &lt; end_time:\n            print(f\"\\n\ud83d\udcca System Check - {time.strftime('%H:%M:%S')}\")\n            print(\"-\" * 50)\n\n            # Check disk usage\n            check_disk_usage(shell)\n\n            # Check memory usage\n            check_memory_usage(shell)\n\n            # Check running services\n            check_services(shell)\n\n            # Check application health\n            check_application_health(shell)\n\n            # Wait before next check\n            time.sleep(30)\n\n        print(\"\\n\u2705 Monitoring completed\")\n\ndef check_disk_usage(shell):\n    \"\"\"Check disk usage.\"\"\"\n    result = shell.run(\"df -h /\")\n    lines = result.stdout.strip().split('\\n')\n    if len(lines) &gt; 1:\n        usage_line = lines[1].split()\n        usage_percent = usage_line[4].rstrip('%')\n\n        if int(usage_percent) &gt; 90:\n            print(f\"\ud83d\udd34 Disk usage: {usage_percent}% (CRITICAL)\")\n        elif int(usage_percent) &gt; 80:\n            print(f\"\ud83d\udfe1 Disk usage: {usage_percent}% (WARNING)\")\n        else:\n            print(f\"\ud83d\udfe2 Disk usage: {usage_percent}% (OK)\")\n\ndef check_memory_usage(shell):\n    \"\"\"Check memory usage.\"\"\"\n    result = shell.run(\"free -m\")\n    lines = result.stdout.strip().split('\\n')\n    if len(lines) &gt; 1:\n        mem_line = lines[1].split()\n        total = int(mem_line[1])\n        used = int(mem_line[2])\n        usage_percent = (used / total) * 100\n\n        if usage_percent &gt; 90:\n            print(f\"\ud83d\udd34 Memory usage: {usage_percent:.1f}% (CRITICAL)\")\n        elif usage_percent &gt; 80:\n            print(f\"\ud83d\udfe1 Memory usage: {usage_percent:.1f}% (WARNING)\")\n        else:\n            print(f\"\ud83d\udfe2 Memory usage: {usage_percent:.1f}% (OK)\")\n\ndef check_services(shell):\n    \"\"\"Check running services.\"\"\"\n    try:\n        result = shell.run(\"docker-compose ps\", check=False)\n        if result.returncode == 0:\n            # Count running containers\n            running = result.stdout.count(\"Up\")\n            total = len([line for line in result.stdout.split('\\n') \n                        if line and not line.startswith('Name')])\n\n            if running == total:\n                print(f\"\ud83d\udfe2 Services: {running}/{total} running (OK)\")\n            else:\n                print(f\"\ud83d\udd34 Services: {running}/{total} running (ISSUES)\")\n        else:\n            print(\"\u26a0\ufe0f Could not check services\")\n    except Exception:\n        print(\"\u26a0\ufe0f Service check failed\")\n\ndef check_application_health(shell):\n    \"\"\"Check application health endpoints.\"\"\"\n    try:\n        result = shell.run(\"curl -s -o /dev/null -w '%{http_code}' http://localhost:8080/health\", \n                          check=False)\n        status_code = result.stdout.strip()\n\n        if status_code == \"200\":\n            print(\"\ud83d\udfe2 Application health: OK\")\n        else:\n            print(f\"\ud83d\udd34 Application health: HTTP {status_code}\")\n    except Exception:\n        print(\"\ud83d\udd34 Application health: UNREACHABLE\")\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"System monitoring\")\n    parser.add_argument(\"--duration\", type=int, default=5, \n                       help=\"Monitoring duration in minutes\")\n\n    args = parser.parse_args()\n\n    try:\n        monitor_system(args.duration)\n    except KeyboardInterrupt:\n        print(\"\\n\u23f9\ufe0f Monitoring stopped by user\")\n</code></pre>"},{"location":"examples/#file-processing","title":"File Processing","text":""},{"location":"examples/#batch-image-processing","title":"Batch Image Processing","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nBatch image processing with ImageMagick.\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\nimport os\nimport sys\n\ndef process_images(input_dir: str, output_dir: str, \n                  width: int = 800, height: int = 600, quality: int = 85):\n    \"\"\"Process images in batch.\"\"\"\n\n    with ShellContext(cwd=input_dir) as shell:\n        # Allow image processing commands\n        shell.allow(\"find\")\n        shell.allow(\"convert\")  # ImageMagick\n        shell.allow(\"mkdir\")\n        shell.allow(\"identify\")\n\n        try:\n            # Create output directory\n            shell.run(f\"mkdir -p {output_dir}\")\n\n            # Find image files\n            result = shell.run(\"find . -type f \\\\( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' \\\\)\")\n\n            image_files = [f.strip() for f in result.stdout.split('\\n') if f.strip()]\n\n            if not image_files:\n                print(\"\u274c No image files found\")\n                return False\n\n            print(f\"\ud83d\udcf7 Found {len(image_files)} images to process\")\n\n            processed = 0\n            for image_file in image_files:\n                try:\n                    # Get original image info\n                    info_result = shell.run(f\"identify -format '%wx%h' '{image_file}'\")\n                    original_size = info_result.stdout.strip()\n\n                    # Generate output filename\n                    output_file = os.path.join(output_dir, \n                                             os.path.basename(image_file))\n\n                    # Process image\n                    convert_cmd = (f\"convert '{image_file}' \"\n                                 f\"-resize {width}x{height}&gt; \"\n                                 f\"-quality {quality} \"\n                                 f\"'{output_file}'\")\n\n                    shell.run(convert_cmd)\n\n                    # Get new image info\n                    new_info_result = shell.run(f\"identify -format '%wx%h' '{output_file}'\")\n                    new_size = new_info_result.stdout.strip()\n\n                    print(f\"\u2705 {image_file}: {original_size} \u2192 {new_size}\")\n                    processed += 1\n\n                except Exception as e:\n                    print(f\"\u274c Failed to process {image_file}: {e}\")\n\n            print(f\"\\n\ud83c\udf89 Processed {processed}/{len(image_files)} images\")\n            return processed &gt; 0\n\n        except Exception as e:\n            print(f\"\u274c Image processing failed: {e}\")\n            return False\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Batch image processing\")\n    parser.add_argument(\"input_dir\", help=\"Input directory\")\n    parser.add_argument(\"output_dir\", help=\"Output directory\")\n    parser.add_argument(\"--width\", type=int, default=800, help=\"Max width\")\n    parser.add_argument(\"--height\", type=int, default=600, help=\"Max height\")\n    parser.add_argument(\"--quality\", type=int, default=85, help=\"JPEG quality\")\n\n    args = parser.parse_args()\n\n    if not os.path.exists(args.input_dir):\n        print(f\"\u274c Input directory does not exist: {args.input_dir}\")\n        sys.exit(1)\n\n    if not process_images(args.input_dir, args.output_dir, \n                         args.width, args.height, args.quality):\n        sys.exit(1)\n</code></pre> <p>These examples demonstrate the flexibility and power of Hands Scaphoid for various automation tasks while maintaining security through command allowlisting.</p>"},{"location":"examples/#getting-started","title":"Getting Started","text":"<p>Welcome to Hands Scaphoid! This guide will help you get up and running quickly with secure shell command execution in Python.</p>"},{"location":"examples/#what-is-hands-scaphoid","title":"What is Hands Scaphoid?","text":"<p>Hands Scaphoid is a Python library that provides a secure and convenient way to execute shell commands with:</p> <ul> <li>Security: Command allowlisting prevents execution of unauthorized commands</li> <li>Environment Management: Load environment variables from files</li> <li>Docker Integration: Execute commands in Docker containers</li> <li>Clean API: Both object-oriented and script-like interfaces</li> </ul>"},{"location":"examples/#basic-concepts","title":"Basic Concepts","text":""},{"location":"examples/#shell-class","title":"Shell Class","text":"<p>The <code>Shell</code> class is the core of Hands Scaphoid. It provides secure command execution with environment management.</p> <pre><code>from hands_scaphoid import Shell\n\n# Create a shell instance\nshell = Shell(cwd=\"/path/to/working/dir\")\n\n# Allow commands before executing them\nshell.allow(\"echo\")\nshell.allow(\"ls\")\n\n# Execute commands\nresult = shell.run(\"echo 'Hello, World!'\")\nprint(result.stdout)  # Output: Hello, World!\n</code></pre>"},{"location":"examples/#shellcontext-manager","title":"ShellContext Manager","text":"<p>The <code>ShellContext</code> provides a more convenient way to use Shell functionality with automatic cleanup.</p> <pre><code>from hands_scaphoid import ShellContext\n\nwith ShellContext(cwd=\"/tmp\") as shell:\n    shell.allow(\"pwd\")\n    result = shell.run(\"pwd\")\n    print(result.stdout)  # Output: /tmp\n</code></pre>"},{"location":"examples/#global-functions","title":"Global Functions","text":"<p>For script-like usage, ShellContext can inject functions globally:</p> <pre><code>from hands_scaphoid import ShellContext\n\nwith ShellContext():\n    # These functions are now available globally\n    allow(\"echo\")\n    allow(\"git\")\n\n    cd(\"/path/to/project\")\n    run(\"git status\")\n    run(\"echo 'Done!'\")\n</code></pre>"},{"location":"examples/#your-first-script","title":"Your First Script","text":"<p>Let's create a simple script that demonstrates the key features:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nSimple deployment script using Hands Scaphoid\n\"\"\"\n\nfrom hands_scaphoid import ShellContext\n\ndef deploy_app():\n    with ShellContext(cwd=\"/app\") as shell:\n        # Allow the commands we need\n        shell.allow(\"git\")\n        shell.allow(\"docker\")\n        shell.allow(\"echo\")\n\n        try:\n            # Pull latest code\n            print(\"Pulling latest code...\")\n            shell.run(\"git pull origin main\")\n\n            # Build Docker image\n            print(\"Building Docker image...\")\n            shell.run(\"docker build -t myapp:latest .\")\n\n            # Check if container is running\n            print(\"Checking dependencies...\")\n            shell.depends_on([\"database\", \"redis\"])\n\n            # Deploy new version\n            print(\"Deploying new version...\")\n            shell.run(\"docker run -d --name myapp myapp:latest\")\n\n            print(\"Deployment complete!\")\n\n        except Exception as e:\n            print(f\"Deployment failed: {e}\")\n            return False\n\n    return True\n\nif __name__ == \"__main__\":\n    deploy_app()\n</code></pre>"},{"location":"examples/#security-model","title":"Security Model","text":"<p>Hands Scaphoid uses an allowlist-based security model:</p> <ol> <li>No commands are allowed by default</li> <li>Commands must be explicitly allowed using <code>allow()</code></li> <li>Only the command name is checked, not arguments</li> <li>Commands are validated to exist on the system</li> </ol> <pre><code>with ShellContext() as shell:\n    # This will fail - command not allowed\n    try:\n        shell.run(\"rm -rf /\")\n    except PermissionError:\n        print(\"Security working!\")\n\n    # Allow the command first\n    shell.allow(\"echo\")\n    shell.run(\"echo 'This works!'\")  # This succeeds\n</code></pre>"},{"location":"examples/#environment-management","title":"Environment Management","text":"<p>Load environment variables from files:</p> <pre><code># Create an .env file\nwith open(\".env\", \"w\") as f:\n    f.write(\"DATABASE_URL=postgresql://localhost/mydb\\n\")\n    f.write(\"API_KEY=secret123\\n\")\n\n# Use the environment file\nwith ShellContext(env_file=\".env\") as shell:\n    db_url = shell.get_env_var(\"DATABASE_URL\")\n    print(f\"Database URL: {db_url}\")\n\n    # Set additional variables\n    shell.set_env_var(\"DEPLOYMENT\", \"production\")\n</code></pre>"},{"location":"examples/#error-handling","title":"Error Handling","text":"<p>Hands Scaphoid provides detailed error handling:</p> <pre><code>from hands_scaphoid import ShellContext\nimport subprocess\n\nwith ShellContext() as shell:\n    shell.allow(\"ls\")\n\n    try:\n        # This will fail if directory doesn't exist\n        result = shell.run(\"ls /nonexistent\", check=True)\n    except subprocess.CalledProcessError as e:\n        print(f\"Command failed with exit code {e.returncode}\")\n        print(f\"Error output: {e.stderr}\")\n    except PermissionError as e:\n        print(f\"Security error: {e}\")\n</code></pre>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore these advanced topics:</p> <ul> <li>Basic Usage - Detailed usage examples</li> <li>PowerShell - Windows PowerShell and WSL support</li> <li>SshShell - Windows PowerShell and WSL support</li> <li>WslShell - Windows PowerShell and WSL support</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"examples/#hands-scaphoid","title":"Hands Scaphoid","text":"<p>A secure shell execution context manager for Python that provides controlled command execution with environment management, command allowlisting, and Docker integration.</p>"},{"location":"examples/#features","title":"Features","text":"<ul> <li>Secure Command Execution: Allowlist-based command execution for enhanced security</li> <li>Environment Management: Load and manage environment variables from files</li> <li>Docker Integration: Execute commands inside Docker containers</li> <li>Context Management: Clean global function injection for script-like usage</li> <li>Rich Output: Beautiful console output using Rich library</li> <li>Type Safety: Full type hints for better development experience</li> </ul>"},{"location":"examples/#quick-start","title":"Quick Start","text":"<pre><code>from hands_scaphoid import ShellContext\n\n# Basic usage with context manager\nwith ShellContext() as shell:\n    # Allow specific commands\n    shell.allow(\"echo\")\n    shell.allow(\"ls\")\n\n    # Execute commands securely\n    result = shell.run(\"echo 'Hello, World!'\")\n    print(result.stdout)\n\n    # Change directory\n    shell.cd(\"/tmp\")\n\n    # List files\n    result = shell.run(\"ls -la\")\n    print(result.stdout)\n</code></pre>"},{"location":"examples/#global-function-style","title":"Global Function Style","text":"<pre><code>from hands_scaphoid import ShellContext\n\n# Use global functions for script-like experience\nwith ShellContext():\n    allow(\"git\")\n    allow(\"echo\")\n\n    # Functions are available globally within the context\n    cd(\"/path/to/project\")\n    run(\"git status\")\n    run(\"echo 'Build complete'\")\n</code></pre>"},{"location":"examples/#docker-integration","title":"Docker Integration","text":"<pre><code>from hands_scaphoid import ShellContext\n\nwith ShellContext() as shell:\n    shell.allow(\"docker\")\n\n    # Execute commands in containers\n    result = shell.run_in(\"mycontainer\", \"ls /app\")\n\n    # Check if containers are running\n    shell.depends_on([\"web\", \"database\"])\n</code></pre>"},{"location":"examples/#installation","title":"Installation","text":"<pre><code>pip install hands-trapezium\n</code></pre>"},{"location":"examples/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> <li>Rich library for console output</li> <li>Click for CLI interface</li> </ul>"},{"location":"examples/#documentation","title":"Documentation","text":"<p>For comprehensive documentation, visit: https://42sol-eu.github.io/hands_scaphoid</p>"},{"location":"getting-started/","title":"Getting Started with Hands Scaphoid","text":"<p>This guide will help you get started with Hands Scaphoid for hierarchical file system operations.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install hands-scaphoid\n</code></pre>"},{"location":"getting-started/#basic-concepts","title":"Basic Concepts","text":""},{"location":"getting-started/#operations-vs-context-classes","title":"Operations vs Context Classes","text":"<p>Hands Scaphoid provides two ways to work with files, directories, and archives:</p> <ol> <li>Operations Classes: Direct static methods for simple operations</li> <li><code>FileObject.read_content(path)</code></li> <li><code>DirectoryObject.create_directory(path)</code></li> <li> <p><code>ArchiveFile.create_zip_archive(target, source)</code></p> </li> <li> <p>Context Classes: Context managers for hierarchical operations</p> </li> <li><code>FileContext(path)</code> - for file operations with context</li> <li><code>DirectoryContext(path)</code> - for directory operations with context  </li> <li><code>ArchiveContext(source, target)</code> - for archive operations with context</li> </ol>"},{"location":"getting-started/#path-resolution","title":"Path Resolution","text":"<p>Context managers maintain a stack of current directories. All paths are resolved relative to the current context:</p> <pre><code>from hands_scaphoid.contexts import DirectoryContext, FileContext\n\nwith DirectoryContext('~/projects') as projects:\n    # Current context: ~/projects\n\n    with DirectoryContext('myproject') as project:\n        # Current context: ~/projects/myproject\n\n        with FileContext('config.txt') as config:\n            # File path resolves to: ~/projects/myproject/config.txt\n            config.write_content('debug=true')\n</code></pre>"},{"location":"getting-started/#file-operations","title":"File Operations","text":""},{"location":"getting-started/#reading-files","title":"Reading Files","text":"<pre><code>from hands_scaphoid.contexts import FileContext\nfrom hands_scaphoid.objects import FileObject\n\n# Using context manager\nwith FileContext('data.txt') as f:\n    content = f.read_content()\n    lines = f.read_lines()\n\n# Using operations class directly\nfrom hands_scaphoid.objects import FileObject\ncontent = FileObject.read_content('data.txt')\nlines = FileObject.read_lines('data.txt')\n</code></pre>"},{"location":"getting-started/#writing-files","title":"Writing Files","text":"<pre><code># Context manager approach\nwith FileContext('output.txt') as f:\n    f.write_content('Hello, World!')\n    f.append_line('New line')\n    f.add_heading('Section 1')\n\n# Direct operations\nFileObject.write_content('output.txt', 'Hello, World!')\nFileObject.append_line('output.txt', 'New line')\n</code></pre>"},{"location":"getting-started/#method-chaining","title":"Method Chaining","text":"<p>Context classes support method chaining for fluent operations:</p> <pre><code>with FileContext('report.txt') as report:\n    report.write_content('Report Data')\\\n          .add_heading('Summary')\\\n          .append_line('Total: 100')\\\n          .append_line('Average: 25')\n</code></pre>"},{"location":"getting-started/#directory-operations","title":"Directory Operations","text":""},{"location":"getting-started/#creating-directory-structures","title":"Creating Directory Structures","text":"<pre><code>from hands_scaphoid.contexts import DirectoryContext\nfrom hands_scaphoid.objects import DirectoryObject\n\n# Using context manager for hierarchical operations\nwith DirectoryContext('~/projects') as projects:\n    with DirectoryContext('newproject', create=True) as project:\n        # Create subdirectories\n        project.create_directory('src')\n        project.create_directory('tests')\n        project.create_directory('docs')\n\n        # Navigate and create files\n        with DirectoryContext('src') as src:\n            src.create_file('main.py', '#!/usr/bin/env python3\\nprint(\"Hello!\")')\n\n# Direct operations\nDirectoryObject.create_directory('path/to/new/directory')\nDirectoryObject.create_file('path/to/file.txt', 'content')\n</code></pre>"},{"location":"getting-started/#directory-navigation","title":"Directory Navigation","text":"<pre><code>with DirectoryContext('~') as home:\n    # List contents of home directory\n    files = home.list_contents()\n    print(f\"Home contains: {files}\")\n\n    with DirectoryContext('Documents') as docs:\n        # Now in ~/Documents\n        doc_files = docs.list_contents()\n\n        # Create a new subdirectory\n        docs.create_directory('Projects')\n</code></pre>"},{"location":"getting-started/#copying-and-moving","title":"Copying and Moving","text":"<pre><code># Copy directories with context\nwith DirectoryContext('~/projects') as projects:\n    projects.copy_directory('template', 'new_project')\n\n    # Move into the new project\n    with DirectoryContext('new_project') as project:\n        # Customize the project\n        project.create_file('config.json', '{\"name\": \"My Project\"}')\n\n# Direct operations\nDirectoryObject.copy_directory('source_dir', 'destination_dir')\n</code></pre>"},{"location":"getting-started/#archive-operations","title":"Archive Operations","text":""},{"location":"getting-started/#creating-archives","title":"Creating Archives","text":"<pre><code>from hands_scaphoid.contexts import ArchiveContext\nfrom hands_scaphoid.objects import ArchiveFile\n\n# Create ZIP archive with context\nwith DirectoryContext('~/projects') as projects:\n    with ArchiveContext(source='myproject', target='backup.zip') as archive:\n        # Archive is automatically created with the source directory\n        contents = archive.list_contents()\n        print(f\"Archive contains: {contents}\")\n\n# Create TAR.GZ archive\nwith ArchiveContext(source='myproject', target='backup.tar.gz', archive_type='tar.gz') as archive:\n    info = archive.get_archive_info()\n    print(f\"Compression ratio: {info['compression_ratio']:.2f}\")\n\n# Direct operations\nArchiveFile.create_zip_archive('backup.zip', 'source_directory')\nArchiveFile.create_tar_archive('backup.tar.gz', 'source_directory', 'gz')\n</code></pre>"},{"location":"getting-started/#extracting-archives","title":"Extracting Archives","text":"<pre><code># Extract with context\nwith DirectoryContext('~/backups') as backups:\n    with ArchiveContext(target='project_backup.zip') as archive:\n        # Extract all contents\n        archive.extract_all('restored_project')\n\n        # Or extract specific files\n        archive.extract_file('README.md', 'extracted_readme')\n\n# Direct operations\nArchiveFile.extract_archive('backup.zip', 'output_directory')\n</code></pre>"},{"location":"getting-started/#selective-archiving","title":"Selective Archiving","text":"<pre><code># Create archive by adding files selectively\nwith ArchiveContext(target='selective_backup.zip') as archive:\n    archive.add_file('important_config.json')\n    archive.add_file('critical_data.csv')\n    archive.add_directory('essential_scripts')\n\n    # Check what we've added\n    contents = archive.list_contents()\n    print(f\"Selective archive contains: {contents}\")\n</code></pre>"},{"location":"getting-started/#global-functions-mode","title":"Global Functions Mode","text":"<p>For script-like usage, enable global functions within contexts:</p> <pre><code>from hands_scaphoid.contexts import DirectoryContext\n\n# Enable global functions\nwith DirectoryContext('~/projects', enable_globals=True):\n    # Functions are now available globally\n    create_directory('newproject')\n    change_directory('newproject')\n\n    # Create project structure\n    create_file('README.md', '# My Project')\n    create_directory('src')\n    create_directory('tests')\n\n    # Navigate and create more files\n    change_directory('src')\n    create_file('main.py', '''#!/usr/bin/env python3\n\"\"\"Main module for my project.\"\"\"\n\ndef main():\n    print(\"Hello from my project!\")\n\nif __name__ == \"__main__\":\n    main()\n''')\n\n    # Go back and list contents\n    change_directory('..')\n    files = list_contents('.')\n    print(f\"Project structure: {files}\")\n</code></pre>"},{"location":"getting-started/#dry-run-mode","title":"Dry Run Mode","text":"<p>Test operations without making actual changes:</p> <pre><code># Dry run mode shows what would happen\nwith DirectoryContext('~/test', dry_run=True) as test:\n    test.create_directory('newdir')  # Shows: [DRY RUN] Would create directory\n    test.create_file('test.txt', 'content')  # Shows: [DRY RUN] Would create file\n\nwith FileContext('test.txt', dry_run=True) as f:\n    f.write_content('new content')  # Shows: [DRY RUN] Would write to file\n    f.append_line('extra line')  # Shows: [DRY RUN] Would append to file\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<p>Hands Scaphoid provides clear error handling:</p> <pre><code>from pathlib import Path\n\ntry:\n    with DirectoryContext('/nonexistent/path') as ctx:\n        ctx.create_file('test.txt', 'content')\nexcept FileNotFoundError as e:\n    print(f\"Directory not found: {e}\")\n\ntry:\n    content = File.read_content('missing_file.txt')\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\n\n# Check if paths exist before operations\nif Directory.directory_exists('path/to/check'):\n    with DirectoryContext('path/to/check') as ctx:\n        # Safe to proceed\n        files = ctx.list_contents()\n</code></pre>"},{"location":"getting-started/#rich-console-output","title":"Rich Console Output","text":"<p>All operations provide beautiful colored console output:</p> <ul> <li>\u2705 Green: Successful operations</li> <li>\u274c Red: Errors and failures  </li> <li>\u26a0\ufe0f Yellow: Warnings and notes</li> <li>\ud83d\udcc1 Blue: Directory operations</li> <li>\ud83d\udcc4 Cyan: File operations</li> <li>\ud83d\udce6 Magenta: Archive operations</li> <li>\ud83d\udd04 Dim: Dry run operations</li> </ul>"},{"location":"getting-started/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates multiple features:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete project setup example using Hands Scaphoid.\n\"\"\"\n\nfrom hands_scaphoid import DirectoryContext, FileContext, ArchiveContext\n\ndef setup_python_project(project_name: str):\n    \"\"\"Set up a complete Python project structure.\"\"\"\n\n    with DirectoryContext('~/projects') as projects:\n        # Create project directory\n        with DirectoryContext(project_name, create=True) as project:\n            print(f\"Setting up Python project: {project_name}\")\n\n            # Create project structure\n            project.create_directory('src')\n            project.create_directory('tests')\n            project.create_directory('docs')\n\n            # Create main package\n            with DirectoryContext('src') as src:\n                with DirectoryContext(project_name, create=True) as pkg:\n                    # Package __init__.py\n                    with FileContext('__init__.py') as init:\n                        init.write_content(f'\"\"\"The {project_name} package.\"\"\"')\\\n                            .append_line(f'__version__ = \"0.1.0\"')\n\n                    # Main module\n                    with FileContext('main.py') as main:\n                        main.write_content('#!/usr/bin/env python3')\\\n                            .append_line(f'\"\"\"Main module for {project_name}.\"\"\"')\\\n                            .append_line('')\\\n                            .append_line('def main():')\\\n                            .append_line(f'    print(\"Hello from {project_name}!\")')\\\n                            .append_line('')\\\n                            .append_line('if __name__ == \"__main__\":')\\\n                            .append_line('    main()')\n\n            # Create tests\n            with DirectoryContext('tests') as tests:\n                with FileContext('test_main.py') as test:\n                    test.write_content(f'\"\"\"Tests for {project_name}.\"\"\"')\\\n                        .append_line('import pytest')\\\n                        .append_line(f'from {project_name} import main')\\\n                        .append_line('')\\\n                        .append_line('def test_main():')\\\n                        .append_line('    \"\"\"Test the main function.\"\"\"')\\\n                        .append_line('    # Test implementation here')\\\n                        .append_line('    pass')\n\n            # Create documentation\n            with DirectoryContext('docs') as docs:\n                with FileContext('README.md') as readme:\n                    readme.write_content(f'# {project_name.title()}')\\\n                          .append_line('')\\\n                          .append_line('A Python project created with Hands Scaphoid.')\\\n                          .append_line('')\\\n                          .add_heading('Installation')\\\n                          .append_line('```bash')\\\n                          .append_line('pip install -e .')\\\n                          .append_line('```')\\\n                          .append_line('')\\\n                          .add_heading('Usage')\\\n                          .append_line('```python')\\\n                          .append_line(f'from {project_name} import main')\\\n                          .append_line('main()')\\\n                          .append_line('```')\n\n            # Create pyproject.toml\n            with FileContext('pyproject.toml') as pyproject:\n                pyproject.write_content('[build-system]')\\\n                         .append_line('requires = [\"setuptools&gt;=45\", \"wheel\"]')\\\n                         .append_line('build-backend = \"setuptools.build_meta\"')\\\n                         .append_line('')\\\n                         .append_line('[project]')\\\n                         .append_line(f'name = \"{project_name}\"')\\\n                         .append_line('version = \"0.1.0\"')\\\n                         .append_line('description = \"A Python project\"')\\\n                         .append_line('authors = [{name = \"Your Name\", email = \"your@email.com\"}]')\n\n            # Create .gitignore\n            with FileContext('.gitignore') as gitignore:\n                gitignore.write_content('__pycache__/')\\\n                        .append_line('*.pyc')\\\n                        .append_line('*.pyo')\\\n                        .append_line('*.egg-info/')\\\n                        .append_line('dist/')\\\n                        .append_line('build/')\\\n                        .append_line('.pytest_cache/')\n\n            print(f\"\u2705 Project structure created for {project_name}\")\n\n            # Create backup\n            with ArchiveContext(source='.', target=f'{project_name}_initial.zip') as backup:\n                print(f\"\u2705 Initial backup created: {project_name}_initial.zip\")\n\n                # Show backup info\n                info = backup.get_archive_info()\n                print(f\"\ud83d\udce6 Backup contains {info['file_count']} files\")\n\nif __name__ == \"__main__\":\n    setup_python_project(\"my_awesome_project\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore these advanced topics:</p> <ul> <li>Basic Usage - More detailed usage examples</li> <li>API Reference - Complete API documentation</li> <li>Examples - Real-world usage examples</li> </ul> <p>Happy coding! \ud83d\ude80</p> <pre><code># Execute commands in containers\nresult = shell.run_in(\"mycontainer\", \"ls /app\")\n\n# Check if containers are running\nshell.depends_on([\"web\", \"database\"])\n</code></pre> <p>``` </p>"},{"location":"getting-started/#installation_1","title":"Installation","text":"<p><code>bash pip install hands-trapezium</code></p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> <li>Rich library for console output</li> <li>Click for CLI interface</li> </ul>"},{"location":"getting-started/#documentation","title":"Documentation","text":"<p>For comprehensive documentation, visit: https://42sol-eu.github.io/hands_scaphoid</p>"},{"location":"motivation/","title":"Motivatoin","text":""},{"location":"motivation/#python-is-awesome","title":"Python is awesome","text":"<p>Python's Philosopy</p> <p>\"Python comes with batteries included!\" - The Zen of Python, by Tim Peters &gt;&gt;</p> <p>Python is a powerful and versatile programming language that emphasizes code readability and simplicity. It has a large standard library that provides many useful modules and functions for various tasks, such as file I/O, regular expressions, data serialization, networking, and more. </p> <p>Python also has a rich ecosystem of third-party packages that extend its functionality and enable developers to build complex applications with ease. Forerunners of this are <code>requests</code> for HTTP requests, <code>pandas</code> for data analysis, <code>numpy</code> for numerical computing, <code>flask</code> for web development, <code>rich</code> for rich text and beautiful formatting or <code>click</code> for command-line interfaces.</p> <p>But Python has quite a bit of history and if you look closely, you will notice that for example handling file system object is quite scattered in different parts of the standard library. <code>os</code> and <code>pathlib</code> are the main modules for file system operations, but they have different approaches and APIs. <code>os</code> is more low-level and provides functions that work with file descriptors and paths as strings, while <code>pathlib</code> is more high-level and provides an object-oriented interface for manipulating paths as objects. But you can not do anything in <code>pathlib</code>. And there is more because some functions need other packages like <code>copy</code> and <code>shutils</code>. This can lead to confusion and inconsistency when working with file system objects in Python.. </p> <p>Furthermore, as with all things created by humans, there is always room for improvement. Python is defining <code>snake_case</code> as its naming convention, which promotes readability and consistency across the language. However many standard library modules and functions do not follow this convention, which can lead to confusion and inconsistency when using them. For example, the <code>os</code> module has functions like <code>listdir</code>, <code>mkdir</code>, and <code>getcwd</code>, while the <code>pathlib</code> module has methods like <code>iterdir</code>, <code>mkdir</code>, and <code>cwd</code>. This inconsistency can make it harder for developers to learn and use the language effectively. Even uglier are functions like <code>isinstance</code>, <code>hasattr</code> or <code>getattr</code>. Keeping those functions for backwards compatibility is surely a good thing, but do you realize how easy it is to rectify those short commings?</p> <pre><code>is_instance = isinstance\n# or if you aiming for \"take a name that is already known:\"\ncd = os.changedir\n</code></pre> <p>!!! note 'Constructive and Loving Critique'</p> <pre><code>This is not meant as a rant against Python. I love Python and use it daily. I just want to point out some areas where it could be improved. I also want to show how we can leverage Python's strengths and create packages that complement and enhance its capabilities.\n</code></pre> <p>Hands Magic comes to the rescue. You can think of it as rechargeable batteries for your Python projects. Its first goal is to provide anything you need for a smooth and consistent automation and testing experiance. Its part are - as the wounderfull idea of a human hand - build by multiple smaller packages that focus on specific aspects of this big goal.  </p> <p>Hands Scaphoid aims to provide a unified and consistent interface for handling file system objects in Python. It combines the best features of <code>os</code> and <code>pathlib</code> and adds more functionality and flexibility. It also integrates with other packages like <code>cells_validator</code> for validation and <code>cells_logger</code> for logging.</p>"},{"location":"plugin-features-test/","title":"Plugin Features Test","text":"<p>This page demonstrates the mkdocs-material plugins: admonitions, tabs, and API includes.</p>"},{"location":"plugin-features-test/#admonitions-callouts","title":"Admonitions (Callouts)","text":"<p>Admonitions provide visually distinct callout boxes for different types of information.</p> <p>Information Note</p> <p>This is a note admonition. Use it to provide helpful information to users.</p> <p>Pro Tip</p> <p>This is a tip admonition. Perfect for sharing best practices and helpful hints.</p> <p>Important Warning</p> <p>This is a warning admonition. Use it to highlight potential issues or important considerations.</p> <p>Critical Alert</p> <p>This is a danger admonition. Use it for critical information that users must be aware of.</p> <p>Code Example</p> <p>This is an example admonition with code:</p> <pre><code>from hands_scaphoid import Shell\n\nwith Shell() as shell:\n    result = shell.run(\"echo 'Hello World'\")\n    print(result.stdout)\n</code></pre> <p>Summary</p> <p>This is an abstract admonition for summarizing key points.</p> <p>Additional Information</p> <p>You can also use collapsible admonitions:</p> Click to expand <p>This content is hidden by default and can be expanded by clicking.</p> Frequently Asked Question <p>Q: How do I use the Shell context manager?</p> <p>A: Simply import it and use it in a <code>with</code> statement as shown in the examples above.</p>"},{"location":"plugin-features-test/#tabs","title":"Tabs","text":"<p>Tabs allow you to organize related content in a compact, navigable interface.</p> Python ExampleWindows PowerShellCommand PromptBash/WSL <pre><code>from hands_scaphoid import Shell\n\n# Basic usage\nwith Shell() as shell:\n    result = shell.run(\"ls -la\")\n    print(result.stdout)\n</code></pre> <pre><code>from hands_scaphoid import Shell\n\n# Windows PowerShell example\nwith Shell(shell=\"powershell\") as shell:\n    result = shell.run(\"Get-ChildItem\")\n    print(result.stdout)\n</code></pre> <pre><code>from hands_scaphoid import Shell\n\n# Windows Command Prompt example\nwith Shell(shell=\"cmd\") as shell:\n    result = shell.run(\"dir\")\n    print(result.stdout)\n</code></pre> <pre><code>from hands_scaphoid import Shell\n\n# WSL/Bash example\nwith Shell(shell=\"bash\") as shell:\n    result = shell.run(\"find . -name '*.py'\")\n    print(result.stdout)\n</code></pre>"},{"location":"plugin-features-test/#configuration-tabs","title":"Configuration Tabs","text":"Basic ConfigurationAdvanced ConfigurationWindows Specific <pre><code>from hands_scaphoid import Shell\n\n# Simple configuration\nshell = Shell(\n    shell=\"bash\",\n    timeout=30\n)\n</code></pre> <pre><code>from hands_scaphoid import Shell\n\n# Advanced configuration with custom environment\nshell = Shell(\n    shell=\"bash\",\n    timeout=60,\n    env={\"PATH\": \"/custom/path\"},\n    cwd=\"/custom/working/directory\"\n)\n</code></pre> <pre><code>from hands_scaphoid import Shell\n\n# Windows-specific configuration\nshell = Shell(\n    shell=\"powershell\",\n    timeout=45,\n    execution_policy=\"RemoteSigned\"\n)\n</code></pre>"},{"location":"plugin-features-test/#api-documentation-includes","title":"API Documentation Includes","text":"<p>The mkdocstrings plugin automatically generates API documentation from docstrings.</p>"},{"location":"plugin-features-test/#shell-class-example","title":"Shell Class Example","text":"<p>A secure shell command executor with environment management.</p> <p>This class provides a secure way to execute shell commands with features like: - Command allowlisting for security - Environment variable management - Docker container command execution - Working directory management</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable-functions","title":"Functions","text":""},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.__init__","title":"<code>__init__(cwd=None, env=None, env_file='~/.env')</code>","text":"<p>Initialize the Shell instance.</p> <p>Parameters:</p> Name Type Description Default <code>cwd</code> <code>Optional[Union[str, PathLike]]</code> <p>Working directory for command execution. Defaults to current directory.</p> <code>None</code> <code>env</code> <code>Optional[Dict[str, str]]</code> <p>Environment variables dictionary. Defaults to copy of os.environ.</p> <code>None</code> <code>env_file</code> <code>str</code> <p>Path to environment file to load variables from.</p> <code>'~/.env'</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified working directory doesn't exist.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.allow","title":"<code>allow(command)</code>","text":"<p>Allow a command to be executed.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Union[str, List[str]]</code> <p>The command or lost of commands to allow (first word will be extracted).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if command was successfully allowed, False if command doesn't exist.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If command is empty or invalid.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.cd","title":"<code>cd(path)</code>","text":"<p>Change the current working directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to change to (relative or absolute).</p> required <p>Raises:</p> Type Description <code>NotADirectoryError</code> <p>If the path is not a valid directory.</p> <code>ValueError</code> <p>If path is empty.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.depends_on","title":"<code>depends_on(names)</code>","text":"<p>Check if Docker containers are running.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>Union[str, List[str]]</code> <p>Container name(s) to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if all containers are running.</p> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If any container is not running.</p> <code>RuntimeError</code> <p>If docker command fails.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.get_allowed_commands","title":"<code>get_allowed_commands()</code>","text":"<p>Get the list of currently allowed commands.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of allowed command names.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.get_env_var","title":"<code>get_env_var(var_name)</code>","text":"<p>Get the value of an environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_name</code> <code>str</code> <p>Name of the environment variable.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Value of the environment variable or None if not found.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If var_name is empty.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.is_command_allowed","title":"<code>is_command_allowed(command)</code>","text":"<p>Check if a command is in the allow list.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if command is allowed, False otherwise.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.run","title":"<code>run(command_with_args, timeout=None, capture_output=True, text=True, check=True)</code>","text":"<p>Execute a shell command with security checks.</p> <p>Parameters:</p> Name Type Description Default <code>command_with_args</code> <code>str</code> <p>The shell command to execute including arguments.</p> required <code>timeout</code> <code>Optional[int]</code> <p>Maximum seconds to wait for command completion.</p> <code>None</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture stdout and stderr.</p> <code>True</code> <code>text</code> <code>bool</code> <p>Whether to return output as text (str) or bytes.</p> <code>True</code> <code>check</code> <code>bool</code> <p>Whether to raise exception on non-zero exit codes.</p> <code>True</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>CompletedProcess object with execution results.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the command is not in the allow list.</p> <code>CalledProcessError</code> <p>If check=True and command fails.</p> <code>TimeoutExpired</code> <p>If command times out.</p> <code>ValueError</code> <p>If command is empty or invalid.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.run_in","title":"<code>run_in(container_name, command_with_args, timeout=None, capture_output=True, text=True, check=True)</code>","text":"<p>Execute a command inside a Docker container.</p> <p>Parameters:</p> Name Type Description Default <code>container_name</code> <code>str</code> <p>Name of the Docker container.</p> required <code>command_with_args</code> <code>list[str] | str</code> <p>Command to execute inside the container.</p> required <code>timeout</code> <code>Optional[int]</code> <p>Maximum seconds to wait for command completion.</p> <code>None</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture stdout and stderr.</p> <code>True</code> <code>text</code> <code>bool</code> <p>Whether to return output as text (str) or bytes.</p> <code>True</code> <code>check</code> <code>bool</code> <p>Whether to raise exception on non-zero exit codes.</p> <code>True</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>CompletedProcess object with execution results.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If docker command is not allowed.</p> <code>CalledProcessError</code> <p>If check=True and command fails.</p> <code>ValueError</code> <p>If container_name or command is empty.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.set_env_var","title":"<code>set_env_var(var_name, value)</code>","text":"<p>Set an environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_name</code> <code>str</code> <p>Name of the environment variable.</p> required <code>value</code> <code>str</code> <p>Value to set.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If var_name is empty.</p>"},{"location":"plugin-features-test/#hands_scaphoid.ShellExecutable.sleep","title":"<code>sleep(seconds)</code>","text":"<p>Sleep for the specified number of seconds.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>Union[int, float]</code> <p>Number of seconds to sleep.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If seconds is negative.</p>"},{"location":"plugin-features-test/#shellcontext-class","title":"ShellContext Class","text":""},{"location":"plugin-features-test/#hands_scaphoid.ShellContext","title":"<code>hands_scaphoid.ShellContext(cwd=None, env=None, env_file='~/.env')</code>","text":"<p>Context manager that provides global shell functions.</p> <p>This context manager creates a Shell instance and exposes its methods as global functions for convenient script-like usage. The functions are automatically cleaned up when exiting the context.</p> <p>Parameters:</p> Name Type Description Default <code>cwd</code> <code>Optional[Union[str, Path]]</code> <p>Working directory for command execution.</p> <code>None</code> <code>env</code> <code>Optional[Dict[str, str]]</code> <p>Environment variables dictionary.</p> <code>None</code> <code>env_file</code> <code>str</code> <p>Path to environment file to load variables from.</p> <code>'~/.env'</code> <p>Yields:</p> Name Type Description <code>Shell</code> <code>ShellExecutable</code> <p>The Shell instance for advanced usage.</p> Example <p>with ShellContext() as shell:     allow(\"ls\")     allow(\"echo\")     result = run(\"ls -la\")     cd(\"/tmp\")     run(\"echo 'Hello World'\")</p> Source code in <code>src/hands_scaphoid/contexts/ShellContext.py</code> <pre><code>@context_manager\ndef ShellContext(\n    cwd: Optional[Union[str, Path]] = None,\n    env: Optional[Dict[str, str]] = None,\n    env_file: str = \"~/.env\",\n) -&gt; Generator[Shell, None, None]:\n    \"\"\"\n    Context manager that provides global shell functions.\n\n    This context manager creates a Shell instance and exposes its methods\n    as global functions for convenient script-like usage. The functions\n    are automatically cleaned up when exiting the context.\n\n    Args:\n        cwd: Working directory for command execution.\n        env: Environment variables dictionary.\n        env_file: Path to environment file to load variables from.\n\n    Yields:\n        Shell: The Shell instance for advanced usage.\n\n    Example:\n        with ShellContext() as shell:\n            allow(\"ls\")\n            allow(\"echo\")\n            result = run(\"ls -la\")\n            cd(\"/tmp\")\n            run(\"echo 'Hello World'\")\n    \"\"\"\n    ctx = Shell(cwd, env, env_file)\n\n    # Store original functions if they exist\n    original_functions = {}\n    function_names = [\"cd\", \"run\", \"run_in\", \"sleep\", \"allow\", \"depends_on\"]\n\n    for func_name in function_names:\n        if hasattr(builtins, func_name):\n            original_functions[func_name] = getattr(builtins, func_name)\n\n    # Set global functions\n    builtins.cd = ctx.cd\n    builtins.run = ctx.run\n    builtins.run_in = ctx.run_in\n    builtins.sleep = ctx.sleep\n    builtins.allow = ctx.allow\n    builtins.depends_on = ctx.depends_on\n\n    try:\n        yield ctx\n    finally:\n        # Restore original functions or delete if they didn't exist\n        for func_name in function_names:\n            if func_name in original_functions:\n                setattr(builtins, func_name, original_functions[func_name])\n            elif hasattr(builtins, func_name):\n                delattr(builtins, func_name)\n</code></pre>"},{"location":"plugin-features-test/#file-operations","title":"File Operations","text":"<p>TODO: add file operations example</p>"},{"location":"plugin-features-test/#combined-example","title":"Combined Example","text":"<p>Here's an example that combines all three features:</p> <p>Complete Workflow Example</p> SetupBasic UsageAdvanced Usage <p>First, install and import the necessary components:</p> <pre><code>from hands_scaphoid import Shell, ShellContext\nimport os\n</code></pre> <pre><code># Create a shell context\nwith Shell() as shell:\n    # Run a simple command\n    result = shell.run(\"echo 'Hello from shell!'\")\n\n    if result.success:\n        print(f\"Output: {result.stdout}\")\n    else:\n        print(f\"Error: {result.stderr}\")\n</code></pre> <pre><code># Advanced usage with error handling\ntry:\n    with Shell(timeout=30) as shell:\n        # Multiple commands\n        commands = [\n            \"pwd\",\n            \"ls -la\",\n            \"echo 'Processing complete'\"\n        ]\n\n        for cmd in commands:\n            result = shell.run(cmd)\n            if not result.success:\n                raise RuntimeError(f\"Command failed: {cmd}\")\n\nexcept TimeoutError:\n    print(\"Operation timed out\")\nexcept RuntimeError as e:\n    print(f\"Command execution failed: {e}\")\n</code></pre> <p>Error Handling</p> <p>Always implement proper error handling when working with shell commands, especially in production environments.</p> <p>Performance</p> <p>For multiple related commands, consider using a single shell context to avoid the overhead of creating multiple shell instances.</p>"},{"location":"plugin-features-test/#testing-the-plugins","title":"Testing the Plugins","text":"<p>To verify that all plugins are working correctly:</p> <ol> <li>Admonitions: Check that the callout boxes above render with proper styling and icons</li> <li>Tabs: Verify that the tabbed content switches properly when clicking different tabs</li> <li>API Includes: Confirm that the API documentation is automatically generated and displayed with proper formatting</li> </ol> <p>All Features Working</p> <p>If you can see properly formatted admonitions, functional tabs, and auto-generated API documentation, then all mkdocs-material plugins are configured correctly!</p>"},{"location":"windows-shells/","title":"Windows Shell Support","text":"<p>Hands Scaphoid provides specialized shell classes for Windows environments that make cross-platform development easier.</p>"},{"location":"windows-shells/#powershell","title":"PowerShell","text":"<p>The <code>PowerShell</code> class automatically translates common Unix commands to their PowerShell equivalents, allowing you to write cross-platform scripts using familiar Unix command syntax.</p>"},{"location":"windows-shells/#basic-usage","title":"Basic Usage","text":"<pre><code>from hands_scaphoid import PowerShell\n\n# Create a PowerShell shell\nshell = PowerShell()\n\n# Allow commands (both Unix and PowerShell versions work)\nshell.allow(\"ls\")         # Automatically translated to Get-ChildItem\nshell.allow(\"cp\")         # Automatically translated to Copy-Item\nshell.allow(\"echo\")       # Automatically translated to Write-Output\n\n# Run Unix commands - they get translated automatically\nresult = shell.run(\"ls -la\")           # Becomes: Get-ChildItem -Force -Detailed\nresult = shell.run(\"cp file1 file2\")   # Becomes: Copy-Item \"file1\" \"file2\"\nresult = shell.run(\"echo 'Hello'\")     # Becomes: Write-Output 'Hello'\n</code></pre>"},{"location":"windows-shells/#command-translation-examples","title":"Command Translation Examples","text":"Unix Command PowerShell Translation <code>ls</code> <code>Get-ChildItem</code> <code>ls -la</code> <code>Get-ChildItem -Force -Detailed</code> <code>cp source dest</code> <code>Copy-Item \"source\" \"dest\"</code> <code>cp -r folder dest</code> <code>Copy-Item \"folder\" \"dest\" -Recurse</code> <code>rm file</code> <code>Remove-Item \"file\"</code> <code>rm -rf folder</code> <code>Remove-Item \"folder\" -Recurse -Force</code> <code>cat file</code> <code>Get-Content file</code> <code>pwd</code> <code>Get-Location</code> <code>echo text</code> <code>Write-Output text</code> <code>ps</code> <code>Get-Process</code> <code>whoami</code> <code>[System.Security.Principal.WindowsIdentity]::GetCurrent().Name</code> <code>hostname</code> <code>$env:COMPUTERNAME</code>"},{"location":"windows-shells/#powershell-executable-detection","title":"PowerShell Executable Detection","text":"<p>The class automatically detects the best PowerShell executable: - Tries <code>pwsh.exe</code> (PowerShell Core) first - Falls back to <code>powershell.exe</code> (Windows PowerShell) if Core is not available</p>"},{"location":"windows-shells/#wslshell","title":"WslShell","text":"<p>The <code>WslShell</code> class allows you to execute Linux commands through Windows Subsystem for Linux (WSL), giving you access to a full Linux environment from your Python scripts.</p>"},{"location":"windows-shells/#basic-usage_1","title":"Basic Usage","text":"<pre><code>from hands_scaphoid import WslShell\n\n# Create a WSL shell (uses default WSL distribution)\nshell = WslShell()\n\n# Or specify a specific distribution\nshell = WslShell(distribution=\"Ubuntu\")\n\n# Allow Linux commands\nshell.allow(\"ls\")\nshell.allow(\"grep\")\nshell.allow(\"awk\")\n\n# Run Linux commands\nresult = shell.run(\"ls -la\")\nresult = shell.run(\"grep 'pattern' file.txt\")\nresult = shell.run(\"uname -a\")\n</code></pre>"},{"location":"windows-shells/#wsl-distribution-management","title":"WSL Distribution Management","text":"<pre><code># List available WSL distributions\ndistributions = shell.list_distributions()\nprint(\"Available distributions:\", distributions)\n\n# Switch to a different distribution\nsuccess = shell.set_distribution(\"Debian\")\nif success:\n    print(\"Switched to Debian\")\nelse:\n    print(\"Failed to switch distribution\")\n</code></pre>"},{"location":"windows-shells/#command-wrapping","title":"Command Wrapping","text":"<p>WSL commands are automatically wrapped for execution: <pre><code># When you run: shell.run(\"ls -la\")\n# It actually executes: [\"wsl.exe\", \"--\", \"sh\", \"-c\", \"ls -la\"]\n</code></pre></p>"},{"location":"windows-shells/#convenience-functions","title":"Convenience Functions","text":"<pre><code>from hands_scaphoid import create_powershell_shell, create_wsl_shell\n\n# Create shells using convenience functions\nps_shell = create_powershell_shell()\nwsl_shell = create_wsl_shell(\"Ubuntu\")\n\n# Get available WSL distributions\nfrom hands_scaphoid.objects.WslShell import get_available_wsl_distributions\ndistributions = get_available_wsl_distributions()\n</code></pre>"},{"location":"windows-shells/#cross-platform-script-example","title":"Cross-Platform Script Example","text":"<pre><code>import platform\nfrom hands_scaphoid import Shell, PowerShell, WslShell\n\ndef cross_platform_example():\n    # Choose shell based on platform and requirements\n    if platform.system() == \"Windows\":\n        # Option 1: Use PowerShell for Windows compatibility\n        shell = PowerShell()\n\n        # Option 2: Use WSL for Linux compatibility\n        # shell = WslShell()\n    else:\n        # Use regular shell on Unix systems\n        shell = Shell()\n\n    # Allow commands (works for all shell types)\n    shell.allow(\"ls\")\n    shell.allow(\"echo\")\n\n    # Run commands using Unix syntax\n    result = shell.run(\"ls\")\n    result = shell.run(\"echo 'Cross-platform hello'\")\n\n    print(\"Directory listing succeeded:\", result.returncode == 0)\n</code></pre>"},{"location":"windows-shells/#error-handling","title":"Error Handling","text":"<pre><code>from hands_scaphoid import WslShell\n\ntry:\n    # This will raise RuntimeError if WSL is not available\n    shell = WslShell()\n    shell.allow(\"ls\")\n    result = shell.run(\"ls\")\nexcept RuntimeError as e:\n    print(f\"WSL not available: {e}\")\n    # Fallback to PowerShell or regular shell\n    shell = PowerShell()\n    shell.allow(\"ls\")\n    result = shell.run(\"ls\")\n</code></pre>"},{"location":"windows-shells/#security","title":"Security","text":"<p>Both Windows shell classes inherit the same security model as the base <code>Shell</code> class: - Commands must be explicitly allowed using <code>allow()</code> - Only the command name is checked, not arguments - Commands are validated to exist on the system when possible</p>"},{"location":"windows-shells/#requirements","title":"Requirements","text":"<ul> <li>PowerShell: Works on any Windows system with PowerShell installed</li> <li>WslShell: Requires Windows Subsystem for Linux (WSL) to be installed and configured</li> </ul>"},{"location":"windows-shells/#platform-behavior","title":"Platform Behavior","text":"<ul> <li>Windows: Both classes work as described above</li> <li>Non-Windows: Both classes fall back to regular shell behavior for cross-platform compatibility</li> </ul>"},{"location":"api/api-reference/","title":"API Reference","text":"<p>This is the complete API reference for Hands Scaphoid, covering all modules, classes, and functions.</p>"},{"location":"api/api-reference/#core-components","title":"Core Components","text":""},{"location":"api/api-reference/#context-managers","title":"Context Managers","text":"<ul> <li>ShellContext - Primary context manager for shell operations</li> <li>Shell Executable - Core shell execution class</li> </ul>"},{"location":"api/api-reference/#command-modules","title":"Command Modules","text":""},{"location":"api/api-reference/#file-commands","title":"File Commands","text":"<p>Module: <code>hands_scaphoid.commands.file_commands</code></p> Function Status Description <code>read(file_path, head=None, tail=None, line_separator='\\n', do_print=False)</code> \u2705 Available Read file content with optional head/tail limits <code>filter(name, pattern)</code> \ud83d\udd04 Planned Filter files by pattern <code>write(name, data)</code> \ud83d\udd04 Planned Write data to file <code>append(name, data)</code> \ud83d\udd04 Planned Append data to file <code>create(name, data)</code> \ud83d\udd04 Planned Create new file with data"},{"location":"api/api-reference/#archive-commands","title":"Archive Commands","text":"<p>Module: <code>hands_scaphoid.commands.archive_commands</code></p> Function Status Description <code>is_archive_file(file_path)</code> \u2705 Available Check if file is an archive <code>create_zip_archive(archive_name, source)</code> \u2705 Available Create ZIP archive <code>create_tar_archive(archive_name, source, compression=None)</code> \u2705 Available Create TAR archive <code>create_7z_archive(archive_name, source)</code> \u2705 Available Create 7Z archive <code>create_rar_archive(archive_name, source)</code> \u2705 Available Create RAR archive <code>extract(archive_path, target_dir)</code> \u2705 Available Extract any supported archive <code>extract_zip_archive(archive_path, target_dir)</code> \u2705 Available Extract ZIP archive <code>extract_tar_archive(archive_path, target_dir, compression=None)</code> \u2705 Available Extract TAR archive <code>extract_7z_archive(archive_path, target_dir)</code> \u2705 Available Extract 7Z archive <code>extract_rar_archive(archive_path, target_dir)</code> \u2705 Available Extract RAR archive <code>list_contents(archive_path)</code> \u2705 Available List archive contents"},{"location":"api/api-reference/#core-commands","title":"Core Commands","text":"<p>Module: <code>hands_scaphoid.commands.core_commands</code></p> Function Status Description <code>exists(path)</code> \u2705 Available Check if path exists <code>does_not_exists(path)</code> \u2705 Available Check if path does not exist <code>is_file(path)</code> \u2705 Available Check if path is a file <code>is_directory(path)</code> \u2705 Available Check if path is a directory <code>is_link(path)</code> \u2705 Available Check if path is a symbolic link <code>is_object(path)</code> \u2705 Available Check if path is any file system object <code>is_variable(var)</code> \u2705 Available Check if environment variable is defined <code>is_item(p)</code> \u2705 Available Check if item is a file system object or variable <code>is_git_project(path)</code> \u2705 Available Check if directory is a Git project <code>is_vscode_project(path)</code> \u2705 Available Check if directory is a VS Code project <code>is_hands_project(path)</code> \u2705 Available Check if directory is a Hands project <code>is_project(path)</code> \u2705 Available Check if directory is any type of project <code>get_file_extension(filename)</code> \u2705 Available Get file extension (supports complex extensions) <code>which(executable)</code> \u2705 Available Find executable in system PATH <code>filter(path, filter)</code> \u2705 Available Filter directory contents by glob pattern"},{"location":"api/api-reference/#data-types","title":"Data Types","text":""},{"location":"api/api-reference/#compressiontype-enum","title":"CompressionType Enum","text":"<p>Module: <code>hands_scaphoid.commands.core_commands</code></p> <p>Supported compression types: - <code>ZIP</code> - ZIP format - <code>TAR</code> - TAR format - <code>GZIP</code>/<code>GZ</code> - GZIP compression - <code>BZIP2</code> - BZIP2 compression - <code>XZ</code> - XZ compression - <code>SEVEN_Z</code> - 7Z format - <code>RAR</code> - RAR format - <code>TAR_GZ</code> - TAR with GZIP compression - <code>TAR_BZ2</code> - TAR with BZIP2 compression - <code>TAR_XZ</code> - TAR with XZ compression</p>"},{"location":"api/api-reference/#item-classes-ordered-logically","title":"Item classes [ordered logically]","text":""},{"location":"api/api-reference/#itemcore","title":"ItemCore","text":"<p>Base class for all file system items.</p>"},{"location":"api/api-reference/#variableitem","title":"VariableItem","text":"<p>Variable class for all file system items.</p>"},{"location":"api/api-reference/#pathvariable","title":"PathVariable","text":"<p>Path class for all file system items.</p>"},{"location":"api/api-reference/#pathlike-type","title":"PathLike Type","text":"<p>Module: <code>hands_scaphoid.__base__</code></p> <p>Type alias for path-like objects: <code>Union[str, Path]</code></p>"},{"location":"api/api-reference/#objectitem","title":"ObjectItem","text":"<p>Base class for all file system items.</p>"},{"location":"api/api-reference/#object-classes","title":"Object classes","text":"[ordered logically] <p>==== \"[ordered by alphabet]\"</p> <pre><code>### [Archive File](objects/archive-file.md)\nObject representation of archive files with built-in operations.\n\n### [ExecutableFile](objects/executable-file.md)\nObject representation of executable files.\n\n### [DirectoryObject](objects/directory-object.md) \nObject representation of directories with file system operations.\n\n### [FileObject](objects/file-object.md)\nObject representation of regular files with read/write operations.\n\n\n### [Script File](objects/script-file.md)\nObject representation of script files.\n\n### [Shell Executable](objects/shell-executable.md)\nMain shell execution class with command allowlisting.\n\n### [SSH Shell](objects/ssh-shell.md)\nSystem access shell via SSH\nTODO: add sSshShell\n\n### [Windows Shells](objects/power-shell.md)\nWindows-specific shell implementations (PowerShell).\n\n### [WSL Shell](objects/wsl-shell.md)\nWindows Subsystem for Linux shell implementation.\n</code></pre>"},{"location":"api/api-reference/#directoryobject","title":"DirectoryObject","text":"<p>Object representation of directories with file system operations.</p>"},{"location":"api/api-reference/#fileobject","title":"FileObject","text":"<p>Object representation of regular files with read/write operations.</p>"},{"location":"api/api-reference/#archive-file","title":"Archive File","text":"<p>Object representation of archive files with built-in operations.</p>"},{"location":"api/api-reference/#executablefile","title":"ExecutableFile","text":"<p>Object representation of executable files.</p>"},{"location":"api/api-reference/#script-file","title":"Script File","text":"<p>Object representation of script files.</p>"},{"location":"api/api-reference/#shell-executable","title":"Shell Executable","text":"<p>Main shell execution class with command allowlisting.</p>"},{"location":"api/api-reference/#ssh-shell","title":"SSH Shell","text":"<p>System access shell via SSH TODO: add sSshShell</p>"},{"location":"api/api-reference/#windows-shells","title":"Windows Shells","text":"<p>Windows-specific shell implementations (PowerShell).</p>"},{"location":"api/api-reference/#wsl-shell","title":"WSL Shell","text":"<p>Windows Subsystem for Linux shell implementation.</p>"},{"location":"api/api-reference/#context-managers_1","title":"Context Managers","text":""},{"location":"api/api-reference/#context-managers_2","title":"Context Managers","text":"<p>Overview of context management functionality.</p>"},{"location":"api/api-reference/#shell-context","title":"Shell Context","text":"<p>Primary context manager for secure shell operations.</p>"},{"location":"api/api-reference/#testing","title":"Testing","text":"<p>Comprehensive test coverage is available for all command modules. See the Testing Guide for detailed information about:</p> <ul> <li>Test structure and organization</li> <li>Running tests locally</li> <li>Coverage reports</li> <li>Mocking strategies for external dependencies</li> </ul>"},{"location":"api/api-reference/#usage-examples","title":"Usage Examples","text":""},{"location":"api/api-reference/#basic-file-operations","title":"Basic File Operations","text":"<pre><code>from hands_scaphoid.commands.file_commands import read\nfrom hands_scaphoid.commands.core_commands import exists, get_file_extension\n\n# Check if file exists\nif exists(\"README.md\"):\n    # Read file content\n    content = read(\"README.md\")\n    print(content)\n\n# Get file extension\next = get_file_extension(\"archive.tar.gz\")\nprint(f\"Extension: {ext}\")  # Output: tar.gz\n</code></pre>"},{"location":"api/api-reference/#archive-operations","title":"Archive Operations","text":"<pre><code>from hands_scaphoid.commands.archive_commands import (\n    create_zip_archive, \n    extract, \n    list_contents\n)\n\n# Create archive\nif create_zip_archive(\"backup\", \"source_directory\"):\n    print(\"Archive created successfully\")\n\n# List archive contents\nfiles = list_contents(\"backup.zip\")\nfor file in files:\n    print(f\"  {file}\")\n\n# Extract archive\nif extract(\"backup.zip\", \"restored_files\"):\n    print(\"Archive extracted successfully\")\n</code></pre>"},{"location":"api/api-reference/#project-detection","title":"Project Detection","text":"<pre><code>from hands_scaphoid.commands.core_commands import (\n    is_git_project,\n    is_vscode_project,\n    is_project\n)\n\nproject_dir = \"/path/to/project\"\n\nif is_git_project(project_dir):\n    print(\"This is a Git repository\")\n\nif is_vscode_project(project_dir):\n    print(\"This is a VS Code project\")\n\nif is_project(project_dir):\n    print(\"This is some kind of project\")\n</code></pre>"},{"location":"api/api-reference/#status-legend","title":"Status Legend","text":"<ul> <li>\u2705 Available: Fully implemented and tested</li> <li>\ud83d\udd04 Planned: Marked as TODO in source code</li> <li>\ud83d\udfe2 Complete: Full test coverage</li> <li>\ud83d\udfe1 Partial: Some test coverage</li> <li>\ud83d\udd34 Needs Work: Requires attention</li> </ul> <p>For detailed implementation status, see the Operations Summary.</p>"},{"location":"api/objects/","title":"Objects API Reference","text":"<p>This section provides detailed API documentation for the core objects in hands-scaphoid.</p> <p>See Summary of file system operations for an overview of file system operations and their types and their relations.</p>"},{"location":"api/contexts/context-managers/","title":"Context Managers","text":"<p>A context manager in Python is a construct that allows for the setup and teardown of resources automatically. It is typically used with the <code>with</code> statement to ensure that resources are properly managed, even in the presence of errors.</p>"},{"location":"api/contexts/context-managers/#using-context-anagers","title":"Using context anagers","text":"<p>To use a context manager, you define a class with <code>__enter__</code> and <code>__exit__</code> methods, or you can use the <code>contextlib</code> module to create one easily. Here's an example:</p> <pre><code>from contextlib import contextmanager as context_manager\n\n@context_manager\ndef managed_resource():\n    # Setup code\n    resource = acquire_resource()\n    try:\n        yield resource\n    finally:\n        # Teardown code\n        release_resource(resource)\n</code></pre> <p>You can then use this context manager as follows:</p> <pre><code>with managed_resource() as res:\n    # Use the resource\n</code></pre>"},{"location":"api/contexts/context-managers/#benefits-of-context-managers","title":"Benefits of context managers","text":"<ol> <li>Automatic resource management: Context managers handle resource allocation and deallocation automatically, reducing the risk of resource leaks.</li> <li>Cleaner code: They help to keep your code clean and readable by encapsulating setup and teardown logic.</li> <li>Error handling: Context managers can handle exceptions gracefully, ensuring that resources are released even if an error occurs.</li> </ol>"},{"location":"api/contexts/shell-context/","title":"ShellContext API Reference","text":""},{"location":"api/contexts/shell-context/#hands_scaphoid.ShellContext","title":"<code>hands_scaphoid.ShellContext(cwd=None, env=None, env_file='~/.env')</code>","text":"<p>Context manager that provides global shell functions.</p> <p>This context manager creates a Shell instance and exposes its methods as global functions for convenient script-like usage. The functions are automatically cleaned up when exiting the context.</p> <p>Parameters:</p> Name Type Description Default <code>cwd</code> <code>Optional[Union[str, Path]]</code> <p>Working directory for command execution.</p> <code>None</code> <code>env</code> <code>Optional[Dict[str, str]]</code> <p>Environment variables dictionary.</p> <code>None</code> <code>env_file</code> <code>str</code> <p>Path to environment file to load variables from.</p> <code>'~/.env'</code> <p>Yields:</p> Name Type Description <code>Shell</code> <code>ShellExecutable</code> <p>The Shell instance for advanced usage.</p> Example <p>with ShellContext() as shell:     allow(\"ls\")     allow(\"echo\")     result = run(\"ls -la\")     cd(\"/tmp\")     run(\"echo 'Hello World'\")</p> Source code in <code>src/hands_scaphoid/contexts/ShellContext.py</code> <pre><code>@context_manager\ndef ShellContext(\n    cwd: Optional[Union[str, Path]] = None,\n    env: Optional[Dict[str, str]] = None,\n    env_file: str = \"~/.env\",\n) -&gt; Generator[Shell, None, None]:\n    \"\"\"\n    Context manager that provides global shell functions.\n\n    This context manager creates a Shell instance and exposes its methods\n    as global functions for convenient script-like usage. The functions\n    are automatically cleaned up when exiting the context.\n\n    Args:\n        cwd: Working directory for command execution.\n        env: Environment variables dictionary.\n        env_file: Path to environment file to load variables from.\n\n    Yields:\n        Shell: The Shell instance for advanced usage.\n\n    Example:\n        with ShellContext() as shell:\n            allow(\"ls\")\n            allow(\"echo\")\n            result = run(\"ls -la\")\n            cd(\"/tmp\")\n            run(\"echo 'Hello World'\")\n    \"\"\"\n    ctx = Shell(cwd, env, env_file)\n\n    # Store original functions if they exist\n    original_functions = {}\n    function_names = [\"cd\", \"run\", \"run_in\", \"sleep\", \"allow\", \"depends_on\"]\n\n    for func_name in function_names:\n        if hasattr(builtins, func_name):\n            original_functions[func_name] = getattr(builtins, func_name)\n\n    # Set global functions\n    builtins.cd = ctx.cd\n    builtins.run = ctx.run\n    builtins.run_in = ctx.run_in\n    builtins.sleep = ctx.sleep\n    builtins.allow = ctx.allow\n    builtins.depends_on = ctx.depends_on\n\n    try:\n        yield ctx\n    finally:\n        # Restore original functions or delete if they didn't exist\n        for func_name in function_names:\n            if func_name in original_functions:\n                setattr(builtins, func_name, original_functions[func_name])\n            elif hasattr(builtins, func_name):\n                delattr(builtins, func_name)\n</code></pre>"},{"location":"api/objects/archive-file/","title":"Archive File API Reference","text":""},{"location":"api/objects/archive-file/#api-documentation","title":"API documentation","text":""},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile","title":"<code>hands_scaphoid.objects.ArchiveFile</code>","text":"<p>Archive module for hands-scaphoid package.</p> <p>This module provides the Archive class for managing archive operations with context manager support and hierarchical path resolution. ---yaml File:     name:   ArchiveFile.py     uuid:   14a7856f-b8d0-43b7-a647-5ccbfc45c0e8     date:   2025-09-16</p> Description <p>Archive context manager for hierarchical file system operations</p> Project <p>name:   hands_scaphoid uuid:   2945ba3b-2d66-4dff-b898-672c386f03f4 url:    https://github.com/42sol-eu/hands_scaphoid</p> <p>Authors: [\"Andreas H\u00e4berle\"]</p>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile-classes","title":"Classes","text":""},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile","title":"<code>ArchiveFile</code>","text":"<p>               Bases: <code>FileObject</code></p> <p>Pure archive operations class without context management.</p> <p>This class provides static methods for archive operations that can be used independently of any context manager. All methods operate on explicit archive paths and do not maintain any state.</p> <p>Supported formats: ZIP, TAR, TAR.GZ, TAR.BZ2</p> Example <pre><code># Direct archive operations\nArchiveFile.create_zip_archive(Path(\"backup.zip\"), Path(\"source_dir\"))\nArchiveFile.add_file_to_zip(Path(\"backup.zip\"), Path(\"new_file.txt\"))\nfiles = ArchiveFile.list_archive_contents(Path(\"backup.zip\"))\nArchiveFile.extract_archive(Path(\"backup.zip\"), Path(\"extracted_dir\"))\n</code></pre> <p>Attributes:     name (str): The name of the archive file.     path (str): The path of the archive file in the filesystem.</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>class ArchiveFile(FileObject):\n    \"\"\"\n    Pure archive operations class without context management.\n\n    This class provides static methods for archive operations that can be used\n    independently of any context manager. All methods operate on explicit\n    archive paths and do not maintain any state.\n\n    Supported formats: ZIP, TAR, TAR.GZ, TAR.BZ2\n\n    Example:\n        ```python\n        # Direct archive operations\n        ArchiveFile.create_zip_archive(Path(\"backup.zip\"), Path(\"source_dir\"))\n        ArchiveFile.add_file_to_zip(Path(\"backup.zip\"), Path(\"new_file.txt\"))\n        files = ArchiveFile.list_archive_contents(Path(\"backup.zip\"))\n        ArchiveFile.extract_archive(Path(\"backup.zip\"), Path(\"extracted_dir\"))\n        ```\n    Attributes:\n        name (str): The name of the archive file.\n        path (str): The path of the archive file in the filesystem.\n    \"\"\"\n\n    def __init__(self, name: str, path: str):\n        super().__init__(name, path)\n        self.item_type = ItemType.ARCHIVE\n\n    @classmethod\n    def compression_type(cls, name: str) -&gt; str:\n        \"\"\"\n        Determines the compression type based on the file extension.\n\n        Args:\n            name (str): The name of the archive file.\n\n        Returns:\n            str: The compression type (e.g., 'zip', 'tar', 'gz', etc.) or 'unknown' if not recognized.\n        \"\"\"\n        extension = get_file_extension(name)\n\n        compression_types = {\n            \"zip\": CompressionType.ZIP,\n            \"tar\": CompressionType.TAR,\n            \"tar.gz\": CompressionType.TAR_GZ,\n            \"tar.bz2\": CompressionType.TAR_BZ2,\n            \"tar.xz\": CompressionType.TAR_XZ,\n            \"gz\": CompressionType.GZIP,\n            \"bz2\": CompressionType.BZIP2,\n            \"xz\": CompressionType.XZ,\n            \"7z\": CompressionType.SEVEN_Z,\n            \"rar\": CompressionType.RAR,\n        }\n        return compression_types.get(extension, CompressionType.UNKNOWN)\n\n    def __repr__(self):\n        return f\"ArchiveFile(name={self.name}, path={self.path})\"\n\n\n    @staticmethod\n    def add_archive_type(name: str, extract_function, compress_function) -&gt; bool:\n        \"\"\"\n        Add a user defined archive type (also used for types like *.whl, *.app)\n        \"\"\"\n        done = CompressionType.add_archvive_type(name, extract_function, compress_function)\n        return done\n\n    @staticmethod\n    def detect_archive_type(archive_path: PathLike) -&gt; str:\n        \"\"\"\n        Detect the archive type from file extension.\n\n        Args:\n            archive_path: Path to the archive file\n\n        Returns:\n            Archive type ('zip', 'tar', 'tar.gz', 'tar.bz2')\n\n        Raises:\n            ValueError: If archive type cannot be determined\n        \"\"\"\n        path = Path(archive_path)\n\n        if path.suffix.lower() == \".zip\":\n            return \"zip\"\n        elif path.suffix.lower() == \".gz\":\n            return \"gz\"\n        elif path.suffix.lower() == \".bz2\":\n            return \"bz2\"\n        elif path.suffix.lower() == \".7z\":\n            return \"7z\"\n        elif path.suffix.lower() == \".rar\":\n            return \"rar\"\n        elif path.suffixes[-2:] == [\".tar\", \".gz\"]:\n            return \"tar.gz\"\n        elif path.suffixes[-2:] == [\".tar\", \".bz2\"]:\n            return \"tar.bz2\"\n        elif path.suffixes[-2:] == [\".tar\", \".xz\"]:\n            return \"tar.xz\"\n        elif path.suffix.lower() == \".tar\":\n            return \"tar\"\n        elif path.suffix.lower() == \".xz\":\n            return \"xz\"\n        else:\n            # check for project specific archive types\n            # TODO: !!! implement whl, app and more \n\n            raise ValueError(f\"Unsupported archive type for file: {path}\")\n\n    @staticmethod\n    def is_archive_file(file_path: PathLike) -&gt; bool:\n        \"\"\"\n        Check if a file is an archive based on its extension.\n\n        Args:\n            file_path: Path to check\n\n        Returns:\n            True if file appears to be an archive, False otherwise\n        \"\"\"\n        try:\n            ArchiveFile.detect_archive_type(file_path)\n            return True\n        except ValueError:\n            return False\n\n    @staticmethod\n    def create_zip_archive(\n        archive_path: PathLike, source_path: Optional[PathLike] = None\n    ) -&gt; None:\n        \"\"\"\n        Create a new ZIP ArchiveFile.\n\n        Args:\n            archive_path: Path for the new archive\n            source_path: Optional source directory/file to add initially\n\n        Raises:\n            PermissionError: If lacking create permissions\n        \"\"\"\n        path = Path(archive_path)\n        try:\n            # Create parent directories if needed\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n            with zipfile.ZipFile(path, \"w\", zipfile.ZIP_DEFLATED) as zf:\n                if source_path:\n                    source = Path(source_path)\n                    if source.is_file():\n                        zf.write(source, source.name)\n                    elif source.is_dir():\n                        for file_path in source.rglob(\"*\"):\n                            if file_path.is_file():\n                                arcname = file_path.relative_to(source.parent)\n                                zf.write(file_path, arcname)\n\n            console.print(f\"[green]Created ZIP archive:[/green] {path}\")\n        except PermissionError:\n            console.print(f\"[red]Permission denied creating archive:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error creating ZIP archive {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def create_tar_archive(\n        archive_path: PathLike,\n        source_path: Optional[PathLike] = None,\n        compression: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Create a new TAR ArchiveFile.\n\n        Args:\n            archive_path: Path for the new archive\n            source_path: Optional source directory/file to add initially\n            compression: Compression type ('gz', 'bz2', or None)\n\n        Raises:\n            PermissionError: If lacking create permissions\n        \"\"\"\n        path = Path(archive_path)\n        try:\n            # Create parent directories if needed\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n            mode = \"w\"\n            if compression == \"gz\":\n                mode = \"w:gz\"\n            elif compression == \"bz2\":\n                mode = \"w:bz2\"\n\n            with tarfile.open(path, mode) as tf:\n                if source_path:\n                    source = Path(source_path)\n                    if source.exists():\n                        tf.add(source, arcname=source.name)\n\n            console.print(f\"[green]Created TAR archive:[/green] {path}\")\n        except PermissionError:\n            console.print(f\"[red]Permission denied creating archive:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error creating TAR archive {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def add_file_to_zip(\n        archive_path: PathLike, file_path: PathLike, archive_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"\n        Add a file to an existing ZIP ArchiveFile.\n\n        Args:\n            archive_path: Path to the ZIP archive\n            file_path: Path to the file to add\n            archive_name: Name to use in archive (defaults to filename)\n\n        Raises:\n            FileNotFoundError: If archive or file doesn't exist\n        \"\"\"\n        archive = Path(archive_path)\n        file_to_add = Path(file_path)\n\n        if not ArchiveFile.exists():\n            raise FileNotFoundError(f\"Archive not found: {archive}\")\n        if not file_to_add.exists():\n            raise FileNotFoundError(f\"File not found: {file_to_add}\")\n\n        try:\n            arcname = archive_name or file_to_add.name\n\n            with zipfile.ZipFile(archive, \"a\", zipfile.ZIP_DEFLATED) as zf:\n                zf.write(file_to_add, arcname)\n\n            console.print(f\"[green]Added file to ZIP archive:[/green] {arcname}\")\n        except Exception as e:\n            console.print(f\"[red]Error adding file to ZIP archive:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def add_directory_to_zip(\n        archive_path: PathLike, dir_path: PathLike, archive_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"\n        Add a directory to an existing ZIP ArchiveFile.\n\n        Args:\n            archive_path: Path to the ZIP archive\n            dir_path: Path to the directory to add\n            archive_name: Name to use in archive (defaults to directory name)\n        \"\"\"\n        archive = Path(archive_path)\n        directory = Path(dir_path)\n\n        if not ArchiveFile.exists():\n            raise FileNotFoundError(f\"Archive not found: {archive}\")\n        if not directory.exists():\n            raise FileNotFoundError(f\"Directory not found: {directory}\")\n        if not directory.is_dir():\n            raise NotADirectoryError(f\"Path is not a directory: {directory}\")\n\n        try:\n            base_name = archive_name or directory.name\n\n            with zipfile.ZipFile(archive, \"a\", zipfile.ZIP_DEFLATED) as zf:\n                for file_path in directory.rglob(\"*\"):\n                    if file_path.is_file():\n                        relative_path = file_path.relative_to(directory)\n                        arcname = f\"{base_name}/{relative_path}\"\n                        zf.write(file_path, arcname)\n\n            console.print(f\"[green]Added directory to ZIP archive:[/green] {base_name}\")\n        except Exception as e:\n            console.print(f\"[red]Error adding directory to ZIP archive:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def add_file_to_tar(\n        archive_path: PathLike, file_path: PathLike, archive_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"\n        Add a file to an existing TAR ArchiveFile.\n\n        Args:\n            archive_path: Path to the TAR archive\n            file_path: Path to the file to add\n            archive_name: Name to use in archive (defaults to filename)\n        \"\"\"\n        archive = Path(archive_path)\n        file_to_add = Path(file_path)\n\n        if not ArchiveFile.exists():\n            raise FileNotFoundError(f\"Archive not found: {archive}\")\n        if not file_to_add.exists():\n            raise FileNotFoundError(f\"File not found: {file_to_add}\")\n\n        try:\n            # Determine TAR mode based on archive type\n            archive_type = ArchiveFile.detect_archive_type(archive)\n            if archive_type == \"tar.gz\":\n                mode = \"a:gz\"\n            elif archive_type == \"tar.bz2\":\n                mode = \"a:bz2\"\n            else:\n                mode = \"a\"\n\n            arcname = archive_name or file_to_add.name\n\n            with tarfile.open(archive, mode) as tf:\n                tf.add(file_to_add, arcname=arcname)\n\n            console.print(f\"[green]Added file to TAR archive:[/green] {arcname}\")\n        except Exception as e:\n            console.print(f\"[red]Error adding file to TAR archive:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def list_archive_contents(archive_path: PathLike) -&gt; List[str]:\n        \"\"\"\n        List contents of an ArchiveFile.\n\n        Args:\n            archive_path: Path to the archive\n\n        Returns:\n            List of file paths in the archive\n\n        Raises:\n            FileNotFoundError: If archive doesn't exist\n        \"\"\"\n        path = Path(archive_path)\n\n        if not path.exists():\n            raise FileNotFoundError(f\"Archive not found: {path}\")\n\n        try:\n            archive_type = ArchiveFile.detect_archive_type(path)\n\n            if archive_type == \"zip\":\n                with zipfile.ZipFile(path, \"r\") as zf:\n                    contents = zf.namelist()\n            else:\n                # TAR archive\n                with tarfile.open(path, \"r\") as tf:\n                    contents = tf.getnames()\n\n            console.print(\n                f\"[blue]Listed {len(contents)} items in archive:[/blue] {path}\"\n            )\n            return contents\n\n        except Exception as e:\n            console.print(f\"[red]Error listing archive contents {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def extract_archive(\n        archive_path: PathLike, target_path: Optional[PathLike] = None\n    ) -&gt; None:\n        \"\"\"\n        Extract all contents from an ArchiveFile.\n\n        Args:\n            archive_path: Path to the archive to extract\n            target_path: Target directory for extraction (defaults to current directory)\n\n        Raises:\n            FileNotFoundError: If archive doesn't exist\n        \"\"\"\n        archive = Path(archive_path)\n        target = Path(target_path) if target_path else Path.cwd()\n\n        if not ArchiveFile.exists():\n            raise FileNotFoundError(f\"Archive not found: {archive}\")\n\n        try:\n            # Create target directory if it doesn't exist\n            target.mkdir(parents=True, exist_ok=True)\n\n            archive_type = ArchiveFile.detect_archive_type(archive)\n\n            if archive_type == \"zip\":\n                with zipfile.ZipFile(archive, \"r\") as zf:\n                    zf.extractall(target)\n            else:\n                # TAR archive\n                with tarfile.open(archive, \"r\") as tf:\n                    tf.extractall(target)\n\n            console.print(f\"[green]Extracted archive:[/green] {archive} \u2192 {target}\")\n\n        except Exception as e:\n            console.print(f\"[red]Error extracting archive {archive}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def extract_file_from_archive(\n        archive_path: PathLike, file_name: str, target_path: Optional[PathLike] = None\n    ) -&gt; None:\n        \"\"\"\n        Extract a specific file from an ArchiveFile.\n\n        Args:\n            archive_path: Path to the archive\n            file_name: Name of file to extract from archive\n            target_path: Target directory for extraction (defaults to current directory)\n\n        Raises:\n            FileNotFoundError: If archive doesn't exist or file not in archive\n        \"\"\"\n        archive = Path(archive_path)\n        target = Path(target_path) if target_path else Path.cwd()\n\n        if not ArchiveFile.exists():\n            raise FileNotFoundError(f\"Archive not found: {archive}\")\n\n        try:\n            # Create target directory if it doesn't exist\n            target.mkdir(parents=True, exist_ok=True)\n\n            archive_type = ArchiveFile.detect_archive_type(archive)\n\n            if archive_type == \"zip\":\n                with zipfile.ZipFile(archive, \"r\") as zf:\n                    if file_name not in zf.namelist():\n                        raise FileNotFoundError(\n                            f\"File '{file_name}' not found in archive\"\n                        )\n                    zf.extract(file_name, target)\n            else:\n                # TAR archive\n                with tarfile.open(archive, \"r\") as tf:\n                    if file_name not in tf.getnames():\n                        raise FileNotFoundError(\n                            f\"File '{file_name}' not found in archive\"\n                        )\n                    tf.extract(file_name, target)\n\n            console.print(f\"[green]Extracted file:[/green] {file_name} \u2192 {target}\")\n\n        except Exception as e:\n            console.print(f\"[red]Error extracting file from archive:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def archive_info(archive_path: PathLike) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get information about an ArchiveFile.\n\n        Args:\n            archive_path: Path to the archive\n\n        Returns:\n            Dictionary with archive information\n\n        Raises:\n            FileNotFoundError: If archive doesn't exist\n        \"\"\"\n        path = Path(archive_path)\n\n        if not path.exists():\n            raise FileNotFoundError(f\"Archive not found: {path}\")\n\n        try:\n            archive_type = ArchiveFile.detect_archive_type(path)\n            file_size = path.stat().st_size\n\n            if archive_type == \"zip\":\n                with zipfile.ZipFile(path, \"r\") as zf:\n                    file_count = len(zf.namelist())\n                    info = zf.infolist()\n                    total_uncompressed = sum(f.file_size for f in info)\n            else:\n                # TAR archive\n                with tarfile.open(path, \"r\") as tf:\n                    members = tf.getmembers()\n                    file_count = len([m for m in members if m.isfile()])\n                    total_uncompressed = sum(m.size for m in members if m.isfile())\n\n            return {\n                \"type\": archive_type,\n                \"file_count\": file_count,\n                \"compressed_size\": file_size,\n                \"uncompressed_size\": total_uncompressed,\n                \"compression_ratio\": (file_size / total_uncompressed)\n                if total_uncompressed &gt; 0\n                else 0,\n            }\n\n        except Exception as e:\n            console.print(f\"[red]Error getting archive info {path}:[/red] {e}\")\n            raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile-functions","title":"Functions","text":""},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.compression_type","title":"<code>compression_type(name)</code>  <code>classmethod</code>","text":"<p>Determines the compression type based on the file extension.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the archive file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The compression type (e.g., 'zip', 'tar', 'gz', etc.) or 'unknown' if not recognized.</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@classmethod\ndef compression_type(cls, name: str) -&gt; str:\n    \"\"\"\n    Determines the compression type based on the file extension.\n\n    Args:\n        name (str): The name of the archive file.\n\n    Returns:\n        str: The compression type (e.g., 'zip', 'tar', 'gz', etc.) or 'unknown' if not recognized.\n    \"\"\"\n    extension = get_file_extension(name)\n\n    compression_types = {\n        \"zip\": CompressionType.ZIP,\n        \"tar\": CompressionType.TAR,\n        \"tar.gz\": CompressionType.TAR_GZ,\n        \"tar.bz2\": CompressionType.TAR_BZ2,\n        \"tar.xz\": CompressionType.TAR_XZ,\n        \"gz\": CompressionType.GZIP,\n        \"bz2\": CompressionType.BZIP2,\n        \"xz\": CompressionType.XZ,\n        \"7z\": CompressionType.SEVEN_Z,\n        \"rar\": CompressionType.RAR,\n    }\n    return compression_types.get(extension, CompressionType.UNKNOWN)\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.add_archive_type","title":"<code>add_archive_type(name, extract_function, compress_function)</code>  <code>staticmethod</code>","text":"<p>Add a user defined archive type (also used for types like .whl, .app)</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef add_archive_type(name: str, extract_function, compress_function) -&gt; bool:\n    \"\"\"\n    Add a user defined archive type (also used for types like *.whl, *.app)\n    \"\"\"\n    done = CompressionType.add_archvive_type(name, extract_function, compress_function)\n    return done\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.detect_archive_type","title":"<code>detect_archive_type(archive_path)</code>  <code>staticmethod</code>","text":"<p>Detect the archive type from file extension.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path to the archive file</p> required <p>Returns:</p> Type Description <code>str</code> <p>Archive type ('zip', 'tar', 'tar.gz', 'tar.bz2')</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If archive type cannot be determined</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef detect_archive_type(archive_path: PathLike) -&gt; str:\n    \"\"\"\n    Detect the archive type from file extension.\n\n    Args:\n        archive_path: Path to the archive file\n\n    Returns:\n        Archive type ('zip', 'tar', 'tar.gz', 'tar.bz2')\n\n    Raises:\n        ValueError: If archive type cannot be determined\n    \"\"\"\n    path = Path(archive_path)\n\n    if path.suffix.lower() == \".zip\":\n        return \"zip\"\n    elif path.suffix.lower() == \".gz\":\n        return \"gz\"\n    elif path.suffix.lower() == \".bz2\":\n        return \"bz2\"\n    elif path.suffix.lower() == \".7z\":\n        return \"7z\"\n    elif path.suffix.lower() == \".rar\":\n        return \"rar\"\n    elif path.suffixes[-2:] == [\".tar\", \".gz\"]:\n        return \"tar.gz\"\n    elif path.suffixes[-2:] == [\".tar\", \".bz2\"]:\n        return \"tar.bz2\"\n    elif path.suffixes[-2:] == [\".tar\", \".xz\"]:\n        return \"tar.xz\"\n    elif path.suffix.lower() == \".tar\":\n        return \"tar\"\n    elif path.suffix.lower() == \".xz\":\n        return \"xz\"\n    else:\n        # check for project specific archive types\n        # TODO: !!! implement whl, app and more \n\n        raise ValueError(f\"Unsupported archive type for file: {path}\")\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.is_archive_file","title":"<code>is_archive_file(file_path)</code>  <code>staticmethod</code>","text":"<p>Check if a file is an archive based on its extension.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if file appears to be an archive, False otherwise</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef is_archive_file(file_path: PathLike) -&gt; bool:\n    \"\"\"\n    Check if a file is an archive based on its extension.\n\n    Args:\n        file_path: Path to check\n\n    Returns:\n        True if file appears to be an archive, False otherwise\n    \"\"\"\n    try:\n        ArchiveFile.detect_archive_type(file_path)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.create_zip_archive","title":"<code>create_zip_archive(archive_path, source_path=None)</code>  <code>staticmethod</code>","text":"<p>Create a new ZIP ArchiveFile.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path for the new archive</p> required <code>source_path</code> <code>Optional[PathLike]</code> <p>Optional source directory/file to add initially</p> <code>None</code> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If lacking create permissions</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef create_zip_archive(\n    archive_path: PathLike, source_path: Optional[PathLike] = None\n) -&gt; None:\n    \"\"\"\n    Create a new ZIP ArchiveFile.\n\n    Args:\n        archive_path: Path for the new archive\n        source_path: Optional source directory/file to add initially\n\n    Raises:\n        PermissionError: If lacking create permissions\n    \"\"\"\n    path = Path(archive_path)\n    try:\n        # Create parent directories if needed\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        with zipfile.ZipFile(path, \"w\", zipfile.ZIP_DEFLATED) as zf:\n            if source_path:\n                source = Path(source_path)\n                if source.is_file():\n                    zf.write(source, source.name)\n                elif source.is_dir():\n                    for file_path in source.rglob(\"*\"):\n                        if file_path.is_file():\n                            arcname = file_path.relative_to(source.parent)\n                            zf.write(file_path, arcname)\n\n        console.print(f\"[green]Created ZIP archive:[/green] {path}\")\n    except PermissionError:\n        console.print(f\"[red]Permission denied creating archive:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error creating ZIP archive {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.create_tar_archive","title":"<code>create_tar_archive(archive_path, source_path=None, compression=None)</code>  <code>staticmethod</code>","text":"<p>Create a new TAR ArchiveFile.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path for the new archive</p> required <code>source_path</code> <code>Optional[PathLike]</code> <p>Optional source directory/file to add initially</p> <code>None</code> <code>compression</code> <code>Optional[str]</code> <p>Compression type ('gz', 'bz2', or None)</p> <code>None</code> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If lacking create permissions</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef create_tar_archive(\n    archive_path: PathLike,\n    source_path: Optional[PathLike] = None,\n    compression: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Create a new TAR ArchiveFile.\n\n    Args:\n        archive_path: Path for the new archive\n        source_path: Optional source directory/file to add initially\n        compression: Compression type ('gz', 'bz2', or None)\n\n    Raises:\n        PermissionError: If lacking create permissions\n    \"\"\"\n    path = Path(archive_path)\n    try:\n        # Create parent directories if needed\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        mode = \"w\"\n        if compression == \"gz\":\n            mode = \"w:gz\"\n        elif compression == \"bz2\":\n            mode = \"w:bz2\"\n\n        with tarfile.open(path, mode) as tf:\n            if source_path:\n                source = Path(source_path)\n                if source.exists():\n                    tf.add(source, arcname=source.name)\n\n        console.print(f\"[green]Created TAR archive:[/green] {path}\")\n    except PermissionError:\n        console.print(f\"[red]Permission denied creating archive:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error creating TAR archive {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.add_file_to_zip","title":"<code>add_file_to_zip(archive_path, file_path, archive_name=None)</code>  <code>staticmethod</code>","text":"<p>Add a file to an existing ZIP ArchiveFile.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path to the ZIP archive</p> required <code>file_path</code> <code>PathLike</code> <p>Path to the file to add</p> required <code>archive_name</code> <code>Optional[str]</code> <p>Name to use in archive (defaults to filename)</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If archive or file doesn't exist</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef add_file_to_zip(\n    archive_path: PathLike, file_path: PathLike, archive_name: Optional[str] = None\n) -&gt; None:\n    \"\"\"\n    Add a file to an existing ZIP ArchiveFile.\n\n    Args:\n        archive_path: Path to the ZIP archive\n        file_path: Path to the file to add\n        archive_name: Name to use in archive (defaults to filename)\n\n    Raises:\n        FileNotFoundError: If archive or file doesn't exist\n    \"\"\"\n    archive = Path(archive_path)\n    file_to_add = Path(file_path)\n\n    if not ArchiveFile.exists():\n        raise FileNotFoundError(f\"Archive not found: {archive}\")\n    if not file_to_add.exists():\n        raise FileNotFoundError(f\"File not found: {file_to_add}\")\n\n    try:\n        arcname = archive_name or file_to_add.name\n\n        with zipfile.ZipFile(archive, \"a\", zipfile.ZIP_DEFLATED) as zf:\n            zf.write(file_to_add, arcname)\n\n        console.print(f\"[green]Added file to ZIP archive:[/green] {arcname}\")\n    except Exception as e:\n        console.print(f\"[red]Error adding file to ZIP archive:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.add_directory_to_zip","title":"<code>add_directory_to_zip(archive_path, dir_path, archive_name=None)</code>  <code>staticmethod</code>","text":"<p>Add a directory to an existing ZIP ArchiveFile.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path to the ZIP archive</p> required <code>dir_path</code> <code>PathLike</code> <p>Path to the directory to add</p> required <code>archive_name</code> <code>Optional[str]</code> <p>Name to use in archive (defaults to directory name)</p> <code>None</code> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef add_directory_to_zip(\n    archive_path: PathLike, dir_path: PathLike, archive_name: Optional[str] = None\n) -&gt; None:\n    \"\"\"\n    Add a directory to an existing ZIP ArchiveFile.\n\n    Args:\n        archive_path: Path to the ZIP archive\n        dir_path: Path to the directory to add\n        archive_name: Name to use in archive (defaults to directory name)\n    \"\"\"\n    archive = Path(archive_path)\n    directory = Path(dir_path)\n\n    if not ArchiveFile.exists():\n        raise FileNotFoundError(f\"Archive not found: {archive}\")\n    if not directory.exists():\n        raise FileNotFoundError(f\"Directory not found: {directory}\")\n    if not directory.is_dir():\n        raise NotADirectoryError(f\"Path is not a directory: {directory}\")\n\n    try:\n        base_name = archive_name or directory.name\n\n        with zipfile.ZipFile(archive, \"a\", zipfile.ZIP_DEFLATED) as zf:\n            for file_path in directory.rglob(\"*\"):\n                if file_path.is_file():\n                    relative_path = file_path.relative_to(directory)\n                    arcname = f\"{base_name}/{relative_path}\"\n                    zf.write(file_path, arcname)\n\n        console.print(f\"[green]Added directory to ZIP archive:[/green] {base_name}\")\n    except Exception as e:\n        console.print(f\"[red]Error adding directory to ZIP archive:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.add_file_to_tar","title":"<code>add_file_to_tar(archive_path, file_path, archive_name=None)</code>  <code>staticmethod</code>","text":"<p>Add a file to an existing TAR ArchiveFile.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path to the TAR archive</p> required <code>file_path</code> <code>PathLike</code> <p>Path to the file to add</p> required <code>archive_name</code> <code>Optional[str]</code> <p>Name to use in archive (defaults to filename)</p> <code>None</code> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef add_file_to_tar(\n    archive_path: PathLike, file_path: PathLike, archive_name: Optional[str] = None\n) -&gt; None:\n    \"\"\"\n    Add a file to an existing TAR ArchiveFile.\n\n    Args:\n        archive_path: Path to the TAR archive\n        file_path: Path to the file to add\n        archive_name: Name to use in archive (defaults to filename)\n    \"\"\"\n    archive = Path(archive_path)\n    file_to_add = Path(file_path)\n\n    if not ArchiveFile.exists():\n        raise FileNotFoundError(f\"Archive not found: {archive}\")\n    if not file_to_add.exists():\n        raise FileNotFoundError(f\"File not found: {file_to_add}\")\n\n    try:\n        # Determine TAR mode based on archive type\n        archive_type = ArchiveFile.detect_archive_type(archive)\n        if archive_type == \"tar.gz\":\n            mode = \"a:gz\"\n        elif archive_type == \"tar.bz2\":\n            mode = \"a:bz2\"\n        else:\n            mode = \"a\"\n\n        arcname = archive_name or file_to_add.name\n\n        with tarfile.open(archive, mode) as tf:\n            tf.add(file_to_add, arcname=arcname)\n\n        console.print(f\"[green]Added file to TAR archive:[/green] {arcname}\")\n    except Exception as e:\n        console.print(f\"[red]Error adding file to TAR archive:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.list_archive_contents","title":"<code>list_archive_contents(archive_path)</code>  <code>staticmethod</code>","text":"<p>List contents of an ArchiveFile.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path to the archive</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of file paths in the archive</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If archive doesn't exist</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef list_archive_contents(archive_path: PathLike) -&gt; List[str]:\n    \"\"\"\n    List contents of an ArchiveFile.\n\n    Args:\n        archive_path: Path to the archive\n\n    Returns:\n        List of file paths in the archive\n\n    Raises:\n        FileNotFoundError: If archive doesn't exist\n    \"\"\"\n    path = Path(archive_path)\n\n    if not path.exists():\n        raise FileNotFoundError(f\"Archive not found: {path}\")\n\n    try:\n        archive_type = ArchiveFile.detect_archive_type(path)\n\n        if archive_type == \"zip\":\n            with zipfile.ZipFile(path, \"r\") as zf:\n                contents = zf.namelist()\n        else:\n            # TAR archive\n            with tarfile.open(path, \"r\") as tf:\n                contents = tf.getnames()\n\n        console.print(\n            f\"[blue]Listed {len(contents)} items in archive:[/blue] {path}\"\n        )\n        return contents\n\n    except Exception as e:\n        console.print(f\"[red]Error listing archive contents {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.extract_archive","title":"<code>extract_archive(archive_path, target_path=None)</code>  <code>staticmethod</code>","text":"<p>Extract all contents from an ArchiveFile.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path to the archive to extract</p> required <code>target_path</code> <code>Optional[PathLike]</code> <p>Target directory for extraction (defaults to current directory)</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If archive doesn't exist</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef extract_archive(\n    archive_path: PathLike, target_path: Optional[PathLike] = None\n) -&gt; None:\n    \"\"\"\n    Extract all contents from an ArchiveFile.\n\n    Args:\n        archive_path: Path to the archive to extract\n        target_path: Target directory for extraction (defaults to current directory)\n\n    Raises:\n        FileNotFoundError: If archive doesn't exist\n    \"\"\"\n    archive = Path(archive_path)\n    target = Path(target_path) if target_path else Path.cwd()\n\n    if not ArchiveFile.exists():\n        raise FileNotFoundError(f\"Archive not found: {archive}\")\n\n    try:\n        # Create target directory if it doesn't exist\n        target.mkdir(parents=True, exist_ok=True)\n\n        archive_type = ArchiveFile.detect_archive_type(archive)\n\n        if archive_type == \"zip\":\n            with zipfile.ZipFile(archive, \"r\") as zf:\n                zf.extractall(target)\n        else:\n            # TAR archive\n            with tarfile.open(archive, \"r\") as tf:\n                tf.extractall(target)\n\n        console.print(f\"[green]Extracted archive:[/green] {archive} \u2192 {target}\")\n\n    except Exception as e:\n        console.print(f\"[red]Error extracting archive {archive}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.extract_file_from_archive","title":"<code>extract_file_from_archive(archive_path, file_name, target_path=None)</code>  <code>staticmethod</code>","text":"<p>Extract a specific file from an ArchiveFile.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path to the archive</p> required <code>file_name</code> <code>str</code> <p>Name of file to extract from archive</p> required <code>target_path</code> <code>Optional[PathLike]</code> <p>Target directory for extraction (defaults to current directory)</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If archive doesn't exist or file not in archive</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef extract_file_from_archive(\n    archive_path: PathLike, file_name: str, target_path: Optional[PathLike] = None\n) -&gt; None:\n    \"\"\"\n    Extract a specific file from an ArchiveFile.\n\n    Args:\n        archive_path: Path to the archive\n        file_name: Name of file to extract from archive\n        target_path: Target directory for extraction (defaults to current directory)\n\n    Raises:\n        FileNotFoundError: If archive doesn't exist or file not in archive\n    \"\"\"\n    archive = Path(archive_path)\n    target = Path(target_path) if target_path else Path.cwd()\n\n    if not ArchiveFile.exists():\n        raise FileNotFoundError(f\"Archive not found: {archive}\")\n\n    try:\n        # Create target directory if it doesn't exist\n        target.mkdir(parents=True, exist_ok=True)\n\n        archive_type = ArchiveFile.detect_archive_type(archive)\n\n        if archive_type == \"zip\":\n            with zipfile.ZipFile(archive, \"r\") as zf:\n                if file_name not in zf.namelist():\n                    raise FileNotFoundError(\n                        f\"File '{file_name}' not found in archive\"\n                    )\n                zf.extract(file_name, target)\n        else:\n            # TAR archive\n            with tarfile.open(archive, \"r\") as tf:\n                if file_name not in tf.getnames():\n                    raise FileNotFoundError(\n                        f\"File '{file_name}' not found in archive\"\n                    )\n                tf.extract(file_name, target)\n\n        console.print(f\"[green]Extracted file:[/green] {file_name} \u2192 {target}\")\n\n    except Exception as e:\n        console.print(f\"[red]Error extracting file from archive:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile.ArchiveFile.archive_info","title":"<code>archive_info(archive_path)</code>  <code>staticmethod</code>","text":"<p>Get information about an ArchiveFile.</p> <p>Parameters:</p> Name Type Description Default <code>archive_path</code> <code>PathLike</code> <p>Path to the archive</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with archive information</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If archive doesn't exist</p> Source code in <code>src/hands_scaphoid/objects/ArchiveFile.py</code> <pre><code>@staticmethod\ndef archive_info(archive_path: PathLike) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get information about an ArchiveFile.\n\n    Args:\n        archive_path: Path to the archive\n\n    Returns:\n        Dictionary with archive information\n\n    Raises:\n        FileNotFoundError: If archive doesn't exist\n    \"\"\"\n    path = Path(archive_path)\n\n    if not path.exists():\n        raise FileNotFoundError(f\"Archive not found: {path}\")\n\n    try:\n        archive_type = ArchiveFile.detect_archive_type(path)\n        file_size = path.stat().st_size\n\n        if archive_type == \"zip\":\n            with zipfile.ZipFile(path, \"r\") as zf:\n                file_count = len(zf.namelist())\n                info = zf.infolist()\n                total_uncompressed = sum(f.file_size for f in info)\n        else:\n            # TAR archive\n            with tarfile.open(path, \"r\") as tf:\n                members = tf.getmembers()\n                file_count = len([m for m in members if m.isfile()])\n                total_uncompressed = sum(m.size for m in members if m.isfile())\n\n        return {\n            \"type\": archive_type,\n            \"file_count\": file_count,\n            \"compressed_size\": file_size,\n            \"uncompressed_size\": total_uncompressed,\n            \"compression_ratio\": (file_size / total_uncompressed)\n            if total_uncompressed &gt; 0\n            else 0,\n        }\n\n    except Exception as e:\n        console.print(f\"[red]Error getting archive info {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/archive-file/#hands_scaphoid.objects.ArchiveFile-functions","title":"Functions","text":""},{"location":"api/objects/directory-object/","title":"DirectoryObject","text":""},{"location":"api/objects/directory-object/#directory-core-api-reference","title":"Directory Core API Reference","text":""},{"location":"api/objects/directory-object/#api-documentation","title":"API Documentation","text":""},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject","title":"<code>hands_scaphoid.objects.DirectoryObject</code>","text":"<p>Directory operations module for hands-scaphoid package.</p> <p>This module provides the Directory class for pure directory operations without context management.</p> File <p>name:   DirectoryOperations.py uuid:   dd9a984d-8031-4c2d-bb99-92dc0c7797f0 date:   2025-09-16</p> Description <p>Pure directory operations class - no context management</p> <p>Authors:    [\"Andreas H\u00e4berle\"]</p>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject-classes","title":"Classes","text":""},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject","title":"<code>DirectoryObject</code>","text":"<p>               Bases: <code>ObjectItem</code></p> <p>Pure directory operations class without context management.</p> <p>This class provides static methods for directory operations that can be used independently of any context manager. All methods operate on explicit directory paths and do not maintain any state.</p> Example Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>class DirectoryObject(ObjectItem):\n    \"\"\"\n    Pure directory operations class without context management.\n\n    This class provides static methods for directory operations that can be used\n    independently of any context manager. All methods operate on explicit\n    directory paths and do not maintain any state.\n\n    Example:\n        # Direct directory operations\n        Directory.create_directory(Path(\"myproject\"))\n        files = Directory.list_contents(Path(\"myproject\"))\n        Directory.copy_directory(Path(\"source\"), Path(\"target\"))\n    \"\"\"\n\n    def __init__(self, name: str, path: str):\n        super().__init__(name, path)\n\n    def __repr__(self):\n        return f\"DirectoryObject(name={self.name}, path={self.value})\"\n\n    @staticmethod\n    def create_directory(\n        dir_path: PathLike, parents: bool = True, exist_ok: bool = True\n    ) -&gt; None:\n        \"\"\"\n        Create a directory.\n\n        Args:\n            dir_path: Path to the directory to create\n            parents: Whether to create parent directories if they don't exist\n            exist_ok: Whether to raise an error if directory already exists\n\n        Raises:\n            PermissionError: If lacking create permissions\n            FileExistsError: If directory exists and exist_ok is False\n        \"\"\"\n        path = Path(dir_path)\n        try:\n            path.mkdir(parents=parents, exist_ok=exist_ok)\n            console.print(f\"[green]Created directory:[/green] {path}\")\n        except FileExistsError:\n            if not exist_ok:\n                console.print(f\"[red]Directory already exists:[/red] {path}\")\n                raise\n        except PermissionError:\n            console.print(f\"[red]Permission denied creating directory:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error creating directory {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def list_contents(dir_path: PathLike) -&gt; List[str]:\n        \"\"\"\n        List all items in a directory.\n\n        Args:\n            dir_path: Path to the directory to list\n\n        Returns:\n            List of file and directory names\n\n        Raises:\n            FileNotFoundError: If directory doesn't exist\n            PermissionError: If lacking read permissions\n        \"\"\"\n        path = Path(dir_path)\n        try:\n            if not path.exists():\n                raise FileNotFoundError(f\"Directory not found: {path}\")\n            if not path.is_dir():\n                raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n            contents = [item.name for item in path.iterdir()]\n            console.print(f\"[blue]Listed {len(contents)} items in:[/blue] {path}\")\n            return sorted(contents)\n        except PermissionError:\n            console.print(f\"[red]Permission denied reading directory:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error listing directory {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def list_files(dir_path: PathLike, extension: Optional[str] = None) -&gt; List[str]:\n        \"\"\"\n        List files in a directory, optionally filtered by extension.\n\n        Args:\n            dir_path: Path to the directory to list\n            extension: File extension filter (without dot, e.g., 'txt')\n\n        Returns:\n            List of filenames\n        \"\"\"\n        path = Path(dir_path)\n        try:\n            if not path.exists():\n                raise FileNotFoundError(f\"Directory not found: {path}\")\n            if not path.is_dir():\n                raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n            files = []\n            for item in path.iterdir():\n                if item.is_file():\n                    if (\n                        extension is None\n                        or item.suffix.lstrip(\".\").lower() == extension.lower()\n                    ):\n                        files.append(item.name)\n\n            console.print(f\"[blue]Found {len(files)} files in:[/blue] {path}\")\n            return sorted(files)\n        except PermissionError:\n            console.print(f\"[red]Permission denied reading directory:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error listing files in {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def list_directories(dir_path: PathLike) -&gt; List[str]:\n        \"\"\"\n        List subdirectories in a directory.\n\n        Args:\n            dir_path: Path to the directory to list\n\n        Returns:\n            List of subdirectory names\n        \"\"\"\n        path = Path(dir_path)\n        try:\n            if not path.exists():\n                raise FileNotFoundError(f\"Directory not found: {path}\")\n            if not path.is_dir():\n                raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n            dirs = []\n            for item in path.iterdir():\n                if item.is_dir():\n                    dirs.append(item.name)\n\n            console.print(f\"[blue]Found {len(dirs)} subdirectories in:[/blue] {path}\")\n            return sorted(dirs)\n        except PermissionError:\n            console.print(f\"[red]Permission denied reading directory:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error listing directories in {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def directory_exists(dir_path: PathLike) -&gt; bool:\n        \"\"\"\n        Check if a directory exists.\n\n        Args:\n            dir_path: Path to check\n\n        Returns:\n            True if directory exists and is a directory, False otherwise\n        \"\"\"\n        path = Path(dir_path)\n        return path.exists() and path.is_dir()\n\n    @staticmethod\n    def is_empty(dir_path: PathLike) -&gt; bool:\n        \"\"\"\n        Check if a directory is empty.\n\n        Args:\n            dir_path: Path to the directory to check\n\n        Returns:\n            True if directory is empty, False otherwise\n\n        Raises:\n            FileNotFoundError: If directory doesn't exist\n            NotADirectoryError: If path is not a directory\n        \"\"\"\n        path = Path(dir_path)\n        if not path.exists():\n            raise FileNotFoundError(f\"Directory not found: {path}\")\n        if not path.is_dir():\n            raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n        return len(list(path.iterdir())) == 0\n\n    @staticmethod\n    def copy_directory(\n        source_path: PathLike, target_path: PathLike, dirs_exist_ok: bool = False\n    ) -&gt; None:\n        \"\"\"\n        Copy a directory and its contents to a new location.\n\n        Args:\n            source_path: Path to the source directory\n            target_path: Path to the target directory\n            dirs_exist_ok: Whether to allow copying to existing directory\n\n        Raises:\n            FileNotFoundError: If source directory doesn't exist\n            PermissionError: If lacking copy permissions\n        \"\"\"\n        source = Path(source_path)\n        target = Path(target_path)\n\n        if not source.exists():\n            raise FileNotFoundError(f\"Source directory not found: {source}\")\n        if not source.is_dir():\n            raise NotADirectoryError(f\"Source path is not a directory: {source}\")\n\n        try:\n            shutil.copytree(source, target, dirs_exist_ok=dirs_exist_ok)\n            console.print(f\"[green]Copied directory:[/green] {source} \u2192 {target}\")\n        except PermissionError:\n            console.print(\n                f\"[red]Permission denied copying directory:[/red] {source} \u2192 {target}\"\n            )\n            raise\n        except Exception as e:\n            console.print(\n                f\"[red]Error copying directory {source} \u2192 {target}:[/red] {e}\"\n            )\n            raise\n\n    @staticmethod\n    def move_directory(source_path: PathLike, target_path: PathLike) -&gt; None:\n        \"\"\"\n        Move a directory to a new location.\n\n        Args:\n            source_path: Path to the source directory\n            target_path: Path to the target directory\n\n        Raises:\n            FileNotFoundError: If source directory doesn't exist\n            PermissionError: If lacking move permissions\n        \"\"\"\n        source = Path(source_path)\n        target = Path(target_path)\n\n        if not source.exists():\n            raise FileNotFoundError(f\"Source directory not found: {source}\")\n        if not source.is_dir():\n            raise NotADirectoryError(f\"Source path is not a directory: {source}\")\n\n        try:\n            shutil.move(str(source), str(target))\n            console.print(f\"[green]Moved directory:[/green] {source} \u2192 {target}\")\n        except PermissionError:\n            console.print(\n                f\"[red]Permission denied moving directory:[/red] {source} \u2192 {target}\"\n            )\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error moving directory {source} \u2192 {target}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def delete_directory(dir_path: PathLike, recursive: bool = False) -&gt; None:\n        \"\"\"\n        Delete a directory.\n\n        Args:\n            dir_path: Path to the directory to delete\n            recursive: Whether to delete directory and all its contents\n\n        Raises:\n            FileNotFoundError: If directory doesn't exist\n            PermissionError: If lacking delete permissions\n            OSError: If directory is not empty and recursive is False\n        \"\"\"\n        path = Path(dir_path)\n\n        if not path.exists():\n            raise FileNotFoundError(f\"Directory not found: {path}\")\n        if not path.is_dir():\n            raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n        try:\n            if recursive:\n                shutil.rmtree(path)\n                console.print(f\"[green]Deleted directory recursively:[/green] {path}\")\n            else:\n                path.rmdir()\n                console.print(f\"[green]Deleted directory:[/green] {path}\")\n        except PermissionError:\n            console.print(f\"[red]Permission denied deleting directory:[/red] {path}\")\n            raise\n        except OSError as e:\n            if \"not empty\" in str(e).lower():\n                console.print(\n                    f\"[red]Directory not empty (use recursive=True):[/red] {path}\"\n                )\n            else:\n                console.print(f\"[red]Error deleting directory {path}:[/red] {e}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error deleting directory {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def get_directory_size(dir_path: PathLike) -&gt; int:\n        \"\"\"\n        Get the total size of a directory and its contents in bytes.\n\n        Args:\n            dir_path: Path to the directory\n\n        Returns:\n            Total size in bytes\n\n        Raises:\n            FileNotFoundError: If directory doesn't exist\n        \"\"\"\n        path = Path(dir_path)\n        if not path.exists():\n            raise FileNotFoundError(f\"Directory not found: {path}\")\n        if not path.is_dir():\n            raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n        total_size = 0\n        try:\n            for item in path.rglob(\"*\"):\n                if item.is_file():\n                    total_size += item.stat().st_size\n            return total_size\n        except PermissionError:\n            console.print(\n                f\"[red]Permission denied accessing some files in:[/red] {path}\"\n            )\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error calculating directory size {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def change_directory(dir_path: PathLike) -&gt; str:\n        \"\"\"\n        Change the current working directory.\n\n        Args:\n            dir_path: Path to change to\n\n        Returns:\n            Previous working directory path\n\n        Raises:\n            FileNotFoundError: If directory doesn't exist\n            PermissionError: If lacking access permissions\n        \"\"\"\n        path = Path(dir_path)\n\n        if not path.exists():\n            raise FileNotFoundError(f\"Directory not found: {path}\")\n        if not path.is_dir():\n            raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n        try:\n            previous_cwd = os.getcwd()\n            os.chdir(path)\n            console.print(f\"[blue]Changed directory to:[/blue] {path}\")\n            return previous_cwd\n        except PermissionError:\n            console.print(f\"[red]Permission denied changing to directory:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error changing to directory {path}:[/red] {e}\")\n            raise\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject--direct-directory-operations","title":"Direct directory operations","text":"<p>Directory.create_directory(Path(\"myproject\")) files = Directory.list_contents(Path(\"myproject\")) Directory.copy_directory(Path(\"source\"), Path(\"target\"))</p>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject-functions","title":"Functions","text":""},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.create_directory","title":"<code>create_directory(dir_path, parents=True, exist_ok=True)</code>  <code>staticmethod</code>","text":"<p>Create a directory.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>Path to the directory to create</p> required <code>parents</code> <code>bool</code> <p>Whether to create parent directories if they don't exist</p> <code>True</code> <code>exist_ok</code> <code>bool</code> <p>Whether to raise an error if directory already exists</p> <code>True</code> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If lacking create permissions</p> <code>FileExistsError</code> <p>If directory exists and exist_ok is False</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef create_directory(\n    dir_path: PathLike, parents: bool = True, exist_ok: bool = True\n) -&gt; None:\n    \"\"\"\n    Create a directory.\n\n    Args:\n        dir_path: Path to the directory to create\n        parents: Whether to create parent directories if they don't exist\n        exist_ok: Whether to raise an error if directory already exists\n\n    Raises:\n        PermissionError: If lacking create permissions\n        FileExistsError: If directory exists and exist_ok is False\n    \"\"\"\n    path = Path(dir_path)\n    try:\n        path.mkdir(parents=parents, exist_ok=exist_ok)\n        console.print(f\"[green]Created directory:[/green] {path}\")\n    except FileExistsError:\n        if not exist_ok:\n            console.print(f\"[red]Directory already exists:[/red] {path}\")\n            raise\n    except PermissionError:\n        console.print(f\"[red]Permission denied creating directory:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error creating directory {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.list_contents","title":"<code>list_contents(dir_path)</code>  <code>staticmethod</code>","text":"<p>List all items in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>Path to the directory to list</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of file and directory names</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If directory doesn't exist</p> <code>PermissionError</code> <p>If lacking read permissions</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef list_contents(dir_path: PathLike) -&gt; List[str]:\n    \"\"\"\n    List all items in a directory.\n\n    Args:\n        dir_path: Path to the directory to list\n\n    Returns:\n        List of file and directory names\n\n    Raises:\n        FileNotFoundError: If directory doesn't exist\n        PermissionError: If lacking read permissions\n    \"\"\"\n    path = Path(dir_path)\n    try:\n        if not path.exists():\n            raise FileNotFoundError(f\"Directory not found: {path}\")\n        if not path.is_dir():\n            raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n        contents = [item.name for item in path.iterdir()]\n        console.print(f\"[blue]Listed {len(contents)} items in:[/blue] {path}\")\n        return sorted(contents)\n    except PermissionError:\n        console.print(f\"[red]Permission denied reading directory:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error listing directory {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.list_files","title":"<code>list_files(dir_path, extension=None)</code>  <code>staticmethod</code>","text":"<p>List files in a directory, optionally filtered by extension.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>Path to the directory to list</p> required <code>extension</code> <code>Optional[str]</code> <p>File extension filter (without dot, e.g., 'txt')</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of filenames</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef list_files(dir_path: PathLike, extension: Optional[str] = None) -&gt; List[str]:\n    \"\"\"\n    List files in a directory, optionally filtered by extension.\n\n    Args:\n        dir_path: Path to the directory to list\n        extension: File extension filter (without dot, e.g., 'txt')\n\n    Returns:\n        List of filenames\n    \"\"\"\n    path = Path(dir_path)\n    try:\n        if not path.exists():\n            raise FileNotFoundError(f\"Directory not found: {path}\")\n        if not path.is_dir():\n            raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n        files = []\n        for item in path.iterdir():\n            if item.is_file():\n                if (\n                    extension is None\n                    or item.suffix.lstrip(\".\").lower() == extension.lower()\n                ):\n                    files.append(item.name)\n\n        console.print(f\"[blue]Found {len(files)} files in:[/blue] {path}\")\n        return sorted(files)\n    except PermissionError:\n        console.print(f\"[red]Permission denied reading directory:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error listing files in {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.list_directories","title":"<code>list_directories(dir_path)</code>  <code>staticmethod</code>","text":"<p>List subdirectories in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>Path to the directory to list</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of subdirectory names</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef list_directories(dir_path: PathLike) -&gt; List[str]:\n    \"\"\"\n    List subdirectories in a directory.\n\n    Args:\n        dir_path: Path to the directory to list\n\n    Returns:\n        List of subdirectory names\n    \"\"\"\n    path = Path(dir_path)\n    try:\n        if not path.exists():\n            raise FileNotFoundError(f\"Directory not found: {path}\")\n        if not path.is_dir():\n            raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n        dirs = []\n        for item in path.iterdir():\n            if item.is_dir():\n                dirs.append(item.name)\n\n        console.print(f\"[blue]Found {len(dirs)} subdirectories in:[/blue] {path}\")\n        return sorted(dirs)\n    except PermissionError:\n        console.print(f\"[red]Permission denied reading directory:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error listing directories in {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.directory_exists","title":"<code>directory_exists(dir_path)</code>  <code>staticmethod</code>","text":"<p>Check if a directory exists.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>Path to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if directory exists and is a directory, False otherwise</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef directory_exists(dir_path: PathLike) -&gt; bool:\n    \"\"\"\n    Check if a directory exists.\n\n    Args:\n        dir_path: Path to check\n\n    Returns:\n        True if directory exists and is a directory, False otherwise\n    \"\"\"\n    path = Path(dir_path)\n    return path.exists() and path.is_dir()\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.is_empty","title":"<code>is_empty(dir_path)</code>  <code>staticmethod</code>","text":"<p>Check if a directory is empty.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>Path to the directory to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if directory is empty, False otherwise</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If directory doesn't exist</p> <code>NotADirectoryError</code> <p>If path is not a directory</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef is_empty(dir_path: PathLike) -&gt; bool:\n    \"\"\"\n    Check if a directory is empty.\n\n    Args:\n        dir_path: Path to the directory to check\n\n    Returns:\n        True if directory is empty, False otherwise\n\n    Raises:\n        FileNotFoundError: If directory doesn't exist\n        NotADirectoryError: If path is not a directory\n    \"\"\"\n    path = Path(dir_path)\n    if not path.exists():\n        raise FileNotFoundError(f\"Directory not found: {path}\")\n    if not path.is_dir():\n        raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n    return len(list(path.iterdir())) == 0\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.copy_directory","title":"<code>copy_directory(source_path, target_path, dirs_exist_ok=False)</code>  <code>staticmethod</code>","text":"<p>Copy a directory and its contents to a new location.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>PathLike</code> <p>Path to the source directory</p> required <code>target_path</code> <code>PathLike</code> <p>Path to the target directory</p> required <code>dirs_exist_ok</code> <code>bool</code> <p>Whether to allow copying to existing directory</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If source directory doesn't exist</p> <code>PermissionError</code> <p>If lacking copy permissions</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef copy_directory(\n    source_path: PathLike, target_path: PathLike, dirs_exist_ok: bool = False\n) -&gt; None:\n    \"\"\"\n    Copy a directory and its contents to a new location.\n\n    Args:\n        source_path: Path to the source directory\n        target_path: Path to the target directory\n        dirs_exist_ok: Whether to allow copying to existing directory\n\n    Raises:\n        FileNotFoundError: If source directory doesn't exist\n        PermissionError: If lacking copy permissions\n    \"\"\"\n    source = Path(source_path)\n    target = Path(target_path)\n\n    if not source.exists():\n        raise FileNotFoundError(f\"Source directory not found: {source}\")\n    if not source.is_dir():\n        raise NotADirectoryError(f\"Source path is not a directory: {source}\")\n\n    try:\n        shutil.copytree(source, target, dirs_exist_ok=dirs_exist_ok)\n        console.print(f\"[green]Copied directory:[/green] {source} \u2192 {target}\")\n    except PermissionError:\n        console.print(\n            f\"[red]Permission denied copying directory:[/red] {source} \u2192 {target}\"\n        )\n        raise\n    except Exception as e:\n        console.print(\n            f\"[red]Error copying directory {source} \u2192 {target}:[/red] {e}\"\n        )\n        raise\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.move_directory","title":"<code>move_directory(source_path, target_path)</code>  <code>staticmethod</code>","text":"<p>Move a directory to a new location.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>PathLike</code> <p>Path to the source directory</p> required <code>target_path</code> <code>PathLike</code> <p>Path to the target directory</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If source directory doesn't exist</p> <code>PermissionError</code> <p>If lacking move permissions</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef move_directory(source_path: PathLike, target_path: PathLike) -&gt; None:\n    \"\"\"\n    Move a directory to a new location.\n\n    Args:\n        source_path: Path to the source directory\n        target_path: Path to the target directory\n\n    Raises:\n        FileNotFoundError: If source directory doesn't exist\n        PermissionError: If lacking move permissions\n    \"\"\"\n    source = Path(source_path)\n    target = Path(target_path)\n\n    if not source.exists():\n        raise FileNotFoundError(f\"Source directory not found: {source}\")\n    if not source.is_dir():\n        raise NotADirectoryError(f\"Source path is not a directory: {source}\")\n\n    try:\n        shutil.move(str(source), str(target))\n        console.print(f\"[green]Moved directory:[/green] {source} \u2192 {target}\")\n    except PermissionError:\n        console.print(\n            f\"[red]Permission denied moving directory:[/red] {source} \u2192 {target}\"\n        )\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error moving directory {source} \u2192 {target}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.delete_directory","title":"<code>delete_directory(dir_path, recursive=False)</code>  <code>staticmethod</code>","text":"<p>Delete a directory.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>Path to the directory to delete</p> required <code>recursive</code> <code>bool</code> <p>Whether to delete directory and all its contents</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If directory doesn't exist</p> <code>PermissionError</code> <p>If lacking delete permissions</p> <code>OSError</code> <p>If directory is not empty and recursive is False</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef delete_directory(dir_path: PathLike, recursive: bool = False) -&gt; None:\n    \"\"\"\n    Delete a directory.\n\n    Args:\n        dir_path: Path to the directory to delete\n        recursive: Whether to delete directory and all its contents\n\n    Raises:\n        FileNotFoundError: If directory doesn't exist\n        PermissionError: If lacking delete permissions\n        OSError: If directory is not empty and recursive is False\n    \"\"\"\n    path = Path(dir_path)\n\n    if not path.exists():\n        raise FileNotFoundError(f\"Directory not found: {path}\")\n    if not path.is_dir():\n        raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n    try:\n        if recursive:\n            shutil.rmtree(path)\n            console.print(f\"[green]Deleted directory recursively:[/green] {path}\")\n        else:\n            path.rmdir()\n            console.print(f\"[green]Deleted directory:[/green] {path}\")\n    except PermissionError:\n        console.print(f\"[red]Permission denied deleting directory:[/red] {path}\")\n        raise\n    except OSError as e:\n        if \"not empty\" in str(e).lower():\n            console.print(\n                f\"[red]Directory not empty (use recursive=True):[/red] {path}\"\n            )\n        else:\n            console.print(f\"[red]Error deleting directory {path}:[/red] {e}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error deleting directory {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.get_directory_size","title":"<code>get_directory_size(dir_path)</code>  <code>staticmethod</code>","text":"<p>Get the total size of a directory and its contents in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>Path to the directory</p> required <p>Returns:</p> Type Description <code>int</code> <p>Total size in bytes</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If directory doesn't exist</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef get_directory_size(dir_path: PathLike) -&gt; int:\n    \"\"\"\n    Get the total size of a directory and its contents in bytes.\n\n    Args:\n        dir_path: Path to the directory\n\n    Returns:\n        Total size in bytes\n\n    Raises:\n        FileNotFoundError: If directory doesn't exist\n    \"\"\"\n    path = Path(dir_path)\n    if not path.exists():\n        raise FileNotFoundError(f\"Directory not found: {path}\")\n    if not path.is_dir():\n        raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n    total_size = 0\n    try:\n        for item in path.rglob(\"*\"):\n            if item.is_file():\n                total_size += item.stat().st_size\n        return total_size\n    except PermissionError:\n        console.print(\n            f\"[red]Permission denied accessing some files in:[/red] {path}\"\n        )\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error calculating directory size {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/directory-object/#hands_scaphoid.objects.DirectoryObject.DirectoryObject.change_directory","title":"<code>change_directory(dir_path)</code>  <code>staticmethod</code>","text":"<p>Change the current working directory.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>Path to change to</p> required <p>Returns:</p> Type Description <code>str</code> <p>Previous working directory path</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If directory doesn't exist</p> <code>PermissionError</code> <p>If lacking access permissions</p> Source code in <code>src/hands_scaphoid/objects/DirectoryObject.py</code> <pre><code>@staticmethod\ndef change_directory(dir_path: PathLike) -&gt; str:\n    \"\"\"\n    Change the current working directory.\n\n    Args:\n        dir_path: Path to change to\n\n    Returns:\n        Previous working directory path\n\n    Raises:\n        FileNotFoundError: If directory doesn't exist\n        PermissionError: If lacking access permissions\n    \"\"\"\n    path = Path(dir_path)\n\n    if not path.exists():\n        raise FileNotFoundError(f\"Directory not found: {path}\")\n    if not path.is_dir():\n        raise NotADirectoryError(f\"Path is not a directory: {path}\")\n\n    try:\n        previous_cwd = os.getcwd()\n        os.chdir(path)\n        console.print(f\"[blue]Changed directory to:[/blue] {path}\")\n        return previous_cwd\n    except PermissionError:\n        console.print(f\"[red]Permission denied changing to directory:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error changing to directory {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/executable-file/","title":"Executable Core API Reference","text":""},{"location":"api/objects/executable-file/#api-documentation","title":"API documentation","text":""},{"location":"api/objects/executable-file/#hands_scaphoid.objects.files.ExecutableFile","title":"<code>hands_scaphoid.objects.files.ExecutableFile</code>","text":""},{"location":"api/objects/executable-file/#hands_scaphoid.objects.files.ExecutableFile--windows-shells-powershell-and-wslshell","title":"Windows shells (PowerShell and WslShell)","text":"<p>file:     name:        WindowsShells.py     uuid:        1b38546a-16d2-4be6-b807-4d0bbe4f9815 description:     implementing ShellExecutables for Windows authors:         felix@42sol.eu project: project:     name:        hands_scaphoid     uuid:        2945ba3b-2d66-4dff-b898-672c386f03f4     url:         https://github.com/42sol-eu/hands_scaphoid</p>"},{"location":"api/objects/executable-file/#hands_scaphoid.objects.files.ExecutableFile-classes","title":"Classes","text":""},{"location":"api/objects/executable-file/#hands_scaphoid.objects.files.ExecutableFile.ExecutableFile","title":"<code>ExecutableFile</code>","text":"<p>               Bases: <code>FileObject</code></p> <p>Core class for executable objects.</p> Source code in <code>src/hands_scaphoid/objects/files/ExecutableFile.py</code> <pre><code>class ExecutableFile(FileObject):\n    \"\"\"\n    Core class for executable objects.\n    \"\"\"\n\n    def __init__(self, name: str, path: str):\n        super().__init__(name, path)\n        self.name = name\n        self.path = path\n\n    def execute(self, *args, **kwargs):\n        \"\"\"\n        Execute the core executable with given arguments.\n        \"\"\"\n        print(\n            f\"Executing {self.name} at {self.path} with args: {args} and kwargs: {kwargs}\"\n        )\n        # Here you would add the actual execution logic, e.g., using subprocess\n        # For demonstration, we'll just return a success message\n        return f\"{self.name} executed successfully.\"\n</code></pre>"},{"location":"api/objects/executable-file/#hands_scaphoid.objects.files.ExecutableFile.ExecutableFile-functions","title":"Functions","text":""},{"location":"api/objects/executable-file/#hands_scaphoid.objects.files.ExecutableFile.ExecutableFile.execute","title":"<code>execute(*args, **kwargs)</code>","text":"<p>Execute the core executable with given arguments.</p> Source code in <code>src/hands_scaphoid/objects/files/ExecutableFile.py</code> <pre><code>def execute(self, *args, **kwargs):\n    \"\"\"\n    Execute the core executable with given arguments.\n    \"\"\"\n    print(\n        f\"Executing {self.name} at {self.path} with args: {args} and kwargs: {kwargs}\"\n    )\n    # Here you would add the actual execution logic, e.g., using subprocess\n    # For demonstration, we'll just return a success message\n    return f\"{self.name} executed successfully.\"\n</code></pre>"},{"location":"api/objects/file-object/","title":"FileObject API Reference","text":""},{"location":"api/objects/file-object/#api-documentation","title":"API documentation","text":""},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject","title":"<code>hands_scaphoid.objects.FileObject</code>","text":"<p>File operations module for hands-scaphoid package.</p> <p>This module provides the File class for pure file operations without context management.</p> File <p>name: FileObject.py uuid: 63856607-707d-4e3b-8e15-3d81661086b0 date: 2025-09-16</p> Description <p>Pure file operations class - no context management</p> Project <p>name: hands_scaphoid uuid: 2945ba3b-2d66-4dff-b898-672c386f03f4 url: https://github.com/42sol-eu/hands_scaphoid</p> <p>Authors: [\"Andreas H\u00e4berle\"]</p>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject-classes","title":"Classes","text":""},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject","title":"<code>FileObject</code>","text":"<p>               Bases: <code>ObjectItem</code></p> <p>Represents a file in the shell context. Pure file operations class without context management.</p> <p>This class provides static methods for file operations that can be used independently of any context manager. All methods operate on explicit file paths and do not maintain any state.</p> Example <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the file.</p> <code>path</code> <code>str</code> <p>The path of the file in the filesystem.</p> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>class FileObject(ObjectItem):\n    \"\"\"\n    Represents a file in the shell context.\n    Pure file operations class without context management.\n\n    This class provides static methods for file operations that can be used\n    independently of any context manager. All methods operate on explicit\n    file paths and do not maintain any state.\n\n    Example:\n        # Direct file operations\n        File.write_content(Path(\"config.txt\"), \"setting=value\")\n        content = File.read_content(Path(\"config.txt\"))\n        File.append_line(Path(\"log.txt\"), \"New log entry\")\n\n    Attributes:\n        name (str): The name of the file.\n        path (str): The path of the file in the filesystem.\n    \"\"\"\n\n    def __init__(self, name: str, path: str):\n        super().__init__(name, path, item_type=ItemType.FILE)\n\n    def __repr__(self):\n        return f\"FileObject(name={self.name}, path={self.path})\"\n\n    @staticmethod\n    def read_content(file_path: PathLike) -&gt; str:\n        \"\"\"\n        Read the entire content of a file.\n\n        Args:\n            file_path: Path to the file to read\n\n        Returns:\n            File content as string\n\n        Raises:\n            FileNotFoundError: If the file doesn't exist\n            PermissionError: If lacking read permissions\n        \"\"\"\n        path = Path(file_path)\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except FileNotFoundError:\n            console.print(f\"[red]File not found:[/red] {path}\")\n            raise\n        except PermissionError:\n            console.print(f\"[red]Permission denied reading file:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error reading file {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def read_lines(file_path: PathLike) -&gt; List[str]:\n        \"\"\"\n        Read all lines from a file.\n\n        Args:\n            file_path: Path to the file to read\n\n        Returns:\n            List of lines from the file\n        \"\"\"\n        path = Path(file_path)\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                return f.readlines()\n        except FileNotFoundError:\n            console.print(f\"[red]File not found:[/red] {path}\")\n            raise\n        except PermissionError:\n            console.print(f\"[red]Permission denied reading file:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error reading file {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def write_content(\n        file_path: PathLike, content: str, create_dirs: bool = True\n    ) -&gt; None:\n        \"\"\"\n        Write content to a file, replacing existing content.\n\n        Args:\n            file_path: Path to the file to write\n            content: Content to write to the file\n            create_dirs: Whether to create parent directories if they don't exist\n\n        Raises:\n            PermissionError: If lacking write permissions\n        \"\"\"\n        path = Path(file_path)\n        try:\n            if create_dirs:\n                path.parent.mkdir(parents=True, exist_ok=True)\n\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n            console.print(f\"[green]Wrote content to file:[/green] {path}\")\n        except PermissionError:\n            console.print(f\"[red]Permission denied writing file:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error writing file {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def append_content(\n        file_path: PathLike, content: str, create_dirs: bool = True\n    ) -&gt; None:\n        \"\"\"\n        Append content to a file.\n\n        Args:\n            file_path: Path to the file to append to\n            content: Content to append to the file\n            create_dirs: Whether to create parent directories if they don't exist\n        \"\"\"\n        path = Path(file_path)\n        try:\n            if create_dirs:\n                path.parent.mkdir(parents=True, exist_ok=True)\n\n            with open(path, \"a\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n            console.print(f\"[green]Appended content to file:[/green] {path}\")\n        except PermissionError:\n            console.print(f\"[red]Permission denied writing file:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error writing file {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def write_line(file_path: PathLike, line: str, create_dirs: bool = True) -&gt; None:\n        \"\"\"\n        Write a line to a file, replacing existing content.\n\n        Args:\n            file_path: Path to the file to write\n            line: Line to write to the file (newline will be added)\n            create_dirs: Whether to create parent directories if they don't exist\n        \"\"\"\n        content = line if line.endswith(\"\\n\") else line + \"\\n\"\n        FileObject.write_content(file_path, content, create_dirs)\n\n    @staticmethod\n    def append_line(file_path: PathLike, line: str, create_dirs: bool = True) -&gt; None:\n        \"\"\"\n        Append a line to a file.\n\n        Args:\n            file_path: Path to the file to append to\n            line: Line to append to the file (newline will be added)\n            create_dirs: Whether to create parent directories if they don't exist\n        \"\"\"\n        content = line if line.endswith(\"\\n\") else line + \"\\n\"\n        FileObject.append_content(file_path, content, create_dirs)\n\n    @staticmethod\n    def add_heading(\n        file_path: PathLike, title: str, level: int = 1, create_dirs: bool = True\n    ) -&gt; None:\n        \"\"\"\n        Append a markdown-style heading to a file.\n\n        Args:\n            file_path: Path to the file to append to\n            title: Heading text\n            level: Heading level (1-6)\n            create_dirs: Whether to create parent directories if they don't exist\n        \"\"\"\n        if not 1 &lt;= level &lt;= 6:\n            raise ValueError(\"Heading level must be between 1 and 6\")\n\n        heading = \"#\" * level + \" \" + title + \"\\n\"\n        FileObject.append_content(file_path, heading, create_dirs)\n\n    @staticmethod\n    def create_file(file_path: PathLike, create_dirs: bool = True) -&gt; None:\n        \"\"\"\n        Create an empty file.\n\n        Args:\n            file_path: Path to the file to create\n            create_dirs: Whether to create parent directories if they don't exist\n        \"\"\"\n        path = Path(file_path)\n        try:\n            if create_dirs:\n                path.parent.mkdir(parents=True, exist_ok=True)\n\n            path.touch()\n            console.print(f\"[green]Created file:[/green] {path}\")\n        except PermissionError:\n            console.print(f\"[red]Permission denied creating file:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error creating file {path}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def file_exists(file_path: PathLike) -&gt; bool:\n        \"\"\"\n        Check if a file exists.\n\n        Args:\n            file_path: Path to check\n\n        Returns:\n            True if file exists and is a file, False otherwise\n        \"\"\"\n        path = Path(file_path)\n        return path.exists() and path.is_file()\n\n    @staticmethod\n    def get_file_size(file_path: PathLike) -&gt; int:\n        \"\"\"\n        Get the size of a file in bytes.\n\n        Args:\n            file_path: Path to the file\n\n        Returns:\n            File size in bytes\n\n        Raises:\n            FileNotFoundError: If the file doesn't exist\n        \"\"\"\n        path = Path(file_path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n        return path.stat().st_size\n\n    @staticmethod\n    def copy_file(\n        source_path: PathLike, target_path: PathLike, create_dirs: bool = True\n    ) -&gt; None:\n        \"\"\"\n        Copy a file from source to target.\n\n        Args:\n            source_path: Path to the source file\n            target_path: Path to the target file\n            create_dirs: Whether to create target parent directories if they don't exist\n        \"\"\"\n\n        source = Path(source_path)\n        target = Path(target_path)\n\n        if not source.exists():\n            raise FileNotFoundError(f\"Source file not found: {source}\")\n\n        try:\n            if create_dirs:\n                target.parent.mkdir(parents=True, exist_ok=True)\n\n            shutil.copy2(source, target)\n            console.print(f\"[green]Copied file:[/green] {source} \u2192 {target}\")\n        except PermissionError:\n            console.print(\n                f\"[red]Permission denied copying file:[/red] {source} \u2192 {target}\"\n            )\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error copying file {source} \u2192 {target}:[/red] {e}\")\n            raise\n\n    @staticmethod\n    def delete_file(file_path: PathLike) -&gt; None:\n        \"\"\"\n        Delete a file.\n\n        Args:\n            file_path: Path to the file to delete\n\n        Raises:\n            FileNotFoundError: If the file doesn't exist\n            PermissionError: If lacking delete permissions\n        \"\"\"\n        path = Path(file_path)\n        try:\n            if not path.exists():\n                raise FileNotFoundError(f\"File not found: {path}\")\n\n            path.unlink()\n            console.print(f\"[green]Deleted file:[/green] {path}\")\n        except PermissionError:\n            console.print(f\"[red]Permission denied deleting file:[/red] {path}\")\n            raise\n        except Exception as e:\n            console.print(f\"[red]Error deleting file {path}:[/red] {e}\")\n            raise\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject--direct-file-operations","title":"Direct file operations","text":"<p>File.write_content(Path(\"config.txt\"), \"setting=value\") content = File.read_content(Path(\"config.txt\")) File.append_line(Path(\"log.txt\"), \"New log entry\")</p>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject-functions","title":"Functions","text":""},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.read_content","title":"<code>read_content(file_path)</code>  <code>staticmethod</code>","text":"<p>Read the entire content of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file to read</p> required <p>Returns:</p> Type Description <code>str</code> <p>File content as string</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>PermissionError</code> <p>If lacking read permissions</p> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef read_content(file_path: PathLike) -&gt; str:\n    \"\"\"\n    Read the entire content of a file.\n\n    Args:\n        file_path: Path to the file to read\n\n    Returns:\n        File content as string\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        PermissionError: If lacking read permissions\n    \"\"\"\n    path = Path(file_path)\n    try:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    except FileNotFoundError:\n        console.print(f\"[red]File not found:[/red] {path}\")\n        raise\n    except PermissionError:\n        console.print(f\"[red]Permission denied reading file:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error reading file {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.read_lines","title":"<code>read_lines(file_path)</code>  <code>staticmethod</code>","text":"<p>Read all lines from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file to read</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of lines from the file</p> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef read_lines(file_path: PathLike) -&gt; List[str]:\n    \"\"\"\n    Read all lines from a file.\n\n    Args:\n        file_path: Path to the file to read\n\n    Returns:\n        List of lines from the file\n    \"\"\"\n    path = Path(file_path)\n    try:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            return f.readlines()\n    except FileNotFoundError:\n        console.print(f\"[red]File not found:[/red] {path}\")\n        raise\n    except PermissionError:\n        console.print(f\"[red]Permission denied reading file:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error reading file {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.write_content","title":"<code>write_content(file_path, content, create_dirs=True)</code>  <code>staticmethod</code>","text":"<p>Write content to a file, replacing existing content.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file to write</p> required <code>content</code> <code>str</code> <p>Content to write to the file</p> required <code>create_dirs</code> <code>bool</code> <p>Whether to create parent directories if they don't exist</p> <code>True</code> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If lacking write permissions</p> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef write_content(\n    file_path: PathLike, content: str, create_dirs: bool = True\n) -&gt; None:\n    \"\"\"\n    Write content to a file, replacing existing content.\n\n    Args:\n        file_path: Path to the file to write\n        content: Content to write to the file\n        create_dirs: Whether to create parent directories if they don't exist\n\n    Raises:\n        PermissionError: If lacking write permissions\n    \"\"\"\n    path = Path(file_path)\n    try:\n        if create_dirs:\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n\n        console.print(f\"[green]Wrote content to file:[/green] {path}\")\n    except PermissionError:\n        console.print(f\"[red]Permission denied writing file:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error writing file {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.append_content","title":"<code>append_content(file_path, content, create_dirs=True)</code>  <code>staticmethod</code>","text":"<p>Append content to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file to append to</p> required <code>content</code> <code>str</code> <p>Content to append to the file</p> required <code>create_dirs</code> <code>bool</code> <p>Whether to create parent directories if they don't exist</p> <code>True</code> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef append_content(\n    file_path: PathLike, content: str, create_dirs: bool = True\n) -&gt; None:\n    \"\"\"\n    Append content to a file.\n\n    Args:\n        file_path: Path to the file to append to\n        content: Content to append to the file\n        create_dirs: Whether to create parent directories if they don't exist\n    \"\"\"\n    path = Path(file_path)\n    try:\n        if create_dirs:\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(path, \"a\", encoding=\"utf-8\") as f:\n            f.write(content)\n\n        console.print(f\"[green]Appended content to file:[/green] {path}\")\n    except PermissionError:\n        console.print(f\"[red]Permission denied writing file:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error writing file {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.write_line","title":"<code>write_line(file_path, line, create_dirs=True)</code>  <code>staticmethod</code>","text":"<p>Write a line to a file, replacing existing content.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file to write</p> required <code>line</code> <code>str</code> <p>Line to write to the file (newline will be added)</p> required <code>create_dirs</code> <code>bool</code> <p>Whether to create parent directories if they don't exist</p> <code>True</code> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef write_line(file_path: PathLike, line: str, create_dirs: bool = True) -&gt; None:\n    \"\"\"\n    Write a line to a file, replacing existing content.\n\n    Args:\n        file_path: Path to the file to write\n        line: Line to write to the file (newline will be added)\n        create_dirs: Whether to create parent directories if they don't exist\n    \"\"\"\n    content = line if line.endswith(\"\\n\") else line + \"\\n\"\n    FileObject.write_content(file_path, content, create_dirs)\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.append_line","title":"<code>append_line(file_path, line, create_dirs=True)</code>  <code>staticmethod</code>","text":"<p>Append a line to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file to append to</p> required <code>line</code> <code>str</code> <p>Line to append to the file (newline will be added)</p> required <code>create_dirs</code> <code>bool</code> <p>Whether to create parent directories if they don't exist</p> <code>True</code> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef append_line(file_path: PathLike, line: str, create_dirs: bool = True) -&gt; None:\n    \"\"\"\n    Append a line to a file.\n\n    Args:\n        file_path: Path to the file to append to\n        line: Line to append to the file (newline will be added)\n        create_dirs: Whether to create parent directories if they don't exist\n    \"\"\"\n    content = line if line.endswith(\"\\n\") else line + \"\\n\"\n    FileObject.append_content(file_path, content, create_dirs)\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.add_heading","title":"<code>add_heading(file_path, title, level=1, create_dirs=True)</code>  <code>staticmethod</code>","text":"<p>Append a markdown-style heading to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file to append to</p> required <code>title</code> <code>str</code> <p>Heading text</p> required <code>level</code> <code>int</code> <p>Heading level (1-6)</p> <code>1</code> <code>create_dirs</code> <code>bool</code> <p>Whether to create parent directories if they don't exist</p> <code>True</code> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef add_heading(\n    file_path: PathLike, title: str, level: int = 1, create_dirs: bool = True\n) -&gt; None:\n    \"\"\"\n    Append a markdown-style heading to a file.\n\n    Args:\n        file_path: Path to the file to append to\n        title: Heading text\n        level: Heading level (1-6)\n        create_dirs: Whether to create parent directories if they don't exist\n    \"\"\"\n    if not 1 &lt;= level &lt;= 6:\n        raise ValueError(\"Heading level must be between 1 and 6\")\n\n    heading = \"#\" * level + \" \" + title + \"\\n\"\n    FileObject.append_content(file_path, heading, create_dirs)\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.create_file","title":"<code>create_file(file_path, create_dirs=True)</code>  <code>staticmethod</code>","text":"<p>Create an empty file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file to create</p> required <code>create_dirs</code> <code>bool</code> <p>Whether to create parent directories if they don't exist</p> <code>True</code> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef create_file(file_path: PathLike, create_dirs: bool = True) -&gt; None:\n    \"\"\"\n    Create an empty file.\n\n    Args:\n        file_path: Path to the file to create\n        create_dirs: Whether to create parent directories if they don't exist\n    \"\"\"\n    path = Path(file_path)\n    try:\n        if create_dirs:\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n        path.touch()\n        console.print(f\"[green]Created file:[/green] {path}\")\n    except PermissionError:\n        console.print(f\"[red]Permission denied creating file:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error creating file {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.file_exists","title":"<code>file_exists(file_path)</code>  <code>staticmethod</code>","text":"<p>Check if a file exists.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if file exists and is a file, False otherwise</p> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef file_exists(file_path: PathLike) -&gt; bool:\n    \"\"\"\n    Check if a file exists.\n\n    Args:\n        file_path: Path to check\n\n    Returns:\n        True if file exists and is a file, False otherwise\n    \"\"\"\n    path = Path(file_path)\n    return path.exists() and path.is_file()\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.get_file_size","title":"<code>get_file_size(file_path)</code>  <code>staticmethod</code>","text":"<p>Get the size of a file in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>int</code> <p>File size in bytes</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef get_file_size(file_path: PathLike) -&gt; int:\n    \"\"\"\n    Get the size of a file in bytes.\n\n    Args:\n        file_path: Path to the file\n\n    Returns:\n        File size in bytes\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n    \"\"\"\n    path = Path(file_path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n    return path.stat().st_size\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.copy_file","title":"<code>copy_file(source_path, target_path, create_dirs=True)</code>  <code>staticmethod</code>","text":"<p>Copy a file from source to target.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>PathLike</code> <p>Path to the source file</p> required <code>target_path</code> <code>PathLike</code> <p>Path to the target file</p> required <code>create_dirs</code> <code>bool</code> <p>Whether to create target parent directories if they don't exist</p> <code>True</code> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef copy_file(\n    source_path: PathLike, target_path: PathLike, create_dirs: bool = True\n) -&gt; None:\n    \"\"\"\n    Copy a file from source to target.\n\n    Args:\n        source_path: Path to the source file\n        target_path: Path to the target file\n        create_dirs: Whether to create target parent directories if they don't exist\n    \"\"\"\n\n    source = Path(source_path)\n    target = Path(target_path)\n\n    if not source.exists():\n        raise FileNotFoundError(f\"Source file not found: {source}\")\n\n    try:\n        if create_dirs:\n            target.parent.mkdir(parents=True, exist_ok=True)\n\n        shutil.copy2(source, target)\n        console.print(f\"[green]Copied file:[/green] {source} \u2192 {target}\")\n    except PermissionError:\n        console.print(\n            f\"[red]Permission denied copying file:[/red] {source} \u2192 {target}\"\n        )\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error copying file {source} \u2192 {target}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/file-object/#hands_scaphoid.objects.FileObject.FileObject.delete_file","title":"<code>delete_file(file_path)</code>  <code>staticmethod</code>","text":"<p>Delete a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>Path to the file to delete</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>PermissionError</code> <p>If lacking delete permissions</p> Source code in <code>src/hands_scaphoid/objects/FileObject.py</code> <pre><code>@staticmethod\ndef delete_file(file_path: PathLike) -&gt; None:\n    \"\"\"\n    Delete a file.\n\n    Args:\n        file_path: Path to the file to delete\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        PermissionError: If lacking delete permissions\n    \"\"\"\n    path = Path(file_path)\n    try:\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        path.unlink()\n        console.print(f\"[green]Deleted file:[/green] {path}\")\n    except PermissionError:\n        console.print(f\"[red]Permission denied deleting file:[/red] {path}\")\n        raise\n    except Exception as e:\n        console.print(f\"[red]Error deleting file {path}:[/red] {e}\")\n        raise\n</code></pre>"},{"location":"api/objects/item-core/","title":"ItemCore API Reference","text":""},{"location":"api/objects/item-core/#api-documentation","title":"API documentation","text":""},{"location":"api/objects/item-core/#hands_scaphoid.objects.ItemCore","title":"<code>hands_scaphoid.objects.ItemCore</code>","text":"<p>ItemCore module for hands-scaphoid package.</p> <p>This module provides the ItemCore class for pure item operations. ---yaml File:     name: ItemCore.py     uuid: 268f89e1-abfc-4376-9e19-f6e78372e289     date: 2025-10-03</p> Description <p>Pure file operations class - no context management</p> Project <p>name: hands_scaphoid uuid: 2945ba3b-2d66-4dff-b898-672c386f03f4 url: https://github.com/42sol-eu/hands_scaphoid</p> <p>Authors: [\"Andreas H\u00e4berle\"]</p>"},{"location":"api/objects/item-core/#hands_scaphoid.objects.ItemCore-classes","title":"Classes","text":""},{"location":"api/objects/item-core/#hands_scaphoid.objects.ItemCore.ItemCore","title":"<code>ItemCore</code>","text":"Source code in <code>src/hands_scaphoid/objects/ItemCore.py</code> <pre><code>class ItemCore:\n    def __init__(self, name: str, value: str | int, \n                 item_type: str | ItemType = ItemType.ITEM,\n                 project: Any = None):\n        self._name = name\n        self._value = value if isinstance(value, int) else value\n        self._item_type = item_type\n        if is_instance(project, str):\n            project = ItemCore(name=project, value=os.getenv(project, \"\"), item_type=ItemType.PROJECT)\n        self._project = project\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def value(self) -&gt; str | int:\n        return self._value\n\n    @value.setter\n    def value(self, new_value: str):\n        self._value = new_value\n\n    @property\n    def item_type(self) -&gt; ItemType:\n        return self._item_type\n\n    @property\n    def project(self) -&gt; 'ItemCore':\n        \"\"\"get project as object\"\"\"\n        return self._project\n\n    @property\n    def project_as_str(self) -&gt; str:\n        \"\"\"get project as string\"\"\"\n        return str(self._project) if self._project.value is None else self._project.value()\n\n    @project.setter\n    def project(self, new_project: Any):\n        if is_instance(new_project, str):\n            new_project = ItemCore(name=new_project, value=os.getenv(new_project, \"\"), item_type=ItemType.PROJECT)\n        self._project = new_project\n\n    def __repr__(self) -&gt; str:\n        return f\"ItemCore(name={self._name}, value={self._value}, item_type={self._item_type.name})\"\n\n    def __str__(self) -&gt; str:\n        return f'{self._name}=\"{self._value}\"'\n\n    def to_dict(self) -&gt; dict:\n        return {\n            \"name\": self._name,\n            \"value\": self._value,\n            \"item_type\": self._item_type,\n            \"project\": self._project if self._project else None\n        }\n        # MAYBE: return project as sub dict (using a parameter in to_dict)\n\n    def to_json(self) -&gt; str:\n        \"\"\"return as JSON\"\"\"\n        return json.dumps(self.to_dict())\n\n    def to_yaml(self) -&gt; str:\n        return yaml.safe_dump(self.to_dict())\n\n    def to_toml(self) -&gt; str:\n        \"\"\"return as TOML\"\"\"\n        # Manual TOML formatting\n        data = self.to_dict()\n        toml_lines = []\n        for key, value in data.items():\n            if value is None:\n                toml_lines.append(f'{key} = \"\"')\n            elif isinstance(value, str):\n                toml_lines.append(f'{key} = \"{value}\"')\n            elif isinstance(value, (int, float)):\n                toml_lines.append(f'{key} = {value}')\n            else:\n                toml_lines.append(f'{key} = \"{str(value)}\"')\n        return '\\n'.join(toml_lines) + '\\n'\n\n    def to_env_var(self) -&gt; str:\n        return f\"{self._name}={self._value}\"\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        return cls(\n            name=data.get(\"name\", \"\"),\n            value=data.get(\"value\", \"\"),\n            item_type=ItemType(data.get(\"item_type\", ItemType.ITEM)),\n            project=data.get(\"project\"),\n        )\n\n    @classmethod\n    def from_json(cls, json_str: str):\n        data = json.loads(json_str)\n        return cls.from_dict(data)\n\n    @classmethod\n    def from_yaml(cls, yaml_str: str):\n        data = yaml.safe_load(yaml_str)\n        return cls.from_dict(data)\n\n    @classmethod\n    def from_env_var(cls, env_var: str):\n        value = os.getenv(env_var, \"\")\n        return cls(name=env_var, value=value, item_type=ItemType.VARIABLE)\n</code></pre>"},{"location":"api/objects/item-core/#hands_scaphoid.objects.ItemCore.ItemCore-attributes","title":"Attributes","text":""},{"location":"api/objects/item-core/#hands_scaphoid.objects.ItemCore.ItemCore.project","title":"<code>project</code>  <code>property</code> <code>writable</code>","text":"<p>get project as object</p>"},{"location":"api/objects/item-core/#hands_scaphoid.objects.ItemCore.ItemCore.project_as_str","title":"<code>project_as_str</code>  <code>property</code>","text":"<p>get project as string</p>"},{"location":"api/objects/item-core/#hands_scaphoid.objects.ItemCore.ItemCore-functions","title":"Functions","text":""},{"location":"api/objects/item-core/#hands_scaphoid.objects.ItemCore.ItemCore.to_json","title":"<code>to_json()</code>","text":"<p>return as JSON</p> Source code in <code>src/hands_scaphoid/objects/ItemCore.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"return as JSON\"\"\"\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"api/objects/item-core/#hands_scaphoid.objects.ItemCore.ItemCore.to_toml","title":"<code>to_toml()</code>","text":"<p>return as TOML</p> Source code in <code>src/hands_scaphoid/objects/ItemCore.py</code> <pre><code>def to_toml(self) -&gt; str:\n    \"\"\"return as TOML\"\"\"\n    # Manual TOML formatting\n    data = self.to_dict()\n    toml_lines = []\n    for key, value in data.items():\n        if value is None:\n            toml_lines.append(f'{key} = \"\"')\n        elif isinstance(value, str):\n            toml_lines.append(f'{key} = \"{value}\"')\n        elif isinstance(value, (int, float)):\n            toml_lines.append(f'{key} = {value}')\n        else:\n            toml_lines.append(f'{key} = \"{str(value)}\"')\n    return '\\n'.join(toml_lines) + '\\n'\n</code></pre>"},{"location":"api/objects/link-item/","title":"Link Object API Reference","text":""},{"location":"api/objects/link-item/#api-documentation","title":"API documentation","text":""},{"location":"api/objects/link-item/#hands_scaphoid.objects.LinkObject","title":"<code>hands_scaphoid.objects.LinkObject</code>","text":""},{"location":"api/objects/link-item/#hands_scaphoid.objects.LinkObject-classes","title":"Classes","text":""},{"location":"api/objects/object-item/","title":"ObjectItem API Reference","text":""},{"location":"api/objects/object-item/#api-documentation","title":"API Documentation","text":""},{"location":"api/objects/object-item/#hands_scaphoid.objects.ObjectItem","title":"<code>hands_scaphoid.objects.ObjectItem</code>","text":""},{"location":"api/objects/object-item/#hands_scaphoid.objects.ObjectItem-classes","title":"Classes","text":""},{"location":"api/objects/object-item/#hands_scaphoid.objects.ObjectItem.ObjectItem","title":"<code>ObjectItem</code>","text":"<p>               Bases: <code>ItemCore</code></p> <p>Represents an object in the shell context.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the object.</p> <code>path</code> <code>str</code> <p>The path of the object in the filesystem.</p> Source code in <code>src/hands_scaphoid/objects/ObjectItem.py</code> <pre><code>class ObjectItem(ItemCore):\n    \"\"\"\n    Represents an object in the shell context.\n\n    Attributes:\n        name (str): The name of the object.\n        path (str): The path of the object in the filesystem.\n    \"\"\"\n\n    def __init__(self, name: str, path: str):\n        super().__init__(name, path, item_type=ItemType.OBJECT)\n\n    def __repr__(self):\n        return f\"ObjectItem(name={self.name}, path={self.value})\"\n</code></pre>"},{"location":"api/objects/path-item/","title":"PathVariable API Reference","text":""},{"location":"api/objects/path-item/#api-documentation","title":"API documentation","text":""},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable","title":"<code>hands_scaphoid.objects.PathVariable</code>","text":"<p>PathVariable module for hands-scaphoid package.</p> <p>This module provides the PathVariable class with comprehensive path validation. ---yaml File:     name: PathVariable.py     uuid: 1ab01ca2-84c3-454a-9589-5ba028a0c2ce     date: 2025-10-03</p> Description <p>Path variable class with ValidationMixin integration for robust path validation</p> Project <p>name: hands_scaphoid uuid: 2945ba3b-2d66-4dff-b898-672c386f03f4 url: https://github.com/42sol-eu/hands_scaphoid</p> <p>Authors: [\"Andreas Felix H\u00e4berle felix@42sol.eu\"]</p> <p>Abbreviations: - OS[system]: Operating System</p>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable-classes","title":"Classes","text":""},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable","title":"<code>PathVariable</code>","text":"<p>               Bases: <code>ValidationMixin</code>, <code>VariableItem</code></p> <p>A variable that contains a path with comprehensive validation.</p> <p>Combines VariableItem functionality with ValidationMixin to provide: - Path-specific validation rules - Cross-platform path compatibility checking - Strict mode for enhanced validation - Built-in rules for common path issues</p> Source code in <code>src/hands_scaphoid/objects/PathVariable.py</code> <pre><code>class PathVariable(ValidationMixin, VariableItem):\n    \"\"\"\n    A variable that contains a path with comprehensive validation.\n\n    Combines VariableItem functionality with ValidationMixin to provide:\n    - Path-specific validation rules\n    - Cross-platform path compatibility checking\n    - Strict mode for enhanced validation\n    - Built-in rules for common path issues\n    \"\"\"\n\n    def __init__(self, name: str, value: str, strict_mode: bool = False, cross_platform: bool = False):\n        # Initialize ValidationMixin first\n        ValidationMixin.__init__(self, strict_mode=strict_mode, cross_platform=cross_platform)\n\n        # Initialize VariableItem (which calls ItemCore)\n        VariableItem.__init__(self, name=name, value=\"\")  # Don't set value yet to avoid validation before setup\n\n        # Set specific attributes\n        self._item_type = ItemType.PATH\n        self._valid = None\n        self._exists = None\n\n        # Add path-specific validation rules\n        self.add_path_rules()\n\n        # Now set the value (triggers validation)\n        self.value = value\n\n    @property\n    def value(self) -&gt; str:\n        \"\"\"Get the path value.\"\"\"\n        return self._value\n\n    @value.setter\n    def value(self, new_value: str):\n        \"\"\"\n        Set the path value and perform validation.\n\n        Args:\n            new_value: The new path value to set\n        \"\"\"\n        self._value = new_value\n        self._exists = os.path.exists(new_value) if new_value else False\n\n        # Perform validation and store result\n        if self.validation_enabled:\n            is_valid, violations = self.validate()\n            self._valid = is_valid\n            self._last_violations = violations\n        else:\n            self._valid = True\n            self._last_violations = []\n\n    @property\n    def valid(self) -&gt; bool:\n        \"\"\"Check if the path passes validation rules.\"\"\"\n        if self._valid is None and self.validation_enabled:\n            self._valid, self._last_violations = self.validate()\n        return self._valid if self._valid is not None else True\n\n    @property\n    def not_valid(self) -&gt; bool:\n        \"\"\"Check if the path does not pass validation rules.\"\"\"\n        return not self.valid\n\n    @property\n    def invalid(self) -&gt; bool:\n        \"\"\"Check if the path does not pass validation rules.\"\"\"\n        return not self.valid\n\n    @property\n    def exists(self) -&gt; bool:\n        \"\"\"Check if the path exists on the filesystem.\"\"\"\n        if self._exists is None:\n            self._exists = os.path.exists(self._value) if self._value else False\n        return self._exists\n\n    @property\n    def not_exists(self) -&gt; bool:\n        \"\"\"Check if the path does not exist on the filesystem.\"\"\"\n        return not self.exists\n\n    @property  \n    def last_violations(self) -&gt; List[ValidationViolation]:\n        \"\"\"Get violations from the last validation run.\"\"\"\n        return getattr(self, '_last_violations', [])\n\n    def get_validation_summary(self) -&gt; dict:\n        \"\"\"\n        Get a summary of the current validation status.\n\n        Returns:\n            dict: Summary containing validity, violations, and recommendations\n        \"\"\"\n        is_valid, violations = self.validate() if self.validation_enabled else (True, [])\n\n        return {\n            \"is_valid\": is_valid,\n            \"exists\": self.exists,\n            \"validation_enabled\": self.validation_enabled,\n            \"strict_mode\": self.strict_mode,\n            \"cross_platform\": self.cross_platform,\n            \"violations\": [\n                {\n                    \"rule\": v.rule_name,\n                    \"severity\": v.severity.value,\n                    \"message\": v.message\n                }\n                for v in violations\n            ],\n            \"error_count\": sum(1 for v in violations if v.severity.is_error),\n            \"warning_count\": sum(1 for v in violations if v.severity.is_warning),\n            \"info_count\": sum(1 for v in violations if v.severity.is_info)\n        }\n\n    def __repr__(self):\n        \"\"\"Returns a string representation of the PathVariable.\"\"\"\n        valid_status = \"valid\" if self.valid else \"invalid\"\n        exists_status = \"exists\" if self.exists else \"not exists\"\n        return f\"PathVariable(name={self.name}, value={self.value}, {valid_status}, {exists_status})\"\n\n    @classmethod\n    def is_valid_path(cls, path: str, strict_mode: bool = False, cross_platform: bool = False) -&gt; bool:\n        \"\"\"\n        Check if a given path string is valid according to validation rules.\n\n        Args:\n            path: Path string to validate\n            strict_mode: Enable strict validation\n            cross_platform: Enable cross-platform validation\n\n        Returns:\n            bool: True if path is valid, False otherwise\n        \"\"\"\n        temp_var = cls(\"temp\", path, strict_mode=strict_mode, cross_platform=cross_platform)\n        return temp_var.valid\n\n    @classmethod\n    def does_exist(cls, path: str) -&gt; bool:\n        \"\"\"Check if a given path exists on the filesystem.\"\"\"\n        return os.path.exists(path)\n\n    @classmethod  \n    def get_path_violations(cls, path: str, strict_mode: bool = False, cross_platform: bool = False) -&gt; List[ValidationViolation]:\n        \"\"\"\n        Get validation violations for a path without creating a persistent object.\n\n        Args:\n            path: Path string to validate\n            strict_mode: Enable strict validation  \n            cross_platform: Enable cross-platform validation\n\n        Returns:\n            List[ValidationViolation]: List of violations found\n        \"\"\"\n        temp_var = cls(\"temp\", path, strict_mode=strict_mode, cross_platform=cross_platform)\n        _, violations = temp_var.validate()\n        return violations\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Serialize the PathVariable to a dictionary.\n\n        Returns:\n            dict: Dictionary representation including validation config\n        \"\"\"\n        data = super().to_dict()\n        data.update({\n            \"exists\": self.exists,\n            \"validation_summary\": self.get_validation_summary()\n        })\n        return data\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"PathVariable\":\n        \"\"\"\n        Create PathVariable from dictionary representation.\n\n        Args:\n            data: Dictionary containing PathVariable data\n\n        Returns:\n            PathVariable: Configured instance\n        \"\"\"\n        # Extract PathVariable-specific parameters\n        name = data.get(\"name\", \"\")\n        value = data.get(\"value\", \"\")\n        strict_mode = data.get(\"strict_mode\", False)\n        cross_platform = data.get(\"cross_platform\", False)\n\n        # Create instance\n        obj = cls(name=name, value=value, strict_mode=strict_mode, cross_platform=cross_platform)\n\n        # Apply validation configuration if present\n        if \"validation_enabled\" in data:\n            obj.validation_enabled = data[\"validation_enabled\"]\n\n        # Load any custom validation rules\n        if \"validation_rules\" in data:\n            rules_data = data[\"validation_rules\"]\n            for rule_name, rule_config in rules_data.items():\n                if rule_name not in obj._validation_rules:  # Don't override built-in rules\n                    obj.add_rule(\n                        name=rule_name,\n                        pattern=rule_config.get(\"pattern\", \".*\"),\n                        severity=SeverityType(rule_config.get(\"severity\", \"error\")),\n                        description=rule_config.get(\"description\", \"\"),\n                        inverse=rule_config.get(\"inverse\", False)\n                    )\n\n        # Ensure correct type\n        if not is_instance(obj, PathVariable):\n            raise TypeError(f\"from_dict expected to create 'PathVariable', got '{type(obj)}'\")\n        return obj\n</code></pre>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable-attributes","title":"Attributes","text":""},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.value","title":"<code>value</code>  <code>property</code> <code>writable</code>","text":"<p>Get the path value.</p>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.valid","title":"<code>valid</code>  <code>property</code>","text":"<p>Check if the path passes validation rules.</p>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.not_valid","title":"<code>not_valid</code>  <code>property</code>","text":"<p>Check if the path does not pass validation rules.</p>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.invalid","title":"<code>invalid</code>  <code>property</code>","text":"<p>Check if the path does not pass validation rules.</p>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.exists","title":"<code>exists</code>  <code>property</code>","text":"<p>Check if the path exists on the filesystem.</p>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.not_exists","title":"<code>not_exists</code>  <code>property</code>","text":"<p>Check if the path does not exist on the filesystem.</p>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.last_violations","title":"<code>last_violations</code>  <code>property</code>","text":"<p>Get violations from the last validation run.</p>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable-functions","title":"Functions","text":""},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.get_validation_summary","title":"<code>get_validation_summary()</code>","text":"<p>Get a summary of the current validation status.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Summary containing validity, violations, and recommendations</p> Source code in <code>src/hands_scaphoid/objects/PathVariable.py</code> <pre><code>def get_validation_summary(self) -&gt; dict:\n    \"\"\"\n    Get a summary of the current validation status.\n\n    Returns:\n        dict: Summary containing validity, violations, and recommendations\n    \"\"\"\n    is_valid, violations = self.validate() if self.validation_enabled else (True, [])\n\n    return {\n        \"is_valid\": is_valid,\n        \"exists\": self.exists,\n        \"validation_enabled\": self.validation_enabled,\n        \"strict_mode\": self.strict_mode,\n        \"cross_platform\": self.cross_platform,\n        \"violations\": [\n            {\n                \"rule\": v.rule_name,\n                \"severity\": v.severity.value,\n                \"message\": v.message\n            }\n            for v in violations\n        ],\n        \"error_count\": sum(1 for v in violations if v.severity.is_error),\n        \"warning_count\": sum(1 for v in violations if v.severity.is_warning),\n        \"info_count\": sum(1 for v in violations if v.severity.is_info)\n    }\n</code></pre>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the PathVariable.</p> Source code in <code>src/hands_scaphoid/objects/PathVariable.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns a string representation of the PathVariable.\"\"\"\n    valid_status = \"valid\" if self.valid else \"invalid\"\n    exists_status = \"exists\" if self.exists else \"not exists\"\n    return f\"PathVariable(name={self.name}, value={self.value}, {valid_status}, {exists_status})\"\n</code></pre>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.is_valid_path","title":"<code>is_valid_path(path, strict_mode=False, cross_platform=False)</code>  <code>classmethod</code>","text":"<p>Check if a given path string is valid according to validation rules.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path string to validate</p> required <code>strict_mode</code> <code>bool</code> <p>Enable strict validation</p> <code>False</code> <code>cross_platform</code> <code>bool</code> <p>Enable cross-platform validation</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if path is valid, False otherwise</p> Source code in <code>src/hands_scaphoid/objects/PathVariable.py</code> <pre><code>@classmethod\ndef is_valid_path(cls, path: str, strict_mode: bool = False, cross_platform: bool = False) -&gt; bool:\n    \"\"\"\n    Check if a given path string is valid according to validation rules.\n\n    Args:\n        path: Path string to validate\n        strict_mode: Enable strict validation\n        cross_platform: Enable cross-platform validation\n\n    Returns:\n        bool: True if path is valid, False otherwise\n    \"\"\"\n    temp_var = cls(\"temp\", path, strict_mode=strict_mode, cross_platform=cross_platform)\n    return temp_var.valid\n</code></pre>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.does_exist","title":"<code>does_exist(path)</code>  <code>classmethod</code>","text":"<p>Check if a given path exists on the filesystem.</p> Source code in <code>src/hands_scaphoid/objects/PathVariable.py</code> <pre><code>@classmethod\ndef does_exist(cls, path: str) -&gt; bool:\n    \"\"\"Check if a given path exists on the filesystem.\"\"\"\n    return os.path.exists(path)\n</code></pre>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.get_path_violations","title":"<code>get_path_violations(path, strict_mode=False, cross_platform=False)</code>  <code>classmethod</code>","text":"<p>Get validation violations for a path without creating a persistent object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path string to validate</p> required <code>strict_mode</code> <code>bool</code> <p>Enable strict validation  </p> <code>False</code> <code>cross_platform</code> <code>bool</code> <p>Enable cross-platform validation</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ValidationViolation]</code> <p>List[ValidationViolation]: List of violations found</p> Source code in <code>src/hands_scaphoid/objects/PathVariable.py</code> <pre><code>@classmethod  \ndef get_path_violations(cls, path: str, strict_mode: bool = False, cross_platform: bool = False) -&gt; List[ValidationViolation]:\n    \"\"\"\n    Get validation violations for a path without creating a persistent object.\n\n    Args:\n        path: Path string to validate\n        strict_mode: Enable strict validation  \n        cross_platform: Enable cross-platform validation\n\n    Returns:\n        List[ValidationViolation]: List of violations found\n    \"\"\"\n    temp_var = cls(\"temp\", path, strict_mode=strict_mode, cross_platform=cross_platform)\n    _, violations = temp_var.validate()\n    return violations\n</code></pre>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the PathVariable to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary representation including validation config</p> Source code in <code>src/hands_scaphoid/objects/PathVariable.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Serialize the PathVariable to a dictionary.\n\n    Returns:\n        dict: Dictionary representation including validation config\n    \"\"\"\n    data = super().to_dict()\n    data.update({\n        \"exists\": self.exists,\n        \"validation_summary\": self.get_validation_summary()\n    })\n    return data\n</code></pre>"},{"location":"api/objects/path-item/#hands_scaphoid.objects.PathVariable.PathVariable.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create PathVariable from dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing PathVariable data</p> required <p>Returns:</p> Name Type Description <code>PathVariable</code> <code>PathVariable</code> <p>Configured instance</p> Source code in <code>src/hands_scaphoid/objects/PathVariable.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"PathVariable\":\n    \"\"\"\n    Create PathVariable from dictionary representation.\n\n    Args:\n        data: Dictionary containing PathVariable data\n\n    Returns:\n        PathVariable: Configured instance\n    \"\"\"\n    # Extract PathVariable-specific parameters\n    name = data.get(\"name\", \"\")\n    value = data.get(\"value\", \"\")\n    strict_mode = data.get(\"strict_mode\", False)\n    cross_platform = data.get(\"cross_platform\", False)\n\n    # Create instance\n    obj = cls(name=name, value=value, strict_mode=strict_mode, cross_platform=cross_platform)\n\n    # Apply validation configuration if present\n    if \"validation_enabled\" in data:\n        obj.validation_enabled = data[\"validation_enabled\"]\n\n    # Load any custom validation rules\n    if \"validation_rules\" in data:\n        rules_data = data[\"validation_rules\"]\n        for rule_name, rule_config in rules_data.items():\n            if rule_name not in obj._validation_rules:  # Don't override built-in rules\n                obj.add_rule(\n                    name=rule_name,\n                    pattern=rule_config.get(\"pattern\", \".*\"),\n                    severity=SeverityType(rule_config.get(\"severity\", \"error\")),\n                    description=rule_config.get(\"description\", \"\"),\n                    inverse=rule_config.get(\"inverse\", False)\n                )\n\n    # Ensure correct type\n    if not is_instance(obj, PathVariable):\n        raise TypeError(f\"from_dict expected to create 'PathVariable', got '{type(obj)}'\")\n    return obj\n</code></pre>"},{"location":"api/objects/power-shell/","title":"PoweerShell API Reference","text":"<p>TODO: Add a note about WSL and Git Bash on Windows.</p>"},{"location":"api/objects/power-shell/#api-documentation","title":"API Documentation","text":""},{"location":"api/objects/power-shell/#hands_scaphoid.objects.PowerShell","title":"<code>hands_scaphoid.objects.PowerShell</code>","text":"<p>               Bases: <code>ShellExecutable</code></p> <p>A PowerShell-compatible shell executor that translates Unix commands to PowerShell.</p> <p>This class automatically translates common Unix commands to their PowerShell equivalents when running on Windows systems.</p> Source code in <code>src/hands_scaphoid/objects/shells/PowerShell.py</code> <pre><code>class PowerShell(Shell):\n    \"\"\"\n    A PowerShell-compatible shell executor that translates Unix commands to PowerShell.\n\n    This class automatically translates common Unix commands to their PowerShell\n    equivalents when running on Windows systems.\n    \"\"\"\n\n    # Command translation mapping from Unix to PowerShell\n    COMMAND_TRANSLATIONS = {\n        \"ls\": \"Get-ChildItem\",\n        \"dir\": \"Get-ChildItem\",\n        \"cat\": \"Get-Content\",\n        \"cp\": \"Copy-Item\",\n        \"copy\": \"Copy-Item\",\n        \"mv\": \"Move-Item\",\n        \"move\": \"Move-Item\",\n        \"rm\": \"Remove-Item\",\n        \"del\": \"Remove-Item\",\n        \"mkdir\": \"New-Item -ItemType Directory\",\n        \"rmdir\": \"Remove-Item -Recurse\",\n        \"pwd\": \"Get-Location\",\n        \"cd\": \"Set-Location\",\n        \"echo\": \"Write-Output\",\n        \"grep\": \"Select-String\",\n        \"find\": \"Get-ChildItem -Recurse | Where-Object\",\n        \"ps\": \"Get-Process\",\n        \"kill\": \"Stop-Process\",\n        \"which\": \"Get-Command\",\n        \"whereis\": \"Get-Command\",\n        \"curl\": \"Invoke-WebRequest\",\n        \"wget\": \"Invoke-WebRequest\",\n        \"head\": \"Get-Content | Select-Object -First\",\n        \"tail\": \"Get-Content | Select-Object -Last\",\n        \"wc\": \"Measure-Object\",\n        \"sort\": \"Sort-Object\",\n        \"uniq\": \"Sort-Object -Unique\",\n        \"cut\": \"Select-Object\",\n        \"awk\": \"ForEach-Object\",\n        \"sed\": \"ForEach-Object\",\n        \"env\": \"Get-ChildItem Env:\",\n        \"export\": \"Set-Variable\",\n        \"chmod\": \"Set-ItemProperty\",\n        \"chown\": \"Set-Acl\",\n        \"df\": \"Get-WmiObject -Class Win32_LogicalDisk\",\n        \"du\": \"Get-ChildItem -Recurse | Measure-Object -Property Length -Sum\",\n        \"mount\": \"Get-WmiObject -Class Win32_LogicalDisk\",\n        \"umount\": 'Write-Warning \"umount not available in PowerShell\"',\n        \"top\": \"Get-Process | Sort-Object CPU -Descending | Select-Object -First 10\",\n        \"htop\": \"Get-Process | Sort-Object CPU -Descending | Select-Object -First 10\",\n        \"free\": \"Get-WmiObject -Class Win32_OperatingSystem | Select-Object TotalVisibleMemorySize, FreePhysicalMemory\",\n        \"uptime\": \"Get-WmiObject -Class Win32_OperatingSystem | Select-Object LastBootUpTime\",\n        \"whoami\": \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\",\n        \"id\": \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\",\n        \"hostname\": \"$env:COMPUTERNAME\",\n        \"uname\": \"Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion\",\n    }\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize PowerShell with PowerShell as the default shell.\"\"\"\n        super().__init__(*args, **kwargs)\n        self.shell_executable = \"powershell.exe\"\n        if platform.system() == \"Windows\":\n            # Try to use PowerShell Core (pwsh) if available, fallback to Windows PowerShell\n            try:\n                subprocess.run([\"pwsh\", \"-Version\"], capture_output=True, check=True)\n                self.shell_executable = \"pwsh.exe\"\n            except (subprocess.CalledProcessError, FileNotFoundError):\n                self.shell_executable = \"powershell.exe\"\n\n    def _translate_command(self, command_with_args: str) -&gt; str:\n        \"\"\"\n        Translate Unix commands to PowerShell equivalents.\n\n        Args:\n            command_with_args: The original command with arguments\n\n        Returns:\n            Translated PowerShell command\n        \"\"\"\n        if isinstance(command_with_args, str):\n            parts = command_with_args.strip().split()\n        else:\n            parts = command_with_args\n\n        if not parts:\n            return command_with_args\n\n        command = parts[0]\n        args = parts[1:] if len(parts) &gt; 1 else []\n\n        # Check if we have a translation for this command\n        if command in self.COMMAND_TRANSLATIONS:\n            translated_cmd = self.COMMAND_TRANSLATIONS[command]\n\n            # Handle special cases for argument translation\n            if command == \"ls\" and args:\n                # ls -la -&gt; Get-ChildItem -Force -Name\n                ps_args = []\n                for arg in args:\n                    if arg.startswith(\"-\"):\n                        if \"a\" in arg:\n                            ps_args.append(\"-Force\")\n                        if \"l\" in arg:\n                            ps_args.append(\"-Detailed\")\n                        if \"h\" in arg:\n                            ps_args.append(\"-Humanized\")\n                    else:\n                        ps_args.append(f'\"{arg}\"')\n                return f\"{translated_cmd} {' '.join(ps_args)}\"\n\n            elif command == \"cp\" and len(args) &gt;= 2:\n                # cp source dest -&gt; Copy-Item source dest\n                source = f'\"{args[0]}\"' if not args[0].startswith('\"') else args[0]\n                dest = f'\"{args[1]}\"' if not args[1].startswith('\"') else args[1]\n                extra_args = args[2:] if len(args) &gt; 2 else []\n                ps_args = [source, dest]\n                if \"-r\" in \" \".join(args) or \"-R\" in \" \".join(args):\n                    ps_args.append(\"-Recurse\")\n                if \"-f\" in \" \".join(args):\n                    ps_args.append(\"-Force\")\n                ps_args.extend(extra_args)\n                return f\"{translated_cmd} {' '.join(ps_args)}\"\n\n            elif command == \"rm\" and args:\n                # rm -rf file -&gt; Remove-Item file -Recurse -Force\n                ps_args = []\n                files = []\n                for arg in args:\n                    if arg.startswith(\"-\"):\n                        if \"r\" in arg or \"R\" in arg:\n                            ps_args.append(\"-Recurse\")\n                        if \"f\" in arg:\n                            ps_args.append(\"-Force\")\n                    else:\n                        files.append(f'\"{arg}\"' if not arg.startswith('\"') else arg)\n                return f\"{translated_cmd} {' '.join(files)} {' '.join(ps_args)}\"\n\n            else:\n                # Default: just append arguments\n                if args:\n                    return f\"{translated_cmd} {' '.join(args)}\"\n                else:\n                    return translated_cmd\n\n        # No translation available, return original command\n        return command_with_args\n\n    def run(\n        self, command_with_args: str, **kwargs: Dict\n    ) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Execute a command, translating Unix commands to PowerShell if needed.\n\n        Args:\n            command_with_args: The command to execute\n            **kwargs: Additional arguments passed to parent run method\n\n        Returns:\n            CompletedProcess object with execution results\n        \"\"\"\n        if platform.system() == \"Windows\":\n            # Translate the command for Windows PowerShell\n            translated_command = self._translate_command(command_with_args)\n\n            # If the command was translated, we need to run it through PowerShell\n            if translated_command != command_with_args:\n                # Run the translated command through PowerShell\n                ps_command = f'{self.shell_executable} -Command \"{translated_command}\"'\n                return super().run(ps_command, **kwargs)\n\n        # Run the original command\n        return super().run(command_with_args, **kwargs)\n</code></pre>"},{"location":"api/objects/power-shell/#hands_scaphoid.objects.PowerShell-functions","title":"Functions","text":""},{"location":"api/objects/power-shell/#hands_scaphoid.objects.PowerShell.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize PowerShell with PowerShell as the default shell.</p> Source code in <code>src/hands_scaphoid/objects/shells/PowerShell.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize PowerShell with PowerShell as the default shell.\"\"\"\n    super().__init__(*args, **kwargs)\n    self.shell_executable = \"powershell.exe\"\n    if platform.system() == \"Windows\":\n        # Try to use PowerShell Core (pwsh) if available, fallback to Windows PowerShell\n        try:\n            subprocess.run([\"pwsh\", \"-Version\"], capture_output=True, check=True)\n            self.shell_executable = \"pwsh.exe\"\n        except (subprocess.CalledProcessError, FileNotFoundError):\n            self.shell_executable = \"powershell.exe\"\n</code></pre>"},{"location":"api/objects/power-shell/#hands_scaphoid.objects.PowerShell.run","title":"<code>run(command_with_args, **kwargs)</code>","text":"<p>Execute a command, translating Unix commands to PowerShell if needed.</p> <p>Parameters:</p> Name Type Description Default <code>command_with_args</code> <code>str</code> <p>The command to execute</p> required <code>**kwargs</code> <code>Dict</code> <p>Additional arguments passed to parent run method</p> <code>{}</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>CompletedProcess object with execution results</p> Source code in <code>src/hands_scaphoid/objects/shells/PowerShell.py</code> <pre><code>def run(\n    self, command_with_args: str, **kwargs: Dict\n) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Execute a command, translating Unix commands to PowerShell if needed.\n\n    Args:\n        command_with_args: The command to execute\n        **kwargs: Additional arguments passed to parent run method\n\n    Returns:\n        CompletedProcess object with execution results\n    \"\"\"\n    if platform.system() == \"Windows\":\n        # Translate the command for Windows PowerShell\n        translated_command = self._translate_command(command_with_args)\n\n        # If the command was translated, we need to run it through PowerShell\n        if translated_command != command_with_args:\n            # Run the translated command through PowerShell\n            ps_command = f'{self.shell_executable} -Command \"{translated_command}\"'\n            return super().run(ps_command, **kwargs)\n\n    # Run the original command\n    return super().run(command_with_args, **kwargs)\n</code></pre>"},{"location":"api/objects/script-file/","title":"Script File API Reference","text":""},{"location":"api/objects/script-file/#api-documentation","title":"API documentation","text":""},{"location":"api/objects/script-file/#hands_scaphoid.objects.files.ScriptFile","title":"<code>hands_scaphoid.objects.files.ScriptFile</code>","text":""},{"location":"api/objects/script-file/#hands_scaphoid.objects.files.ScriptFile--windows-shells-powershell-and-wslshell","title":"Windows shells (PowerShell and WslShell)","text":"<p>file:     name:        WindowsShells.py     uuid:        1b38546a-16d2-4be6-b807-4d0bbe4f9815 description:     implementing ShellExecutables for Windows authors:         felix@42sol.eu project: project:     name:        hands_scaphoid     uuid:        2945ba3b-2d66-4dff-b898-672c386f03f4     url:         https://github.com/42sol-eu/hands_scaphoid</p>"},{"location":"api/objects/script-file/#hands_scaphoid.objects.files.ScriptFile-classes","title":"Classes","text":""},{"location":"api/objects/script-file/#hands_scaphoid.objects.files.ScriptFile.ScriptFile","title":"<code>ScriptFile</code>","text":"<p>               Bases: <code>FileObject</code></p> <p>Core class for executable objects.</p> Source code in <code>src/hands_scaphoid/objects/files/ScriptFile.py</code> <pre><code>class ScriptFile(FileObject):    \n    \"\"\"\n    Core class for executable objects.\n    \"\"\"\n\n    def __init__(self, name: str, path: PathLike):\n        super().__init__(name, path)\n        self.name = name\n        self.path = path\n\n    def execute(self, *args, **kwargs):\n        \"\"\"\n        Execute the core executable with given arguments.\n        \"\"\"\n        print(\n            f\"Executing {self.name} at {self.path} with args: {args} and kwargs: {kwargs}\"\n        )\n        # Here you would add the actual execution logic, e.g., using subprocess\n        # For demonstration, we'll just return a success message\n        return f\"{self.name} executed successfully.\"\n</code></pre>"},{"location":"api/objects/script-file/#hands_scaphoid.objects.files.ScriptFile.ScriptFile-functions","title":"Functions","text":""},{"location":"api/objects/script-file/#hands_scaphoid.objects.files.ScriptFile.ScriptFile.execute","title":"<code>execute(*args, **kwargs)</code>","text":"<p>Execute the core executable with given arguments.</p> Source code in <code>src/hands_scaphoid/objects/files/ScriptFile.py</code> <pre><code>def execute(self, *args, **kwargs):\n    \"\"\"\n    Execute the core executable with given arguments.\n    \"\"\"\n    print(\n        f\"Executing {self.name} at {self.path} with args: {args} and kwargs: {kwargs}\"\n    )\n    # Here you would add the actual execution logic, e.g., using subprocess\n    # For demonstration, we'll just return a success message\n    return f\"{self.name} executed successfully.\"\n</code></pre>"},{"location":"api/objects/shell-executable/","title":"Shell Executable API Reference","text":"<p>The <code>Shell</code> class is the core component of hands-scaphoid, providing a secure context manager for shell command execution.</p> <p>Context Manager</p> <p>The Shell class implements the context manager protocol, ensuring proper cleanup of resources.</p> Basic UsageWith Configuration <pre><code>from hands_scaphoid import Shell\n\nwith Shell() as shell:\n    result = shell.run(\"echo 'Hello World'\")\n    print(result.stdout)\n</code></pre> <pre><code>from hands_scaphoid import Shell\n\nwith Shell(shell=\"bash\", timeout=30) as shell:\n    result = shell.run(\"ls -la\")\n    if result.success:\n        print(result.stdout)\n    else:\n        print(f\"Error: {result.stderr}\")\n</code></pre> <p>Platform Compatibility</p> <p>Different shell types have varying levels of support across platforms. See the Windows Shells documentation for platform-specific details.</p>"},{"location":"api/objects/shell-executable/#api-documentation","title":"API documentation","text":""},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable","title":"<code>hands_scaphoid.objects.ShellExecutable</code>","text":"<p>Shell execution module with security and environment management.</p> File <p>name: Shell.py uuid: 52319d84-4784-4df7-8752-64967f3716f8 date: 2025-09-12</p> Description <p>Provides secure shell command execution with allowlisting, environment management, and Docker integration capabilities.</p> Project <p>name: hands/palm/trapezium uuid: 2945ba3b-2d66-4dff-b898-672c386f03f4</p> <p>Authors: [\"Andreas H\u00e4berle\"] Projects: [\"hands/palm/trapezium\"]</p>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable-classes","title":"Classes","text":""},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable","title":"<code>ShellExecutable</code>","text":"<p>               Bases: <code>ExecutableFile</code></p> <p>A secure shell command executor with environment management.</p> <p>This class provides a secure way to execute shell commands with features like: - Command allowlisting for security - Environment variable management - Docker container command execution - Working directory management</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>class ShellExecutable(ExecutableFile):\n    \"\"\"\n    A secure shell command executor with environment management.\n\n    This class provides a secure way to execute shell commands with features like:\n    - Command allowlisting for security\n    - Environment variable management\n    - Docker container command execution\n    - Working directory management\n    \"\"\"\n\n    def __init__(\n        self,\n        cwd: Optional[Union[str, PathLike]] = None,\n        env: Optional[Dict[str, str]] = None,\n        env_file: str = \"~/.env\",\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Shell instance.\n\n        Args:\n            cwd: Working directory for command execution. Defaults to current directory.\n            env: Environment variables dictionary. Defaults to copy of os.environ.\n            env_file: Path to environment file to load variables from.\n\n        Raises:\n            FileNotFoundError: If the specified working directory doesn't exist.\n        \"\"\"\n        super().__init__(name=\"shell\", path=str(cwd or os.getcwd()))\n\n        self.cwd = str(Path(cwd or os.getcwd()).resolve())\n        if not os.path.isdir(self.cwd):\n            raise FileNotFoundError(f\"Working directory does not exist: {self.cwd}\")\n\n        self.env = env or os.environ.copy()\n        self.env_file = os.path.expanduser(env_file)\n        self._load_env_file()\n        self.allow_commands: List[str] = []\n        self.last_result: Optional[subprocess.CompletedProcess] = None\n\n        # define basic commands\n        self.allow_commands.append(\"which\")\n\n    def _load_env_file(self) -&gt; None:\n        \"\"\"Load environment variables from the specified env file.\"\"\"\n        if os.path.exists(self.env_file):\n            try:\n                with open(self.env_file, \"r\", encoding=\"utf-8\") as f:\n                    for line_num, line in enumerate(f, 1):\n                        line = line.strip()\n                        if line and not line.startswith(\"#\") and \"=\" in line:\n                            try:\n                                key, value = line.split(\"=\", 1)\n                                self.env[key.strip()] = value.strip()\n                            except ValueError:\n                                console.print(\n                                    f\"[yellow]Warning: Invalid line {line_num} in {self.env_file}: {line}[/yellow]\"\n                                )\n            except IOError as e:\n                console.print(\n                    f\"[yellow]Warning: Could not read env file {self.env_file}: {e}[/yellow]\"\n                )\n\n    def allow(self, command: Union[str, List[str]]) -&gt; bool:\n        \"\"\"\n        Allow a command to be executed.\n\n        Args:\n            command: The command or lost of commands to allow (first word will be extracted).\n\n        Returns:\n            True if command was successfully allowed, False if command doesn't exist.\n\n        Raises:\n            ValueError: If command is empty or invalid.\n        \"\"\"\n        do_check: bool = True\n\n        if isinstance(command, str):\n            command = [command]\n\n        for cmd in command:\n            if not cmd or not cmd.split(\" \")[0].strip():\n                raise ValueError(\"Command cannot be empty\")\n\n            # check if available\n            if do_check:\n                # Use a different approach for checking command availability\n                # to avoid recursive call to run()\n                try:\n                    if platform.system() == \"Windows\":\n                        # On Windows, try 'where' command instead of 'which'\n                        check_result = subprocess.run(\n                            [\"where\", cmd], capture_output=True, timeout=2, env=self.env\n                        )\n                    else:\n                        # On Unix systems, use 'which'\n                        check_result = subprocess.run(\n                            [\"which\", cmd], capture_output=True, timeout=2, env=self.env\n                        )\n                    add = check_result.returncode == 0\n                except (\n                    subprocess.CalledProcessError,\n                    subprocess.TimeoutExpired,\n                    FileNotFoundError,\n                ):\n                    add = True  # If we can't check, assume it's available\n                    console.print(f\"\u26a0\ufe0f Could not verify availability of command: {cmd}\")\n            else:\n                add = True\n                console.print(f\"\u26a0\ufe0f Skipping availability check for command: {cmd}\")\n\n            if add:\n                # command is available\n                if cmd not in self.allow_commands:\n                    self.allow_commands.append(cmd)\n                else:\n                    pass\n                result = True\n            else:\n                console.print(\n                    f\"\u274c Command not found: {cmd} in {self.env.get('PATH', '')}\"\n                )\n                result = False\n\n        return result\n\n    def run(\n        self,\n        command_with_args: str,\n        timeout: Optional[int] = None,\n        capture_output: bool = True,\n        text: bool = True,\n        check: bool = True,\n    ) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Execute a shell command with security checks.\n\n        Args:\n            command_with_args: The shell command to execute including arguments.\n            timeout: Maximum seconds to wait for command completion.\n            capture_output: Whether to capture stdout and stderr.\n            text: Whether to return output as text (str) or bytes.\n            check: Whether to raise exception on non-zero exit codes.\n\n        Returns:\n            CompletedProcess object with execution results.\n\n        Raises:\n            PermissionError: If the command is not in the allow list.\n            subprocess.CalledProcessError: If check=True and command fails.\n            subprocess.TimeoutExpired: If command times out.\n            ValueError: If command is empty or invalid.\n        \"\"\"\n\n        if isinstance(command_with_args, str):\n            command_parts = command_with_args.strip().split()\n        else:\n            command_parts = command_with_args\n\n        command_name = command_parts[0]\n\n        console.print(f\"[bold]$ {command_with_args}[/bold]\")\n\n        if command_name not in self.allow_commands:\n            raise PermissionError(\n                f\"Command '{command_name}' is not allowed. Use allow() first.\"\n            )\n\n        try:\n            result = subprocess.run(\n                command_parts,\n                cwd=self.cwd,\n                env=self.env,\n                timeout=timeout,\n                capture_output=capture_output,\n                text=text,\n                check=check,\n            )\n\n            if result.stderr and capture_output:\n                console.print(f\"[red]Error: {result.stderr}[/red]\")\n\n            self.last_result = result\n            return result\n\n        except subprocess.CalledProcessError as e:\n            self.last_result = e\n            raise\n        except subprocess.TimeoutExpired as e:\n            console.print(\n                f\"[red]Command timed out after {timeout} seconds: {command_with_args}[/red]\"\n            )\n            raise\n\n    def run_in(\n        self,\n        container_name: str,\n        command_with_args: list[str] | str,\n        timeout: Optional[int] = None,\n        capture_output: bool = True,\n        text: bool = True,\n        check: bool = True,\n    ) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Execute a command inside a Docker container.\n\n        Args:\n            container_name: Name of the Docker container.\n            command_with_args: Command to execute inside the container.\n            timeout: Maximum seconds to wait for command completion.\n            capture_output: Whether to capture stdout and stderr.\n            text: Whether to return output as text (str) or bytes.\n            check: Whether to raise exception on non-zero exit codes.\n\n        Returns:\n            CompletedProcess object with execution results.\n\n        Raises:\n            PermissionError: If docker command is not allowed.\n            subprocess.CalledProcessError: If check=True and command fails.\n            ValueError: If container_name or command is empty.\n        \"\"\"\n\n        command_with_args.insert(0, container_name)\n        command_with_args.insert(0, \"exec\")\n        command_with_args.insert(0, \"docker\")\n\n        return self.run(command_with_args, timeout, capture_output, text, check)\n\n    def cd(self, path: str) -&gt; None:\n        \"\"\"\n        Change the current working directory.\n\n        Args:\n            path: Path to change to (relative or absolute).\n\n        Raises:\n            NotADirectoryError: If the path is not a valid directory.\n            ValueError: If path is empty.\n        \"\"\"\n        if not path or not path.strip():\n            raise ValueError(\"Path cannot be empty\")\n\n        if os.name == \"nt\":\n            new_path = Path(\"C:\") / os.path.abspath(\n                os.path.join(self.cwd, path.replace(\"/\", \"\\\\\"))\n            )\n\n        new_path = os.path.abspath(os.path.join(self.cwd, path))\n\n        if not os.path.isdir(new_path):\n            raise NotADirectoryError(f\"{new_path} is not a valid directory.\")\n\n        self.cwd = new_path\n\n    def get_env_var(self, var_name: str) -&gt; Optional[str]:\n        \"\"\"\n        Get the value of an environment variable.\n\n        Args:\n            var_name: Name of the environment variable.\n\n        Returns:\n            Value of the environment variable or None if not found.\n\n        Raises:\n            ValueError: If var_name is empty.\n        \"\"\"\n        if not var_name or not var_name.strip():\n            raise ValueError(\"Variable name cannot be empty\")\n\n        return self.env.get(var_name)\n\n    def set_env_var(self, var_name: str, value: str) -&gt; None:\n        \"\"\"\n        Set an environment variable.\n\n        Args:\n            var_name: Name of the environment variable.\n            value: Value to set.\n\n        Raises:\n            ValueError: If var_name is empty.\n        \"\"\"\n        if not var_name or not var_name.strip():\n            raise ValueError(\"Variable name cannot be empty\")\n\n        self.env[var_name] = value\n\n    def sleep(self, seconds: Union[int, float]) -&gt; None:\n        \"\"\"\n        Sleep for the specified number of seconds.\n\n        Args:\n            seconds: Number of seconds to sleep.\n\n        Raises:\n            ValueError: If seconds is negative.\n        \"\"\"\n        if seconds &lt; 0:\n            raise ValueError(\"Sleep duration cannot be negative\")\n\n        time.sleep(seconds)\n\n    def depends_on(self, names: Union[str, List[str]]) -&gt; bool:\n        \"\"\"\n        Check if Docker containers are running.\n\n        Args:\n            names: Container name(s) to check.\n\n        Returns:\n            True if all containers are running.\n\n        Raises:\n            SystemExit: If any container is not running.\n            RuntimeError: If docker command fails.\n        \"\"\"\n        if isinstance(names, str):\n            names = [names]\n\n        if not names:\n            raise ValueError(\"Container names cannot be empty\")\n\n        try:\n            # Ensure docker is allowed\n            if \"docker\" not in self.allow_commands:\n                if not self.allow(\"docker\"):\n                    raise RuntimeError(\"Docker command is not available\")\n\n            result = self.run(\"docker ps --format '{{.Names}}'\", check=True)\n            running_containers = [\n                line.strip().replace(\"'\", \"\") for line in result.stdout.splitlines()\n            ]\n\n            for name in names:\n                if name not in running_containers:\n                    console.print(f\"[red]Container {name} is not running![/red]\")\n                    sys.exit(2)\n\n            return True\n\n        except subprocess.CalledProcessError as e:\n            raise RuntimeError(f\"Failed to check Docker containers: {e}\")\n\n    def get_allowed_commands(self) -&gt; List[str]:\n        \"\"\"\n        Get the list of currently allowed commands.\n\n        Returns:\n            List of allowed command names.\n        \"\"\"\n        return self.allow_commands.copy()\n\n    def is_command_allowed(self, command: str) -&gt; bool:\n        \"\"\"\n        Check if a command is in the allow list.\n\n        Args:\n            command: Command name to check.\n\n        Returns:\n            True if command is allowed, False otherwise.\n        \"\"\"\n        if not command or not command.strip():\n            return False\n\n        command_name = command.strip().split()[0]\n        return command_name in self.allow_commands\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable-functions","title":"Functions","text":""},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.__init__","title":"<code>__init__(cwd=None, env=None, env_file='~/.env')</code>","text":"<p>Initialize the Shell instance.</p> <p>Parameters:</p> Name Type Description Default <code>cwd</code> <code>Optional[Union[str, PathLike]]</code> <p>Working directory for command execution. Defaults to current directory.</p> <code>None</code> <code>env</code> <code>Optional[Dict[str, str]]</code> <p>Environment variables dictionary. Defaults to copy of os.environ.</p> <code>None</code> <code>env_file</code> <code>str</code> <p>Path to environment file to load variables from.</p> <code>'~/.env'</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified working directory doesn't exist.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def __init__(\n    self,\n    cwd: Optional[Union[str, PathLike]] = None,\n    env: Optional[Dict[str, str]] = None,\n    env_file: str = \"~/.env\",\n) -&gt; None:\n    \"\"\"\n    Initialize the Shell instance.\n\n    Args:\n        cwd: Working directory for command execution. Defaults to current directory.\n        env: Environment variables dictionary. Defaults to copy of os.environ.\n        env_file: Path to environment file to load variables from.\n\n    Raises:\n        FileNotFoundError: If the specified working directory doesn't exist.\n    \"\"\"\n    super().__init__(name=\"shell\", path=str(cwd or os.getcwd()))\n\n    self.cwd = str(Path(cwd or os.getcwd()).resolve())\n    if not os.path.isdir(self.cwd):\n        raise FileNotFoundError(f\"Working directory does not exist: {self.cwd}\")\n\n    self.env = env or os.environ.copy()\n    self.env_file = os.path.expanduser(env_file)\n    self._load_env_file()\n    self.allow_commands: List[str] = []\n    self.last_result: Optional[subprocess.CompletedProcess] = None\n\n    # define basic commands\n    self.allow_commands.append(\"which\")\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.allow","title":"<code>allow(command)</code>","text":"<p>Allow a command to be executed.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Union[str, List[str]]</code> <p>The command or lost of commands to allow (first word will be extracted).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if command was successfully allowed, False if command doesn't exist.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If command is empty or invalid.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def allow(self, command: Union[str, List[str]]) -&gt; bool:\n    \"\"\"\n    Allow a command to be executed.\n\n    Args:\n        command: The command or lost of commands to allow (first word will be extracted).\n\n    Returns:\n        True if command was successfully allowed, False if command doesn't exist.\n\n    Raises:\n        ValueError: If command is empty or invalid.\n    \"\"\"\n    do_check: bool = True\n\n    if isinstance(command, str):\n        command = [command]\n\n    for cmd in command:\n        if not cmd or not cmd.split(\" \")[0].strip():\n            raise ValueError(\"Command cannot be empty\")\n\n        # check if available\n        if do_check:\n            # Use a different approach for checking command availability\n            # to avoid recursive call to run()\n            try:\n                if platform.system() == \"Windows\":\n                    # On Windows, try 'where' command instead of 'which'\n                    check_result = subprocess.run(\n                        [\"where\", cmd], capture_output=True, timeout=2, env=self.env\n                    )\n                else:\n                    # On Unix systems, use 'which'\n                    check_result = subprocess.run(\n                        [\"which\", cmd], capture_output=True, timeout=2, env=self.env\n                    )\n                add = check_result.returncode == 0\n            except (\n                subprocess.CalledProcessError,\n                subprocess.TimeoutExpired,\n                FileNotFoundError,\n            ):\n                add = True  # If we can't check, assume it's available\n                console.print(f\"\u26a0\ufe0f Could not verify availability of command: {cmd}\")\n        else:\n            add = True\n            console.print(f\"\u26a0\ufe0f Skipping availability check for command: {cmd}\")\n\n        if add:\n            # command is available\n            if cmd not in self.allow_commands:\n                self.allow_commands.append(cmd)\n            else:\n                pass\n            result = True\n        else:\n            console.print(\n                f\"\u274c Command not found: {cmd} in {self.env.get('PATH', '')}\"\n            )\n            result = False\n\n    return result\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.run","title":"<code>run(command_with_args, timeout=None, capture_output=True, text=True, check=True)</code>","text":"<p>Execute a shell command with security checks.</p> <p>Parameters:</p> Name Type Description Default <code>command_with_args</code> <code>str</code> <p>The shell command to execute including arguments.</p> required <code>timeout</code> <code>Optional[int]</code> <p>Maximum seconds to wait for command completion.</p> <code>None</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture stdout and stderr.</p> <code>True</code> <code>text</code> <code>bool</code> <p>Whether to return output as text (str) or bytes.</p> <code>True</code> <code>check</code> <code>bool</code> <p>Whether to raise exception on non-zero exit codes.</p> <code>True</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>CompletedProcess object with execution results.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the command is not in the allow list.</p> <code>CalledProcessError</code> <p>If check=True and command fails.</p> <code>TimeoutExpired</code> <p>If command times out.</p> <code>ValueError</code> <p>If command is empty or invalid.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def run(\n    self,\n    command_with_args: str,\n    timeout: Optional[int] = None,\n    capture_output: bool = True,\n    text: bool = True,\n    check: bool = True,\n) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Execute a shell command with security checks.\n\n    Args:\n        command_with_args: The shell command to execute including arguments.\n        timeout: Maximum seconds to wait for command completion.\n        capture_output: Whether to capture stdout and stderr.\n        text: Whether to return output as text (str) or bytes.\n        check: Whether to raise exception on non-zero exit codes.\n\n    Returns:\n        CompletedProcess object with execution results.\n\n    Raises:\n        PermissionError: If the command is not in the allow list.\n        subprocess.CalledProcessError: If check=True and command fails.\n        subprocess.TimeoutExpired: If command times out.\n        ValueError: If command is empty or invalid.\n    \"\"\"\n\n    if isinstance(command_with_args, str):\n        command_parts = command_with_args.strip().split()\n    else:\n        command_parts = command_with_args\n\n    command_name = command_parts[0]\n\n    console.print(f\"[bold]$ {command_with_args}[/bold]\")\n\n    if command_name not in self.allow_commands:\n        raise PermissionError(\n            f\"Command '{command_name}' is not allowed. Use allow() first.\"\n        )\n\n    try:\n        result = subprocess.run(\n            command_parts,\n            cwd=self.cwd,\n            env=self.env,\n            timeout=timeout,\n            capture_output=capture_output,\n            text=text,\n            check=check,\n        )\n\n        if result.stderr and capture_output:\n            console.print(f\"[red]Error: {result.stderr}[/red]\")\n\n        self.last_result = result\n        return result\n\n    except subprocess.CalledProcessError as e:\n        self.last_result = e\n        raise\n    except subprocess.TimeoutExpired as e:\n        console.print(\n            f\"[red]Command timed out after {timeout} seconds: {command_with_args}[/red]\"\n        )\n        raise\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.run_in","title":"<code>run_in(container_name, command_with_args, timeout=None, capture_output=True, text=True, check=True)</code>","text":"<p>Execute a command inside a Docker container.</p> <p>Parameters:</p> Name Type Description Default <code>container_name</code> <code>str</code> <p>Name of the Docker container.</p> required <code>command_with_args</code> <code>list[str] | str</code> <p>Command to execute inside the container.</p> required <code>timeout</code> <code>Optional[int]</code> <p>Maximum seconds to wait for command completion.</p> <code>None</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture stdout and stderr.</p> <code>True</code> <code>text</code> <code>bool</code> <p>Whether to return output as text (str) or bytes.</p> <code>True</code> <code>check</code> <code>bool</code> <p>Whether to raise exception on non-zero exit codes.</p> <code>True</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>CompletedProcess object with execution results.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If docker command is not allowed.</p> <code>CalledProcessError</code> <p>If check=True and command fails.</p> <code>ValueError</code> <p>If container_name or command is empty.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def run_in(\n    self,\n    container_name: str,\n    command_with_args: list[str] | str,\n    timeout: Optional[int] = None,\n    capture_output: bool = True,\n    text: bool = True,\n    check: bool = True,\n) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Execute a command inside a Docker container.\n\n    Args:\n        container_name: Name of the Docker container.\n        command_with_args: Command to execute inside the container.\n        timeout: Maximum seconds to wait for command completion.\n        capture_output: Whether to capture stdout and stderr.\n        text: Whether to return output as text (str) or bytes.\n        check: Whether to raise exception on non-zero exit codes.\n\n    Returns:\n        CompletedProcess object with execution results.\n\n    Raises:\n        PermissionError: If docker command is not allowed.\n        subprocess.CalledProcessError: If check=True and command fails.\n        ValueError: If container_name or command is empty.\n    \"\"\"\n\n    command_with_args.insert(0, container_name)\n    command_with_args.insert(0, \"exec\")\n    command_with_args.insert(0, \"docker\")\n\n    return self.run(command_with_args, timeout, capture_output, text, check)\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.cd","title":"<code>cd(path)</code>","text":"<p>Change the current working directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to change to (relative or absolute).</p> required <p>Raises:</p> Type Description <code>NotADirectoryError</code> <p>If the path is not a valid directory.</p> <code>ValueError</code> <p>If path is empty.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def cd(self, path: str) -&gt; None:\n    \"\"\"\n    Change the current working directory.\n\n    Args:\n        path: Path to change to (relative or absolute).\n\n    Raises:\n        NotADirectoryError: If the path is not a valid directory.\n        ValueError: If path is empty.\n    \"\"\"\n    if not path or not path.strip():\n        raise ValueError(\"Path cannot be empty\")\n\n    if os.name == \"nt\":\n        new_path = Path(\"C:\") / os.path.abspath(\n            os.path.join(self.cwd, path.replace(\"/\", \"\\\\\"))\n        )\n\n    new_path = os.path.abspath(os.path.join(self.cwd, path))\n\n    if not os.path.isdir(new_path):\n        raise NotADirectoryError(f\"{new_path} is not a valid directory.\")\n\n    self.cwd = new_path\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.get_env_var","title":"<code>get_env_var(var_name)</code>","text":"<p>Get the value of an environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_name</code> <code>str</code> <p>Name of the environment variable.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Value of the environment variable or None if not found.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If var_name is empty.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def get_env_var(self, var_name: str) -&gt; Optional[str]:\n    \"\"\"\n    Get the value of an environment variable.\n\n    Args:\n        var_name: Name of the environment variable.\n\n    Returns:\n        Value of the environment variable or None if not found.\n\n    Raises:\n        ValueError: If var_name is empty.\n    \"\"\"\n    if not var_name or not var_name.strip():\n        raise ValueError(\"Variable name cannot be empty\")\n\n    return self.env.get(var_name)\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.set_env_var","title":"<code>set_env_var(var_name, value)</code>","text":"<p>Set an environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_name</code> <code>str</code> <p>Name of the environment variable.</p> required <code>value</code> <code>str</code> <p>Value to set.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If var_name is empty.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def set_env_var(self, var_name: str, value: str) -&gt; None:\n    \"\"\"\n    Set an environment variable.\n\n    Args:\n        var_name: Name of the environment variable.\n        value: Value to set.\n\n    Raises:\n        ValueError: If var_name is empty.\n    \"\"\"\n    if not var_name or not var_name.strip():\n        raise ValueError(\"Variable name cannot be empty\")\n\n    self.env[var_name] = value\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.sleep","title":"<code>sleep(seconds)</code>","text":"<p>Sleep for the specified number of seconds.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>Union[int, float]</code> <p>Number of seconds to sleep.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If seconds is negative.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def sleep(self, seconds: Union[int, float]) -&gt; None:\n    \"\"\"\n    Sleep for the specified number of seconds.\n\n    Args:\n        seconds: Number of seconds to sleep.\n\n    Raises:\n        ValueError: If seconds is negative.\n    \"\"\"\n    if seconds &lt; 0:\n        raise ValueError(\"Sleep duration cannot be negative\")\n\n    time.sleep(seconds)\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.depends_on","title":"<code>depends_on(names)</code>","text":"<p>Check if Docker containers are running.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>Union[str, List[str]]</code> <p>Container name(s) to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if all containers are running.</p> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If any container is not running.</p> <code>RuntimeError</code> <p>If docker command fails.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def depends_on(self, names: Union[str, List[str]]) -&gt; bool:\n    \"\"\"\n    Check if Docker containers are running.\n\n    Args:\n        names: Container name(s) to check.\n\n    Returns:\n        True if all containers are running.\n\n    Raises:\n        SystemExit: If any container is not running.\n        RuntimeError: If docker command fails.\n    \"\"\"\n    if isinstance(names, str):\n        names = [names]\n\n    if not names:\n        raise ValueError(\"Container names cannot be empty\")\n\n    try:\n        # Ensure docker is allowed\n        if \"docker\" not in self.allow_commands:\n            if not self.allow(\"docker\"):\n                raise RuntimeError(\"Docker command is not available\")\n\n        result = self.run(\"docker ps --format '{{.Names}}'\", check=True)\n        running_containers = [\n            line.strip().replace(\"'\", \"\") for line in result.stdout.splitlines()\n        ]\n\n        for name in names:\n            if name not in running_containers:\n                console.print(f\"[red]Container {name} is not running![/red]\")\n                sys.exit(2)\n\n        return True\n\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Failed to check Docker containers: {e}\")\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.get_allowed_commands","title":"<code>get_allowed_commands()</code>","text":"<p>Get the list of currently allowed commands.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of allowed command names.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def get_allowed_commands(self) -&gt; List[str]:\n    \"\"\"\n    Get the list of currently allowed commands.\n\n    Returns:\n        List of allowed command names.\n    \"\"\"\n    return self.allow_commands.copy()\n</code></pre>"},{"location":"api/objects/shell-executable/#hands_scaphoid.objects.ShellExecutable.ShellExecutable.is_command_allowed","title":"<code>is_command_allowed(command)</code>","text":"<p>Check if a command is in the allow list.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if command is allowed, False otherwise.</p> Source code in <code>src/hands_scaphoid/objects/ShellExecutable.py</code> <pre><code>def is_command_allowed(self, command: str) -&gt; bool:\n    \"\"\"\n    Check if a command is in the allow list.\n\n    Args:\n        command: Command name to check.\n\n    Returns:\n        True if command is allowed, False otherwise.\n    \"\"\"\n    if not command or not command.strip():\n        return False\n\n    command_name = command.strip().split()[0]\n    return command_name in self.allow_commands\n</code></pre>"},{"location":"api/objects/ssh-shell/","title":"System SSH Shell API Reference","text":"<p>TODO: Add a note about SSH shell.</p>"},{"location":"api/objects/ssh-shell/#api-documentation","title":"API Documentation","text":""},{"location":"api/objects/ssh-shell/#todo-switch-to-sshshell-if-class-is-implemented","title":"TODO: switch to SshShell (if class is implemented)","text":""},{"location":"api/objects/ssh-shell/#hands_scaphoid.objects.WslShell","title":"<code>hands_scaphoid.objects.WslShell</code>","text":"<p>               Bases: <code>ShellExecutable</code></p> <p>A shell executor that runs commands in Windows Subsystem for Linux.</p> <p>This class prefixes commands with wsl.exe or a specific distribution executable (like debian.exe) to execute Linux commands on Windows.</p> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>class WslShell(Shell):\n    \"\"\"\n    A shell executor that runs commands in Windows Subsystem for Linux.\n\n    This class prefixes commands with wsl.exe or a specific distribution\n    executable (like debian.exe) to execute Linux commands on Windows.\n    \"\"\"\n\n    def __init__(\n        self, distribution: str = \"wsl\", *args: List[str], **kwargs: Dict[str, str]\n    ):\n        \"\"\"\n        Initialize WslShell with a specific WSL distribution.\n\n        Args:\n            distribution: WSL distribution command (e.g., 'wsl', 'debian', 'ubuntu')\n            *args:\n            **kwargs: Arguments passed to parent Shell class\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.distribution = distribution\n\n        # Ensure the distribution executable exists\n        if not self._check_wsl_available():\n            raise RuntimeError(f\"WSL distribution '{distribution}' is not available\")\n\n    def _check_wsl_available(self) -&gt; bool:\n        \"\"\"\n        Check if the specified WSL distribution is available.\n\n        Returns:\n            True if WSL distribution is available, False otherwise\n        \"\"\"\n        try:\n            # Try to run the distribution command with --help\n            result = subprocess.run(\n                [f\"{self.distribution}.exe\", \"--help\"], capture_output=True, timeout=5\n            )\n            return result.returncode == 0\n        except (\n            subprocess.CalledProcessError,\n            FileNotFoundError,\n            subprocess.TimeoutExpired,\n        ):\n            return False\n\n    def _wrap_command_for_wsl(self, command_with_args: str) -&gt; List[str]:\n        \"\"\"\n        Wrap a command to be executed in WSL.\n\n        Args:\n            command_with_args: The original command with arguments\n\n        Returns:\n            List of command parts including WSL wrapper\n        \"\"\"\n        if isinstance(command_with_args, str):\n            # For string commands, pass them to WSL as a single argument\n            return [f\"{self.distribution}.exe\", \"--\", \"sh\", \"-c\", command_with_args]\n        else:\n            # For list commands, join them and pass to WSL\n            command_str = \" \".join(command_with_args)\n            return [f\"{self.distribution}.exe\", \"--\", \"sh\", \"-c\", command_str]\n\n    def run(\n        self, command_with_args: str, **kwargs: Dict[str, str]\n    ) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Execute a command in WSL.\n\n        Args:\n            command_with_args: The command to execute in WSL\n            **kwargs: Additional arguments passed to subprocess.run\n\n        Returns:\n            CompletedProcess object with execution results\n        \"\"\"\n        if platform.system() == \"Windows\":\n            # Wrap the command for WSL execution\n            wsl_command = self._wrap_command_for_wsl(command_with_args)\n\n            # Extract the base command for permission checking\n            if isinstance(command_with_args, str):\n                base_command = command_with_args.strip().split()[0]\n            else:\n                base_command = command_with_args[0]\n\n            # Check if the base command is allowed\n            if base_command not in self.allow_commands:\n                raise PermissionError(\n                    f\"Command '{base_command}' is not allowed. Use allow() first.\"\n                )\n\n            console.print(f\"[bold]$ (WSL) {command_with_args}[/bold]\")\n\n            # Execute the wrapped command\n            return subprocess.run(wsl_command, cwd=self.cwd, env=self.env, **kwargs)\n        else:\n            # On non-Windows systems, just run the command normally\n            return super().run(command_with_args, **kwargs)\n\n    def list_distributions(self) -&gt; List[str]:\n        \"\"\"\n        List available WSL distributions.\n\n        Returns:\n            List of available WSL distribution names\n        \"\"\"\n        try:\n            result = subprocess.run(\n                [\"wsl.exe\", \"--list\", \"--quiet\"],\n                capture_output=True,\n                text=True,\n                check=True,\n            )\n            # Parse the output to get distribution names\n            distributions = []\n            for line in result.stdout.strip().split(\"\\n\"):\n                if line.strip():\n                    # Remove any special characters and whitespace\n                    dist_name = (\n                        line.strip().replace(\"\\x00\", \"\").replace(\"*\", \"\").strip()\n                    )\n                    if dist_name:\n                        distributions.append(dist_name)\n            return distributions\n        except (subprocess.CalledProcessError, FileNotFoundError):\n            return []\n\n    def set_distribution(self, distribution: str) -&gt; bool:\n        \"\"\"\n        Change the WSL distribution used by this shell.\n\n        Args:\n            distribution: New distribution name to use\n\n        Returns:\n            True if distribution was successfully set, False otherwise\n        \"\"\"\n        old_distribution = self.distribution\n        self.distribution = distribution\n\n        if self._check_wsl_available():\n            return True\n        else:\n            # Revert to old distribution if new one is not available\n            self.distribution = old_distribution\n            return False\n</code></pre>"},{"location":"api/objects/ssh-shell/#hands_scaphoid.objects.WslShell-functions","title":"Functions","text":""},{"location":"api/objects/ssh-shell/#hands_scaphoid.objects.WslShell.__init__","title":"<code>__init__(distribution='wsl', *args, **kwargs)</code>","text":"<p>Initialize WslShell with a specific WSL distribution.</p> <p>Parameters:</p> Name Type Description Default <code>distribution</code> <code>str</code> <p>WSL distribution command (e.g., 'wsl', 'debian', 'ubuntu')</p> <code>'wsl'</code> <code>*args</code> <code>List[str]</code> <code>()</code> <code>**kwargs</code> <code>Dict[str, str]</code> <p>Arguments passed to parent Shell class</p> <code>{}</code> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>def __init__(\n    self, distribution: str = \"wsl\", *args: List[str], **kwargs: Dict[str, str]\n):\n    \"\"\"\n    Initialize WslShell with a specific WSL distribution.\n\n    Args:\n        distribution: WSL distribution command (e.g., 'wsl', 'debian', 'ubuntu')\n        *args:\n        **kwargs: Arguments passed to parent Shell class\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.distribution = distribution\n\n    # Ensure the distribution executable exists\n    if not self._check_wsl_available():\n        raise RuntimeError(f\"WSL distribution '{distribution}' is not available\")\n</code></pre>"},{"location":"api/objects/ssh-shell/#hands_scaphoid.objects.WslShell.run","title":"<code>run(command_with_args, **kwargs)</code>","text":"<p>Execute a command in WSL.</p> <p>Parameters:</p> Name Type Description Default <code>command_with_args</code> <code>str</code> <p>The command to execute in WSL</p> required <code>**kwargs</code> <code>Dict[str, str]</code> <p>Additional arguments passed to subprocess.run</p> <code>{}</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>CompletedProcess object with execution results</p> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>def run(\n    self, command_with_args: str, **kwargs: Dict[str, str]\n) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Execute a command in WSL.\n\n    Args:\n        command_with_args: The command to execute in WSL\n        **kwargs: Additional arguments passed to subprocess.run\n\n    Returns:\n        CompletedProcess object with execution results\n    \"\"\"\n    if platform.system() == \"Windows\":\n        # Wrap the command for WSL execution\n        wsl_command = self._wrap_command_for_wsl(command_with_args)\n\n        # Extract the base command for permission checking\n        if isinstance(command_with_args, str):\n            base_command = command_with_args.strip().split()[0]\n        else:\n            base_command = command_with_args[0]\n\n        # Check if the base command is allowed\n        if base_command not in self.allow_commands:\n            raise PermissionError(\n                f\"Command '{base_command}' is not allowed. Use allow() first.\"\n            )\n\n        console.print(f\"[bold]$ (WSL) {command_with_args}[/bold]\")\n\n        # Execute the wrapped command\n        return subprocess.run(wsl_command, cwd=self.cwd, env=self.env, **kwargs)\n    else:\n        # On non-Windows systems, just run the command normally\n        return super().run(command_with_args, **kwargs)\n</code></pre>"},{"location":"api/objects/ssh-shell/#hands_scaphoid.objects.WslShell.list_distributions","title":"<code>list_distributions()</code>","text":"<p>List available WSL distributions.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of available WSL distribution names</p> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>def list_distributions(self) -&gt; List[str]:\n    \"\"\"\n    List available WSL distributions.\n\n    Returns:\n        List of available WSL distribution names\n    \"\"\"\n    try:\n        result = subprocess.run(\n            [\"wsl.exe\", \"--list\", \"--quiet\"],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        # Parse the output to get distribution names\n        distributions = []\n        for line in result.stdout.strip().split(\"\\n\"):\n            if line.strip():\n                # Remove any special characters and whitespace\n                dist_name = (\n                    line.strip().replace(\"\\x00\", \"\").replace(\"*\", \"\").strip()\n                )\n                if dist_name:\n                    distributions.append(dist_name)\n        return distributions\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        return []\n</code></pre>"},{"location":"api/objects/ssh-shell/#hands_scaphoid.objects.WslShell.set_distribution","title":"<code>set_distribution(distribution)</code>","text":"<p>Change the WSL distribution used by this shell.</p> <p>Parameters:</p> Name Type Description Default <code>distribution</code> <code>str</code> <p>New distribution name to use</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if distribution was successfully set, False otherwise</p> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>def set_distribution(self, distribution: str) -&gt; bool:\n    \"\"\"\n    Change the WSL distribution used by this shell.\n\n    Args:\n        distribution: New distribution name to use\n\n    Returns:\n        True if distribution was successfully set, False otherwise\n    \"\"\"\n    old_distribution = self.distribution\n    self.distribution = distribution\n\n    if self._check_wsl_available():\n        return True\n    else:\n        # Revert to old distribution if new one is not available\n        self.distribution = old_distribution\n        return False\n</code></pre>"},{"location":"api/objects/variable-item/","title":"Variable API Reference","text":"<p><code>Variables</code> are special simple <code>Items</code> that hold configuration values like environment settings or default paths. They have a <code>Key</code> (e.g. <code>$HOME</code>, <code>$PATH</code>, <code>$USER</code>) and a <code>Value</code> (e.g. <code>/home/user</code>, <code>/usr/bin:/bin</code>, <code>user</code>).</p>"},{"location":"api/objects/variable-item/#api-documentation","title":"API Documentation","text":""},{"location":"api/objects/variable-item/#hands_scaphoid.objects.VariableItem","title":"<code>hands_scaphoid.objects.VariableItem</code>","text":""},{"location":"api/objects/variable-item/#hands_scaphoid.objects.VariableItem-classes","title":"Classes","text":""},{"location":"api/objects/variable-item/#hands_scaphoid.objects.VariableItem.VariableItem","title":"<code>VariableItem</code>","text":"<p>               Bases: <code>ItemCore</code></p> <p>Represents a variable in the shell context.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the variable.</p> <code>value</code> <code>str</code> <p>The value of the variable.</p> Source code in <code>src/hands_scaphoid/objects/VariableItem.py</code> <pre><code>class VariableItem(ItemCore):\n    \"\"\"\n    Represents a variable in the shell context.\n\n    Attributes:\n        name (str): The name of the variable.\n        value (str): The value of the variable.\n    \"\"\"\n\n    def __init__(self, name: str, value: str):\n        \"\"\"Initializes a VariableItem instance.\"\"\"\n        super().__init__(name, value, item_type=ItemType.VARIABLE)\n        self.value = value\n\n    def __repr__(self):\n        \"\"\"Returns a string representation of the VariableItem.\"\"\"\n        return f\"VariableItem(name={self.name}, value={self.value})\"\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"VariableItem\":\n        \"\"\"ensure correct type\"\"\"\n        obj = super().from_dict(data)\n        if not is_instance(obj, VariableItem):\n            raise TypeError(f\"from_dict expected to create 'VariableItem', got '{type(obj)}'\")\n        return obj\n</code></pre>"},{"location":"api/objects/variable-item/#hands_scaphoid.objects.VariableItem.VariableItem-functions","title":"Functions","text":""},{"location":"api/objects/variable-item/#hands_scaphoid.objects.VariableItem.VariableItem.__init__","title":"<code>__init__(name, value)</code>","text":"<p>Initializes a VariableItem instance.</p> Source code in <code>src/hands_scaphoid/objects/VariableItem.py</code> <pre><code>def __init__(self, name: str, value: str):\n    \"\"\"Initializes a VariableItem instance.\"\"\"\n    super().__init__(name, value, item_type=ItemType.VARIABLE)\n    self.value = value\n</code></pre>"},{"location":"api/objects/variable-item/#hands_scaphoid.objects.VariableItem.VariableItem.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the VariableItem.</p> Source code in <code>src/hands_scaphoid/objects/VariableItem.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns a string representation of the VariableItem.\"\"\"\n    return f\"VariableItem(name={self.name}, value={self.value})\"\n</code></pre>"},{"location":"api/objects/variable-item/#hands_scaphoid.objects.VariableItem.VariableItem.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>ensure correct type</p> Source code in <code>src/hands_scaphoid/objects/VariableItem.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"VariableItem\":\n    \"\"\"ensure correct type\"\"\"\n    obj = super().from_dict(data)\n    if not is_instance(obj, VariableItem):\n        raise TypeError(f\"from_dict expected to create 'VariableItem', got '{type(obj)}'\")\n    return obj\n</code></pre>"},{"location":"api/objects/wsl-shell/","title":"Windows WSL Shell API Reference","text":"<p>TODO: Add a note about WSL and Git Bash on Windows.</p>"},{"location":"api/objects/wsl-shell/#api-documentation","title":"API Documentation","text":""},{"location":"api/objects/wsl-shell/#hands_scaphoid.objects.WslShell","title":"<code>hands_scaphoid.objects.WslShell</code>","text":"<p>               Bases: <code>ShellExecutable</code></p> <p>A shell executor that runs commands in Windows Subsystem for Linux.</p> <p>This class prefixes commands with wsl.exe or a specific distribution executable (like debian.exe) to execute Linux commands on Windows.</p> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>class WslShell(Shell):\n    \"\"\"\n    A shell executor that runs commands in Windows Subsystem for Linux.\n\n    This class prefixes commands with wsl.exe or a specific distribution\n    executable (like debian.exe) to execute Linux commands on Windows.\n    \"\"\"\n\n    def __init__(\n        self, distribution: str = \"wsl\", *args: List[str], **kwargs: Dict[str, str]\n    ):\n        \"\"\"\n        Initialize WslShell with a specific WSL distribution.\n\n        Args:\n            distribution: WSL distribution command (e.g., 'wsl', 'debian', 'ubuntu')\n            *args:\n            **kwargs: Arguments passed to parent Shell class\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.distribution = distribution\n\n        # Ensure the distribution executable exists\n        if not self._check_wsl_available():\n            raise RuntimeError(f\"WSL distribution '{distribution}' is not available\")\n\n    def _check_wsl_available(self) -&gt; bool:\n        \"\"\"\n        Check if the specified WSL distribution is available.\n\n        Returns:\n            True if WSL distribution is available, False otherwise\n        \"\"\"\n        try:\n            # Try to run the distribution command with --help\n            result = subprocess.run(\n                [f\"{self.distribution}.exe\", \"--help\"], capture_output=True, timeout=5\n            )\n            return result.returncode == 0\n        except (\n            subprocess.CalledProcessError,\n            FileNotFoundError,\n            subprocess.TimeoutExpired,\n        ):\n            return False\n\n    def _wrap_command_for_wsl(self, command_with_args: str) -&gt; List[str]:\n        \"\"\"\n        Wrap a command to be executed in WSL.\n\n        Args:\n            command_with_args: The original command with arguments\n\n        Returns:\n            List of command parts including WSL wrapper\n        \"\"\"\n        if isinstance(command_with_args, str):\n            # For string commands, pass them to WSL as a single argument\n            return [f\"{self.distribution}.exe\", \"--\", \"sh\", \"-c\", command_with_args]\n        else:\n            # For list commands, join them and pass to WSL\n            command_str = \" \".join(command_with_args)\n            return [f\"{self.distribution}.exe\", \"--\", \"sh\", \"-c\", command_str]\n\n    def run(\n        self, command_with_args: str, **kwargs: Dict[str, str]\n    ) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Execute a command in WSL.\n\n        Args:\n            command_with_args: The command to execute in WSL\n            **kwargs: Additional arguments passed to subprocess.run\n\n        Returns:\n            CompletedProcess object with execution results\n        \"\"\"\n        if platform.system() == \"Windows\":\n            # Wrap the command for WSL execution\n            wsl_command = self._wrap_command_for_wsl(command_with_args)\n\n            # Extract the base command for permission checking\n            if isinstance(command_with_args, str):\n                base_command = command_with_args.strip().split()[0]\n            else:\n                base_command = command_with_args[0]\n\n            # Check if the base command is allowed\n            if base_command not in self.allow_commands:\n                raise PermissionError(\n                    f\"Command '{base_command}' is not allowed. Use allow() first.\"\n                )\n\n            console.print(f\"[bold]$ (WSL) {command_with_args}[/bold]\")\n\n            # Execute the wrapped command\n            return subprocess.run(wsl_command, cwd=self.cwd, env=self.env, **kwargs)\n        else:\n            # On non-Windows systems, just run the command normally\n            return super().run(command_with_args, **kwargs)\n\n    def list_distributions(self) -&gt; List[str]:\n        \"\"\"\n        List available WSL distributions.\n\n        Returns:\n            List of available WSL distribution names\n        \"\"\"\n        try:\n            result = subprocess.run(\n                [\"wsl.exe\", \"--list\", \"--quiet\"],\n                capture_output=True,\n                text=True,\n                check=True,\n            )\n            # Parse the output to get distribution names\n            distributions = []\n            for line in result.stdout.strip().split(\"\\n\"):\n                if line.strip():\n                    # Remove any special characters and whitespace\n                    dist_name = (\n                        line.strip().replace(\"\\x00\", \"\").replace(\"*\", \"\").strip()\n                    )\n                    if dist_name:\n                        distributions.append(dist_name)\n            return distributions\n        except (subprocess.CalledProcessError, FileNotFoundError):\n            return []\n\n    def set_distribution(self, distribution: str) -&gt; bool:\n        \"\"\"\n        Change the WSL distribution used by this shell.\n\n        Args:\n            distribution: New distribution name to use\n\n        Returns:\n            True if distribution was successfully set, False otherwise\n        \"\"\"\n        old_distribution = self.distribution\n        self.distribution = distribution\n\n        if self._check_wsl_available():\n            return True\n        else:\n            # Revert to old distribution if new one is not available\n            self.distribution = old_distribution\n            return False\n</code></pre>"},{"location":"api/objects/wsl-shell/#hands_scaphoid.objects.WslShell-functions","title":"Functions","text":""},{"location":"api/objects/wsl-shell/#hands_scaphoid.objects.WslShell.__init__","title":"<code>__init__(distribution='wsl', *args, **kwargs)</code>","text":"<p>Initialize WslShell with a specific WSL distribution.</p> <p>Parameters:</p> Name Type Description Default <code>distribution</code> <code>str</code> <p>WSL distribution command (e.g., 'wsl', 'debian', 'ubuntu')</p> <code>'wsl'</code> <code>*args</code> <code>List[str]</code> <code>()</code> <code>**kwargs</code> <code>Dict[str, str]</code> <p>Arguments passed to parent Shell class</p> <code>{}</code> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>def __init__(\n    self, distribution: str = \"wsl\", *args: List[str], **kwargs: Dict[str, str]\n):\n    \"\"\"\n    Initialize WslShell with a specific WSL distribution.\n\n    Args:\n        distribution: WSL distribution command (e.g., 'wsl', 'debian', 'ubuntu')\n        *args:\n        **kwargs: Arguments passed to parent Shell class\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.distribution = distribution\n\n    # Ensure the distribution executable exists\n    if not self._check_wsl_available():\n        raise RuntimeError(f\"WSL distribution '{distribution}' is not available\")\n</code></pre>"},{"location":"api/objects/wsl-shell/#hands_scaphoid.objects.WslShell.run","title":"<code>run(command_with_args, **kwargs)</code>","text":"<p>Execute a command in WSL.</p> <p>Parameters:</p> Name Type Description Default <code>command_with_args</code> <code>str</code> <p>The command to execute in WSL</p> required <code>**kwargs</code> <code>Dict[str, str]</code> <p>Additional arguments passed to subprocess.run</p> <code>{}</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>CompletedProcess object with execution results</p> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>def run(\n    self, command_with_args: str, **kwargs: Dict[str, str]\n) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Execute a command in WSL.\n\n    Args:\n        command_with_args: The command to execute in WSL\n        **kwargs: Additional arguments passed to subprocess.run\n\n    Returns:\n        CompletedProcess object with execution results\n    \"\"\"\n    if platform.system() == \"Windows\":\n        # Wrap the command for WSL execution\n        wsl_command = self._wrap_command_for_wsl(command_with_args)\n\n        # Extract the base command for permission checking\n        if isinstance(command_with_args, str):\n            base_command = command_with_args.strip().split()[0]\n        else:\n            base_command = command_with_args[0]\n\n        # Check if the base command is allowed\n        if base_command not in self.allow_commands:\n            raise PermissionError(\n                f\"Command '{base_command}' is not allowed. Use allow() first.\"\n            )\n\n        console.print(f\"[bold]$ (WSL) {command_with_args}[/bold]\")\n\n        # Execute the wrapped command\n        return subprocess.run(wsl_command, cwd=self.cwd, env=self.env, **kwargs)\n    else:\n        # On non-Windows systems, just run the command normally\n        return super().run(command_with_args, **kwargs)\n</code></pre>"},{"location":"api/objects/wsl-shell/#hands_scaphoid.objects.WslShell.list_distributions","title":"<code>list_distributions()</code>","text":"<p>List available WSL distributions.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of available WSL distribution names</p> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>def list_distributions(self) -&gt; List[str]:\n    \"\"\"\n    List available WSL distributions.\n\n    Returns:\n        List of available WSL distribution names\n    \"\"\"\n    try:\n        result = subprocess.run(\n            [\"wsl.exe\", \"--list\", \"--quiet\"],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        # Parse the output to get distribution names\n        distributions = []\n        for line in result.stdout.strip().split(\"\\n\"):\n            if line.strip():\n                # Remove any special characters and whitespace\n                dist_name = (\n                    line.strip().replace(\"\\x00\", \"\").replace(\"*\", \"\").strip()\n                )\n                if dist_name:\n                    distributions.append(dist_name)\n        return distributions\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        return []\n</code></pre>"},{"location":"api/objects/wsl-shell/#hands_scaphoid.objects.WslShell.set_distribution","title":"<code>set_distribution(distribution)</code>","text":"<p>Change the WSL distribution used by this shell.</p> <p>Parameters:</p> Name Type Description Default <code>distribution</code> <code>str</code> <p>New distribution name to use</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if distribution was successfully set, False otherwise</p> Source code in <code>src/hands_scaphoid/objects/shells/WslShell.py</code> <pre><code>def set_distribution(self, distribution: str) -&gt; bool:\n    \"\"\"\n    Change the WSL distribution used by this shell.\n\n    Args:\n        distribution: New distribution name to use\n\n    Returns:\n        True if distribution was successfully set, False otherwise\n    \"\"\"\n    old_distribution = self.distribution\n    self.distribution = distribution\n\n    if self._check_wsl_available():\n        return True\n    else:\n        # Revert to old distribution if new one is not available\n        self.distribution = old_distribution\n        return False\n</code></pre>"},{"location":"operations/summary/","title":"Summary of file system operations","text":"<p>Excludes</p> <p>This does not include operations for processes and system management. But the related remote commands (network based file system), user and groups are included.</p>"},{"location":"operations/summary/#elements","title":"Elements:","text":"<pre><code>---\nconfig:\n  layout: elk\n---\ngraph TD;\n    ItemCore@{ shape: rounded} --&gt; ObjectItem@{ shape: rounded}\n    ObjectItem --&gt; n1@{ shape: anchor}\n    ItemCore --&gt; PathVariable@{ shape: rounded};\n    ItemCore --&gt; System['system']@{ shape: card};\n    System['system'] --&gt;|provides| Filesystem['filesystem'];\n    ItemCore --&gt; VariableItem@{ shape: rounded};\n    Environment['environment']@{ shape: card} --&gt;|contains| VariableItem;\n</code></pre> <ul> <li><code>ItemCore</code> is the top most generic items</li> <li><code>VariableItem</code> is a special simple <code>ItemCore</code> that hold configuration values like environment settings or default paths they have a <code>Key</code> (e.g. <code>$HOME</code>, <code>$PATH</code>, <code>$USER</code>) and a <code>Value</code> (e.g. <code>/home/user</code>, <code>/usr/bin:/bin</code>, <code>user</code>)</li> <li><code>Environment</code> holds  <code>Variable(s)</code> that hold information about the execution environment (e.g. paths, user info)</li> <li><code>PathVariable</code> is a string representation of file system locations</li> <li><code>System</code> is a special <code>ItemCore</code> that holds addresses or URLs (<code>PathVariable</code>) to remote file systems (e.g. network shares, cloud storage or inside containers)</li> </ul> <pre><code>---\nconfig:\n  layout: elk\n---\nflowchart TD\n    MountPoint@{ label: \"'mount'\" } -- provides --&gt; DirectoryObject[\"DirectoryObject\"]\n    ObjectItem[\"ObjectItem\"] --&gt; DirectoryObject &amp; FileObject[\"FileObject\"] &amp; LinkObject[\"LinkObject\"]\n    DirectoryObject -- contains --&gt; FileObject\n    ArchiveFile[\"ArchiveFile\"] -- extracts --&gt; DirectoryObject\n    FileObject --&gt; ExecutableFile[\"ExecutableFile\"] &amp; ScriptFile[\"ScriptFile\"]\n    ScriptFile -- uses --&gt; ExecutableFile\n    DirectoryObject -- compresses --&gt; ArchiveFile\n    Path@{ label: \"'path'\" } -- identifies --&gt; FileObject &amp; DirectoryObject\n\n    MountPoint@{ shape: card}\n    DirectoryObject@{ shape: rounded}\n    ObjectItem@{ shape: rounded}\n    FileObject@{ shape: rounded}\n    LinkObject@{ shape: rounded}\n    ArchiveFile@{ shape: rounded} \n    FileObject --&gt; ArchiveFile\n    ExecutableFile@{ shape: rounded}\n    ScriptFile@{ shape: rounded}\n    Path@{ shape: card}\n     ArchiveFile:::Ash\n     ExecutableFile:::Ash\n     ScriptFile:::Ash\n    classDef Ash stroke-width:1px, stroke-dasharray:none, stroke:#999999, fill:#EEEEEE, color:#000000</code></pre> <ul> <li><code>ObjectItem</code>s are generic file system items.</li> <li><code>DirectoryObject</code>(Directories) are containers for files and other directories.</li> <li><code>FileObject</code>s are holding data in text or binary format.</li> <li> <p><code>LinkObject</code>s are references to other file system items.</p> </li> <li> <p><code>Archive</code>s are special <code>File</code> containers compressed files holding multiple files and directories</p> </li> <li><code>ExecutableFile</code>s are special binary <code>File</code>s that can be run as programs or interpreters</li> <li><code>ScriptFile</code>s are special text <code>File</code>s that contain a series of commands to be executed by a specific interpreter</li> <li><code>MountPoints</code> are special <code>Directory</code>s, locations in the file system where additional file systems can be attached</li> </ul> Types of OperationsGeneric OperationsArchive OperationsFile OperationsGeneric commands Symbol Type Description M meta read-access that retrieves metadata R read read-access that retrieves data S show read-access that displays data U update write-access that modifies existing meta data C create write-access that creates new data (no overwrite) W write write-access that extends or over-writes data D delete/remove delete-access that destroys data E execute unknown-access execute-access that runs a program or script Operation Type Bash Description exists( path ) M <code>test -e {path}</code> Check if an object exists at the given path exists( system_path ) M <code>test -e {system_path}</code> Check if a system object exists at the given path type( path ) M <code>file {path}</code> Show the type of object at the given path permissions( path ) M <code>ls -l {path}</code> Show the permissions of the object at the given path size( path ) M <code>du -sh {path}</code> Show the size of the object at the given path list( path, pattern ) S <code>ls -l {path} | grep {pattern}</code> List contents of a directory, archive or file path ... S <code>cat {file_path}</code> Show contents of a file at the given path list( file_path, head=) S <code>head {file_path}</code> Show first lines of a file at the given path list( file_path, tail=) S <code>tail {file_path}</code> Show last lines of a file at the given path list( file_path, pattern ) S <code>grep {pattern} {file_path}</code> Show lines matching pattern in a file list( archive_path ) S <code>tar -tf {archive_path}</code> List contents of an archive at the given path show( type ) R <code>ls -l</code> Show all objects of the given type in the current directory permissions( path, mode ) U <code>chmod {mode} {path}</code> Change the permissions of the object at the given path permissions( path, user, group ) U <code>chown {user:group} {path}</code> Change the owner and group of the object at the given path link( path ) C <code>ln -s {path}</code> Create a (symbolic) link at the given path mount( system, mount_point ) C <code>mount {system} {path}</code> Mount a remote file system at the given mount point extract( archive_path, target ) C <code>tar -xf {archive_path} -C {target}</code> Extract contents of an archive to the target path create( object_path ) C/W <code>touch {path}</code> Create an empty object at the given path move( source, destination ) W <code>mv {source} {target}</code> Move or rename an object from source to target path copy( source, destination ) W <code>cp {source} {target}</code> Copy or duplicate an object from source to target path unlink( path ) D <code>rm {path}</code> Remove a (symbolic) link at the given path delete( path, recursive=false ) D <code>rm {path}</code> Delete the object at the given path delete( path, recursive=true ) D+ <code>rm -r {path}</code> Recursively delete the object at the given path unmount( mount_point ) D <code>umount {path}</code> Unmount a remote file system from the given mount point execute( file_path, args ) E <code>{file_path} {args}</code> Execute a file at the given path with optional arguments Operation Type Implementation Status Test Coverage Description is_archive_file( path ) M \u2705 Implemented \u2705 Complete Check if file is an archive based on extension create_zip_archive( name, source ) C \u2705 Implemented \u2705 Complete Create ZIP archive from directory create_tar_archive( name, source ) C \u2705 Implemented \u2705 Complete Create TAR archive (with optional compression) create_7z_archive( name, source ) C \u2705 Implemented \u2705 Complete Create 7Z archive from directory create_rar_archive( name, source ) C \u2705 Implemented \u2705 Complete Create RAR archive (requires external rar command) extract( archive_path, target ) C \u2705 Implemented \u2705 Complete Extract archive contents to target directory list_contents( archive_path ) S \u2705 Implemented \u2705 Complete List files and directories in archive Operation Type Implementation Status Test Coverage Description read( path, head, tail ) R \u2705 Implemented \u2705 Complete Read file content with optional head/tail limits filter( path, pattern ) S \ud83d\udd04 TODO \ud83d\udd04 Placeholder Filter files by pattern (planned) write( path, data ) W \ud83d\udd04 TODO \ud83d\udd04 Placeholder Write data to file (planned) append( path, data ) W \ud83d\udd04 TODO \ud83d\udd04 Placeholder Append data to file (planned) create( path, data ) C \ud83d\udd04 TODO \ud83d\udd04 Placeholder Create new file with data (planned) Operation Type Implementation Status Test Coverage Description exists( path ) M \u2705 Implemented \u2705 Complete Check if path exists does_not_exists( path ) M \u2705 Implemented \u2705 Complete Check if path does not exist is_file( path ) M \u2705 Implemented \u2705 Complete Check if path is a file is_directory( path ) M \u2705 Implemented \u2705 Complete Check if path is a directory is_link( path ) M \u2705 Implemented \u2705 Complete Check if path is a symbolic link is_object( path ) M \u2705 Implemented \u2705 Complete Check if path is any file system object is_project( path ) M \u2705 Implemented \u2705 Complete Check if directory is a project (git/vscode/hands) get_file_extension( filename ) M \u2705 Implemented \u2705 Complete Get file extension (supports complex extensions) which( executable ) M \u2705 Implemented \u2705 Complete Find executable in system PATH filter( path, pattern ) S \u2705 Implemented \u2705 Complete Filter directory contents by glob pattern Operation Bash Description show_user <code>whoami</code> Show current user name change_user( user ) <code>su - user</code> Change to another user show_groups( user ) <code>groups</code> Show groups of given user name, defaults to current user change_owner( user, file ) <code>chown user file</code> Change owner of a file or directory change_group( group, file ) <code>chgrp group file</code> Change group of a file or directory"},{"location":"operations/summary/#reports","title":"Reports","text":"Test Coverage Summary Module Functions Tested Coverage Level Status file_commands 1/5 functions \ud83d\udfe1 Partial Ready for expansion archive_commands 11/11 functions \ud83d\udfe2 Complete Fully tested core_commands 15/15 functions \ud83d\udfe2 Complete Comprehensive <p>Legend: - \u2705 Implemented &amp; Tested - \ud83d\udd04 TODO/Planned - \ud83d\udfe2 Complete Coverage - \ud83d\udfe1 Partial Coverage - \ud83d\udd34 Needs Attention</p>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers the basic usage patterns of Hands Trapezium.</p>"},{"location":"user-guide/basic-usage/#shell-class","title":"Shell Class","text":"<p>The <code>Shell</code> class is the core of Hands Trapezium, providing secure command execution.</p>"},{"location":"user-guide/basic-usage/#creating-a-shell-instance","title":"Creating a Shell Instance","text":"<pre><code>from hands_scaphoid import Shell\n\n# Basic shell with current directory\nshell = Shell()\n\n# Shell with custom working directory\nshell = Shell(cwd=\"/path/to/working/dir\")\n\n# Shell with custom environment\nshell = Shell(env={\"PATH\": \"/usr/bin:/bin\"})\n\n# Shell with environment file\nshell = Shell(env_file=\"/path/to/.env\")\n</code></pre>"},{"location":"user-guide/basic-usage/#allowing-commands","title":"Allowing Commands","text":"<p>Before executing any command, you must explicitly allow it:</p> <pre><code># Allow single commands\nshell.allow(\"echo\")\nshell.allow(\"ls\")\nshell.allow(\"git\")\n\n# Check if command exists and allow it\nif shell.allow(\"docker\"):\n    print(\"Docker is available\")\nelse:\n    print(\"Docker not found on system\")\n</code></pre>"},{"location":"user-guide/basic-usage/#executing-commands","title":"Executing Commands","text":"<pre><code># Basic command execution\nresult = shell.run(\"echo 'Hello World'\")\nprint(result.stdout)  # Output: Hello World\n\n# Command with timeout\nresult = shell.run(\"sleep 1\", timeout=5)\n\n# Command without error checking\nresult = shell.run(\"ls /nonexistent\", check=False)\nif result.returncode != 0:\n    print(\"Command failed\")\n\n# Capture output as bytes instead of text\nresult = shell.run(\"cat binary_file\", text=False)\n</code></pre>"},{"location":"user-guide/basic-usage/#working-with-directories","title":"Working with Directories","text":"<pre><code># Change directory\nshell.cd(\"/tmp\")\nprint(shell.cwd)  # Output: /tmp\n\n# Use relative paths\nshell.cd(\"../\")\nshell.cd(\"subdir\")\n\n# Go to absolute path\nshell.cd(\"/home/user/project\")\n</code></pre>"},{"location":"user-guide/basic-usage/#environment-variables","title":"Environment Variables","text":"<pre><code># Get environment variable\ndb_url = shell.get_env_var(\"DATABASE_URL\")\n\n# Set environment variable\nshell.set_env_var(\"NODE_ENV\", \"production\")\n\n# Check if variable exists\nif shell.get_env_var(\"API_KEY\"):\n    print(\"API key is set\")\n</code></pre>"},{"location":"user-guide/basic-usage/#shellcontext-manager","title":"ShellContext Manager","text":"<p>The <code>ShellContext</code> provides a cleaner way to use Shell functionality.</p>"},{"location":"user-guide/basic-usage/#basic-context-usage","title":"Basic Context Usage","text":"<pre><code>from hands_scaphoid import ShellContext\n\nwith ShellContext() as shell:\n    shell.allow(\"echo\")\n    shell.allow(\"ls\")\n\n    result = shell.run(\"echo 'Hello from context'\")\n    print(result.stdout)\n\n    shell.cd(\"/tmp\")\n    result = shell.run(\"ls\")\n    print(result.stdout)\n</code></pre>"},{"location":"user-guide/basic-usage/#global-functions-style","title":"Global Functions Style","text":"<pre><code>with ShellContext():\n    # These functions are now available globally\n    allow(\"git\")\n    allow(\"echo\")\n    allow(\"npm\")\n\n    # Change to project directory\n    cd(\"/path/to/project\")\n\n    # Run build commands\n    run(\"git pull origin main\")\n    run(\"npm install\")\n    run(\"npm run build\")\n\n    # Show completion message\n    run(\"echo 'Build complete!'\")\n</code></pre>"},{"location":"user-guide/basic-usage/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Custom working directory and environment\nwith ShellContext(cwd=\"/app\", env_file=\".env.production\") as shell:\n    shell.allow(\"docker\")\n    shell.allow(\"docker-compose\")\n\n    # Deploy application\n    shell.run(\"docker-compose down\")\n    shell.run(\"docker-compose up -d\")\n</code></pre>"},{"location":"user-guide/basic-usage/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/basic-usage/#security-errors","title":"Security Errors","text":"<pre><code>with ShellContext() as shell:\n    # This will raise PermissionError\n    try:\n        shell.run(\"rm important_file\")\n    except PermissionError as e:\n        print(f\"Security prevented: {e}\")\n\n    # Allow the command first\n    shell.allow(\"rm\")\n    shell.run(\"rm temporary_file\")  # Now works\n</code></pre>"},{"location":"user-guide/basic-usage/#command-execution-errors","title":"Command Execution Errors","text":"<pre><code>import subprocess\n\nwith ShellContext() as shell:\n    shell.allow(\"ls\")\n\n    try:\n        shell.run(\"ls /nonexistent/directory\")\n    except subprocess.CalledProcessError as e:\n        print(f\"Command failed with exit code {e.returncode}\")\n        print(f\"Error output: {e.stderr}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#timeout-handling","title":"Timeout Handling","text":"<pre><code>try:\n    with ShellContext() as shell:\n        shell.allow(\"sleep\")\n        shell.run(\"sleep 10\", timeout=5)\nexcept subprocess.TimeoutExpired:\n    print(\"Command timed out\")\n</code></pre>"},{"location":"user-guide/basic-usage/#practical-examples","title":"Practical Examples","text":""},{"location":"user-guide/basic-usage/#simple-script-runner","title":"Simple Script Runner","text":"<pre><code>from hands_scaphoid import ShellContext\n\ndef run_tests():\n    \"\"\"Run project tests.\"\"\"\n    with ShellContext() as shell:\n        # Allow required commands\n        shell.allow(\"python\")\n        shell.allow(\"pytest\")\n\n        # Change to project directory\n        shell.cd(\"/path/to/project\")\n\n        # Run tests\n        try:\n            result = shell.run(\"pytest tests/\")\n            if result.returncode == 0:\n                print(\"\u2705 All tests passed!\")\n            else:\n                print(\"\u274c Tests failed!\")\n                return False\n        except Exception as e:\n            print(f\"\u274c Test execution failed: {e}\")\n            return False\n\n    return True\n</code></pre>"},{"location":"user-guide/basic-usage/#environment-setup-script","title":"Environment Setup Script","text":"<pre><code>def setup_development_environment():\n    \"\"\"Set up development environment.\"\"\"\n    with ShellContext(cwd=\"/app\") as shell:\n        # Allow necessary commands\n        commands = [\"git\", \"python\", \"pip\", \"npm\"]\n        for cmd in commands:\n            if not shell.allow(cmd):\n                print(f\"\u274c {cmd} not found\")\n                return False\n\n        # Clone repository\n        shell.run(\"git clone https://github.com/user/repo.git .\")\n\n        # Install Python dependencies\n        shell.run(\"pip install -r requirements.txt\")\n\n        # Install Node.js dependencies\n        shell.run(\"npm install\")\n\n        # Set up environment file\n        shell.set_env_var(\"ENVIRONMENT\", \"development\")\n\n        print(\"\u2705 Development environment ready!\")\n\n    return True\n</code></pre>"},{"location":"user-guide/basic-usage/#file-processing-pipeline","title":"File Processing Pipeline","text":"<pre><code>def process_files(input_dir: str, output_dir: str):\n    \"\"\"Process files in a directory.\"\"\"\n    with ShellContext(cwd=input_dir) as shell:\n        # Allow file processing commands\n        shell.allow(\"find\")\n        shell.allow(\"convert\")  # ImageMagick\n        shell.allow(\"mkdir\")\n\n        # Create output directory\n        shell.run(f\"mkdir -p {output_dir}\")\n\n        # Find and process image files\n        result = shell.run(\"find . -name '*.jpg' -o -name '*.png'\")\n\n        for file_path in result.stdout.strip().split('\\n'):\n            if file_path:\n                output_file = f\"{output_dir}/{file_path}\"\n                shell.run(f\"convert {file_path} -resize 800x600 {output_file}\")\n                print(f\"Processed: {file_path}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#tips-and-best-practices","title":"Tips and Best Practices","text":""},{"location":"user-guide/basic-usage/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Allowlist Only Required Commands: Only allow commands you actually need</li> <li>Validate Input: Validate any user input before using in commands</li> <li>Use Specific Commands: Prefer specific commands over generic ones</li> <li>Review Command Lists: Regularly review what commands your scripts allow</li> </ol>"},{"location":"user-guide/basic-usage/#performance-tips","title":"Performance Tips","text":"<ol> <li>Reuse Shell Instances: Create once and reuse for multiple commands</li> <li>Batch Operations: Group related commands in the same context</li> <li>Avoid Unnecessary Captures: Set <code>capture_output=False</code> when you don't need output</li> </ol>"},{"location":"user-guide/basic-usage/#error-handling_1","title":"Error Handling","text":"<ol> <li>Use try/except: Always handle potential errors</li> <li>Check Return Codes: Check command success before proceeding</li> <li>Provide Meaningful Messages: Give users clear error messages</li> <li>Graceful Degradation: Have fallback options when commands fail</li> </ol>"},{"location":"user-guide/basic-usage/#code-organization","title":"Code Organization","text":"<ol> <li>Separate Concerns: Keep command logic separate from business logic</li> <li>Use Functions: Wrap command sequences in functions</li> <li>Document Commands: Comment what each command does</li> <li>Version Control: Track changes to command sequences</li> </ol>"},{"location":"user-guide/hierarchical-contexts/","title":"API Reference: Hierarchical File System Context Managers","text":""},{"location":"user-guide/hierarchical-contexts/#overview","title":"Overview","text":"<p>The hands-scaphoid package provides hierarchical file system context managers that allow working with directories, files, and archives in a structured, chainable manner with support for global function access.</p>"},{"location":"user-guide/hierarchical-contexts/#base-classes","title":"Base Classes","text":""},{"location":"user-guide/hierarchical-contexts/#context","title":"Context","text":"<p>The <code>Context</code> class is the abstract base class for all hierarchical file system operations.</p> <pre><code>from hands_scaphoid.Context import Context\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#constructor","title":"Constructor","text":"<pre><code>Context(path: PathLike, create: bool = True, dry_run: bool = False, enable_globals: bool = False)\n</code></pre> <p>Parameters: - <code>path</code>: The file system path (relative or absolute) - <code>create</code>: Whether to create the path if it doesn't exist (default: True) - <code>dry_run</code>: Whether to simulate operations without making actual changes (default: False) - <code>enable_globals</code>: Whether to enable global function access within context (default: False)</p>"},{"location":"user-guide/hierarchical-contexts/#key-methods","title":"Key Methods","text":"<ul> <li><code>resolve_path() -&gt; Path</code>: Resolve the absolute path for this context</li> <li><code>__enter__()</code>: Enter the context manager</li> <li><code>__exit__()</code>: Exit the context manager and cleanup</li> </ul>"},{"location":"user-guide/hierarchical-contexts/#directory-class","title":"Directory Class","text":"<p>The <code>Directory</code> class provides directory context management with automatic working directory changes.</p> <pre><code>from hands_scaphoid.Directory import Directory\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#constructor_1","title":"Constructor","text":"<pre><code>DirectoryContext(path: PathLike, create: bool = True, dry_run: bool = False, enable_globals: bool = False)\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#context-manager-usage","title":"Context Manager Usage","text":"<pre><code>with DirectoryContext('~/projects') as home_projects:\n    with DirectoryContext('myproject') as project:\n        # Now working in ~/projects/myproject\n        project.list_contents()\n        project.create_subdirectory('src')\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#global-functions-usage","title":"Global Functions Usage","text":"<p>When <code>enable_globals=True</code>, methods can be called without object prefix:</p> <pre><code>with DirectoryContext('~/projects', enable_globals=True):\n    list_contents()  # Instead of directory.list_contents()\n    create_subdirectory('src')\n    list_contents()\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#methods","title":"Methods","text":""},{"location":"user-guide/hierarchical-contexts/#list_contents-liststr","title":"<code>list_contents() -&gt; List[str]</code>","text":"<p>List all items in the directory.</p> <p>Returns: List of file and directory names</p> <p>Example: <pre><code>with DirectoryContext('/home/user') as home:\n    contents = home.list_contents()\n    print(contents)  # ['Documents', 'Downloads', 'Pictures', ...]\n</code></pre></p>"},{"location":"user-guide/hierarchical-contexts/#create_subdirectoryname-str-directory","title":"<code>create_subdirectory(name: str) -&gt; 'Directory'</code>","text":"<p>Create a subdirectory within the current context.</p> <p>Parameters: - <code>name</code>: Name of the subdirectory to create</p> <p>Returns: New Directory instance for method chaining</p> <p>Example: <pre><code>with DirectoryContext('/tmp') as temp:\n    temp.create_subdirectory('project').create_subdirectory('src')\n</code></pre></p>"},{"location":"user-guide/hierarchical-contexts/#list_filesextension-str-none-liststr","title":"<code>list_files(extension: str = None) -&gt; List[str]</code>","text":"<p>List files in the directory, optionally filtered by extension.</p> <p>Parameters: - <code>extension</code>: File extension filter (optional, without dot)</p> <p>Returns: List of filenames</p> <p>Example: <pre><code>with DirectoryContext('/home/user/documents') as docs:\n    python_files = docs.list_files('py')\n    all_files = docs.list_files()\n</code></pre></p>"},{"location":"user-guide/hierarchical-contexts/#standalone-methods","title":"Standalone Methods","text":""},{"location":"user-guide/hierarchical-contexts/#directorycreate_directorypath-pathlike-none","title":"<code>Directory.create_directory(path: PathLike) -&gt; None</code>","text":"<p>Create a directory without using context manager.</p> <p>Parameters: - <code>path</code>: Directory path to create</p> <p>Example: <pre><code>Directory.create_directory('/tmp/standalone_dir')\n</code></pre></p>"},{"location":"user-guide/hierarchical-contexts/#file-class","title":"File Class","text":"<p>The <code>File</code> class provides file context management with automatic file handle management.</p> <pre><code>from hands_scaphoid.objects import FileObject\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#constructor_2","title":"Constructor","text":"<pre><code>FileContext(path: PathLike, create: bool = True, mode: str = 'r+', \n     encoding: str = 'utf-8', dry_run: bool = False, enable_globals: bool = False)\n</code></pre> <p>Parameters: - <code>path</code>: The file path (relative or absolute) - <code>create</code>: Whether to create the file if it doesn't exist (default: True) - <code>mode</code>: File open mode (default: 'r+' for read/write) - <code>encoding</code>: File encoding (default: 'utf-8') - <code>dry_run</code>: Whether to simulate operations without making actual changes - <code>enable_globals</code>: Whether to enable global function access within context</p>"},{"location":"user-guide/hierarchical-contexts/#context-manager-usage_1","title":"Context Manager Usage","text":"<pre><code>with FileContext('config.txt') as config:\n    config.write_line('# Configuration file')\n    config.add_heading('Database Settings')\n    config.write_line('host=localhost')\n    config.write_line('port=5432')\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#global-functions-usage_1","title":"Global Functions Usage","text":"<pre><code>with FileContext('config.txt', enable_globals=True):\n    write_line('# Configuration file')\n    add_heading('Database Settings')\n    write_content('host=localhost\\nport=5432')\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#methods_1","title":"Methods","text":""},{"location":"user-guide/hierarchical-contexts/#write_linecontent-str-file","title":"<code>write_line(content: str) -&gt; 'File'</code>","text":"<p>Write a line to the file with automatic newline.</p> <p>Parameters: - <code>content</code>: Text content to write</p> <p>Returns: Self for method chaining</p>"},{"location":"user-guide/hierarchical-contexts/#write_contentcontent-str-file","title":"<code>write_content(content: str) -&gt; 'File'</code>","text":"<p>Write content to the file without automatic newline.</p> <p>Parameters: - <code>content</code>: Text content to write</p> <p>Returns: Self for method chaining</p>"},{"location":"user-guide/hierarchical-contexts/#add_headingtitle-str-level-int-1-file","title":"<code>add_heading(title: str, level: int = 1) -&gt; 'File'</code>","text":"<p>Add a markdown-style heading to the file.</p> <p>Parameters: - <code>title</code>: Heading text - <code>level</code>: Heading level (1-6, default: 1)</p> <p>Returns: Self for method chaining</p>"},{"location":"user-guide/hierarchical-contexts/#read_content-str","title":"<code>read_content() -&gt; str</code>","text":"<p>Read the entire file content.</p> <p>Returns: File content as string</p>"},{"location":"user-guide/hierarchical-contexts/#read_lines-liststr","title":"<code>read_lines() -&gt; List[str]</code>","text":"<p>Read all lines from the file.</p> <p>Returns: List of lines</p>"},{"location":"user-guide/hierarchical-contexts/#standalone-methods_1","title":"Standalone Methods","text":""},{"location":"user-guide/hierarchical-contexts/#filewrite_filepath-pathlike-content-str-none","title":"<code>File.write_file(path: PathLike, content: str) -&gt; None</code>","text":"<p>Write content to a file without using context manager.</p> <p>Parameters: - <code>path</code>: File path - <code>content</code>: Content to write</p>"},{"location":"user-guide/hierarchical-contexts/#fileread_filepath-pathlike-str","title":"<code>File.read_file(path: PathLike) -&gt; str</code>","text":"<p>Read content from a file without using context manager.</p> <p>Parameters: - <code>path</code>: File path</p> <p>Returns: File content</p>"},{"location":"user-guide/hierarchical-contexts/#archive-class","title":"Archive Class","text":"<p>The <code>Archive</code> class provides archive context management supporting ZIP, TAR, TAR.GZ, and TAR.BZ2 formats.</p> <pre><code>from hands_scaphoid.Archive import Archive\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#constructor_3","title":"Constructor","text":"<pre><code>ArchiveFile(source: Optional[PathLike] = None, target: Optional[PathLike] = None, \n        archive_type: str = 'zip', create: bool = True, dry_run: bool = False, \n        enable_globals: bool = False)\n</code></pre> <p>Parameters: - <code>source</code>: Source directory, file, or existing archive to work with (optional) - <code>target</code>: Target archive file path (defaults to source name with archive extension) - <code>archive_type</code>: Type of archive ('zip', 'tar', 'tar.gz', 'tar.bz2') - <code>create</code>: Whether to create the archive if it doesn't exist - <code>dry_run</code>: Whether to simulate operations without making actual changes - <code>enable_globals</code>: Whether to enable global function access within context</p>"},{"location":"user-guide/hierarchical-contexts/#context-manager-usage_2","title":"Context Manager Usage","text":"<pre><code>with ArchiveFile('project.zip', create=True) as archive:\n    archive.add_file('README.md')\n    archive.add_directory('src')\n    archive.list_contents()\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#global-functions-usage_2","title":"Global Functions Usage","text":"<pre><code>with ArchiveFile('project.zip', enable_globals=True):\n    add_file('README.md')\n    add_directory('src')\n    list_contents()\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#methods_2","title":"Methods","text":""},{"location":"user-guide/hierarchical-contexts/#add_filefile_path-pathlike-archive_path-str-none-archive","title":"<code>add_file(file_path: PathLike, archive_path: str = None) -&gt; 'Archive'</code>","text":"<p>Add a file to the archive.</p> <p>Parameters: - <code>file_path</code>: Path to the file to add - <code>archive_path</code>: Path within archive (optional, defaults to filename)</p> <p>Returns: Self for method chaining</p>"},{"location":"user-guide/hierarchical-contexts/#add_directorydir_path-pathlike-archive_path-str-none-archive","title":"<code>add_directory(dir_path: PathLike, archive_path: str = None) -&gt; 'Archive'</code>","text":"<p>Add a directory and its contents to the archive.</p> <p>Parameters: - <code>dir_path</code>: Path to the directory to add - <code>archive_path</code>: Path within archive (optional, defaults to directory name)</p> <p>Returns: Self for method chaining</p>"},{"location":"user-guide/hierarchical-contexts/#list_contents-liststr_1","title":"<code>list_contents() -&gt; List[str]</code>","text":"<p>List contents of the archive.</p> <p>Returns: List of file paths in the archive</p>"},{"location":"user-guide/hierarchical-contexts/#extract_filearchive_path-str-target_path-pathlike-none-archive","title":"<code>extract_file(archive_path: str, target_path: PathLike = None) -&gt; 'Archive'</code>","text":"<p>Extract a specific file from the archive.</p> <p>Parameters: - <code>archive_path</code>: Path of file within archive - <code>target_path</code>: Target extraction path (optional)</p> <p>Returns: Self for method chaining</p>"},{"location":"user-guide/hierarchical-contexts/#extract_alltarget_path-pathlike-none-archive","title":"<code>extract_all(target_path: PathLike = None) -&gt; 'Archive'</code>","text":"<p>Extract all contents from the archive.</p> <p>Parameters: - <code>target_path</code>: Target extraction directory (optional)</p> <p>Returns: Self for method chaining</p>"},{"location":"user-guide/hierarchical-contexts/#standalone-methods_2","title":"Standalone Methods","text":""},{"location":"user-guide/hierarchical-contexts/#archivecreate_archivearchive_path-pathlike-source_path-pathlike-archive_type-str-zip-none","title":"<code>Archive.create_archive(archive_path: PathLike, source_path: PathLike, archive_type: str = 'zip') -&gt; None</code>","text":"<p>Create an archive without using context manager.</p> <p>Parameters: - <code>archive_path</code>: Path for the new archive - <code>source_path</code>: Source directory or file to archive - <code>archive_type</code>: Type of archive to create</p>"},{"location":"user-guide/hierarchical-contexts/#global-functions-feature","title":"Global Functions Feature","text":"<p>When <code>enable_globals=True</code> is set on any context manager, the context's methods become available as global functions within the context scope.</p>"},{"location":"user-guide/hierarchical-contexts/#how-it-works","title":"How It Works","text":"<pre><code># Traditional usage\nwith DirectoryContext('mydir') as d:\n    d.list_contents()\n    d.create_subdirectory('subdir')\n\n# Global functions usage\nwith DirectoryContext('mydir', enable_globals=True):\n    list_contents()        # No object prefix needed\n    create_subdirectory('subdir')\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#nested-contexts","title":"Nested Contexts","text":"<p>When contexts are nested, the inner context's global functions take precedence:</p> <pre><code>with DirectoryContext('mydir', enable_globals=True):\n    list_contents()  # Directory.list_contents()\n\n    with FileContext('myfile.txt', enable_globals=True):\n        write_line('text')    # File.write_line()\n        # list_contents() would fail here (not a File method)\n\n    list_contents()  # Directory.list_contents() available again\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#cleanup","title":"Cleanup","text":"<p>Global functions are automatically cleaned up when exiting contexts, preventing namespace pollution.</p>"},{"location":"user-guide/hierarchical-contexts/#dry-run-mode","title":"Dry-Run Mode","text":"<p>All classes support dry-run mode for testing operations without making actual changes.</p> <pre><code>with DirectoryContext('test', dry_run=True, enable_globals=True):\n    create_subdirectory('would_create')  # Shows what would be created\n    list_contents()                      # Shows what would be listed\n\nwith FileContext('test.txt', dry_run=True, enable_globals=True):\n    write_line('would write this')       # Shows what would be written\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#method-chaining","title":"Method Chaining","text":"<p>All mutation methods return <code>self</code> to enable method chaining:</p> <pre><code>with FileContext('config.txt') as config:\n    config.add_heading('Settings') \\\n          .write_line('key=value') \\\n          .write_line('debug=true')\n\nwith ArchiveFile('project.zip') as archive:\n    archive.add_file('README.md') \\\n           .add_directory('src') \\\n           .add_file('LICENSE')\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#error-handling","title":"Error Handling","text":"<p>All classes provide comprehensive error handling with descriptive messages using rich console output for better visibility.</p> <p>Common exceptions: - <code>PermissionError</code>: When lacking permissions for file operations - <code>FileNotFoundError</code>: When referenced files don't exist - <code>ValueError</code>: When invalid parameters are provided - <code>RuntimeError</code>: When context management rules are violated</p>"},{"location":"user-guide/hierarchical-contexts/#examples","title":"Examples","text":""},{"location":"user-guide/hierarchical-contexts/#basic-usage","title":"Basic Usage","text":"<pre><code>from hands_scaphoid import Directory, File, Archive\n\n# Create a project structure\nwith DirectoryContext('myproject', create=True) as project:\n    with DirectoryContext('src') as src:\n        with FileContext('main.py') as main:\n            main.add_heading('Main Application', 1)\n            main.write_line('#!/usr/bin/env python3')\n            main.write_line('print(\"Hello, World!\")')\n\n    with DirectoryContext('docs') as docs:\n        with FileContext('README.md') as readme:\n            readme.add_heading('My Project')\n            readme.write_line('This is my project description.')\n\n    # Create an archive of the project\n    with ArchiveFile('myproject.zip') as archive:\n        archive.add_directory('src')\n        archive.add_directory('docs')\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#global-functions-usage_3","title":"Global Functions Usage","text":"<pre><code># Using global functions for cleaner syntax\nwith DirectoryContext('myproject', create=True, enable_globals=True):\n    create_subdirectory('src')\n\n    with FileContext('src/main.py', enable_globals=True):\n        add_heading('Main Application')\n        write_line('#!/usr/bin/env python3')\n        write_line('print(\"Hello, World!\")')\n\n    with ArchiveFile('project.zip', enable_globals=True):\n        add_directory('src')\n        list_contents()\n</code></pre>"},{"location":"user-guide/hierarchical-contexts/#dry-run-testing","title":"Dry-Run Testing","text":"<pre><code># Test operations without making changes\nwith DirectoryContext('testdir', dry_run=True, enable_globals=True):\n    create_subdirectory('would_create')\n\n    with FileContext('would_create.txt', dry_run=True, enable_globals=True):\n        write_line('This would be written')\n        add_heading('Test Heading')\n</code></pre>"},{"location":"user-guide/installation/","title":"Installation","text":""},{"location":"user-guide/installation/#requirements","title":"Requirements","text":"<p>Hands Trapezium requires Python 3.11 or higher.</p>"},{"location":"user-guide/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The easiest way to install Hands Trapezium is from PyPI using pip:</p> <pre><code>pip install hands-trapezium\n</code></pre>"},{"location":"user-guide/installation/#install-from-source","title":"Install from Source","text":"<p>You can also install directly from the GitHub repository:</p> <pre><code>pip install git+https://github.com/42sol-eu/hands_scaphoid.git\n</code></pre> <p>Or clone the repository and install in development mode:</p> <pre><code>git clone https://github.com/42sol-eu/hands_scaphoid.git\ncd hands_scaphoid\npip install -e .\n</code></pre>"},{"location":"user-guide/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to Hands Trapezium, install it in development mode with testing dependencies:</p> <pre><code>git clone https://github.com/42sol-eu/hands_scaphoid.git\ncd hands_scaphoid\npip install -e \".[dev]\"\n</code></pre> <p>This will install additional dependencies for testing and development:</p> <ul> <li>pytest for testing</li> <li>pytest-cov for coverage</li> <li>mkdocs for documentation</li> <li>black for code formatting</li> <li>mypy for type checking</li> </ul>"},{"location":"user-guide/installation/#virtual-environment","title":"Virtual Environment","text":"<p>It's recommended to install Hands Trapezium in a virtual environment:</p> <pre><code># Create virtual environment\npython -m venv venv\n\n# Activate (Linux/Mac)\nsource venv/bin/activate\n\n# Activate (Windows)\nvenv\\Scripts\\activate\n\n# Install Hands Trapezium\npip install hands-trapezium\n</code></pre>"},{"location":"user-guide/installation/#using-uv-recommended","title":"Using UV (Recommended)","text":"<p>If you're using UV for package management:</p> <pre><code>uv add hands-trapezium\n</code></pre>"},{"location":"user-guide/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that Hands Trapezium is installed correctly:</p> <pre><code>import hands_scaphoid\nprint(hands_scaphoid.__version__)\n</code></pre> <p>Or use the command-line interface:</p> <pre><code>python -m hands_scaphoid --version\n</code></pre>"},{"location":"user-guide/installation/#dependencies","title":"Dependencies","text":"<p>Hands Trapezium has minimal dependencies:</p> <ul> <li>rich: For beautiful console output</li> <li>click: For the command-line interface</li> </ul> <p>These will be automatically installed when you install Hands Trapezium.</p>"},{"location":"user-guide/installation/#platform-support","title":"Platform Support","text":"<p>Hands Trapezium is tested on:</p> <ul> <li>Linux (Ubuntu, Debian, CentOS, etc.)</li> <li>macOS</li> <li>Windows</li> </ul> <p>The library works anywhere Python runs, but some features (like command validation) may behave differently on different platforms.</p>"},{"location":"user-guide/installation/#docker","title":"Docker","text":"<p>You can also use Hands Trapezium in Docker containers. Here's a simple Dockerfile:</p> <pre><code>FROM python:3.11-slim\n\n# Install Hands Trapezium\nRUN pip install hands-trapezium\n\n# Copy your script\nCOPY script.py /app/script.py\n\nWORKDIR /app\nCMD [\"python\", \"script.py\"]\n</code></pre>"},{"location":"user-guide/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/installation/#permission-errors","title":"Permission Errors","text":"<p>If you encounter permission errors during installation, try:</p> <pre><code>pip install --user hands-trapezium\n</code></pre>"},{"location":"user-guide/installation/#python-version-issues","title":"Python Version Issues","text":"<p>Ensure you're using Python 3.11 or higher:</p> <pre><code>python --version\n</code></pre> <p>If you have multiple Python versions, you might need to use <code>python3.11</code> or <code>python3</code> instead of <code>python</code>.</p>"},{"location":"user-guide/installation/#import-errors","title":"Import Errors","text":"<p>If you get import errors after installation, make sure you're in the correct virtual environment and that the installation completed successfully:</p> <pre><code>pip list | grep hands-trapezium\n</code></pre>"},{"location":"user-guide/testing/","title":"Testing","text":"<p>This guide covers the comprehensive test suite for Hands Scaphoid command modules, ensuring reliability and maintainability of the codebase.</p>"},{"location":"user-guide/testing/#test-structure","title":"Test Structure","text":"<p>The test suite is organized into separate test modules that mirror the main command modules:</p> <pre><code>tests/commands/\n\u251c\u2500\u2500 test_file_commands.py      # Tests for file operations\n\u251c\u2500\u2500 test_archive_commands.py   # Tests for archive operations  \n\u251c\u2500\u2500 test_core_commands.py      # Tests for core utility functions\n\u2514\u2500\u2500 conftest.py               # Shared test fixtures\n</code></pre>"},{"location":"user-guide/testing/#test-coverage-overview","title":"Test Coverage Overview","text":""},{"location":"user-guide/testing/#file-commands-test_file_commandspy","title":"File Commands (<code>test_file_commands.py</code>)","text":"<p>The file commands test suite covers:</p> <ul> <li>File Reading Operations:</li> <li>Reading entire file content</li> <li>Reading with head/tail limits</li> <li>Custom line separators</li> <li>Error handling for non-existent files</li> <li> <p>Encoding handling</p> </li> <li> <p>Placeholder Tests: Ready for future file operations like:</p> </li> <li><code>filter()</code> - Pattern-based file filtering</li> <li><code>write()</code> - File writing operations</li> <li><code>append()</code> - File appending operations</li> <li><code>create()</code> - File creation operations</li> </ul> <p>Example test: <pre><code>def test_read_entire_file(self, tmp_path):\n    \"\"\"Test reading entire file content.\"\"\"\n    test_file = tmp_path / \"test.txt\"\n    content = \"Line 1\\nLine 2\\nLine 3\"\n    test_file.write_text(content)\n\n    result = read(test_file)\n    assert result == content\n</code></pre></p>"},{"location":"user-guide/testing/#archive-commands-test_archive_commandspy","title":"Archive Commands (<code>test_archive_commands.py</code>)","text":"<p>Comprehensive testing for all archive formats:</p> <ul> <li>Archive Detection:</li> <li>File extension validation</li> <li> <p>Support for <code>.zip</code>, <code>.tar</code>, <code>.7z</code>, <code>.rar</code>, <code>.tar.gz</code>, etc.</p> </li> <li> <p>Archive Creation:</p> </li> <li>ZIP archive creation and validation</li> <li>TAR archives (with/without compression)</li> <li>7Z archives (mocked py7zr library)</li> <li> <p>RAR archives (via external command)</p> </li> <li> <p>Archive Extraction:</p> </li> <li>All supported formats</li> <li>Target directory validation</li> <li> <p>Error handling for corrupted archives</p> </li> <li> <p>Content Listing:</p> </li> <li>Listing files in archives</li> <li>Support for all archive formats</li> <li>Error handling for invalid archives</li> </ul> <p>Example test: <pre><code>def test_create_zip_archive(self, tmp_path):\n    \"\"\"Test creating ZIP archives.\"\"\"\n    source_dir = tmp_path / \"source\"\n    source_dir.mkdir()\n    (source_dir / \"file1.txt\").write_text(\"content1\")\n\n    archive_name = str(tmp_path / \"test_archive\")\n    result = create_zip_archive(archive_name, source_dir)\n    assert result is True\n\n    # Verify archive was created\n    archive_path = Path(f\"{archive_name}.zip\")\n    assert archive_path.exists()\n</code></pre></p>"},{"location":"user-guide/testing/#core-commands-test_core_commandspy","title":"Core Commands (<code>test_core_commands.py</code>)","text":"<p>Testing for core utility functions:</p> <ul> <li>Path Operations:</li> <li>File/directory existence checking</li> <li>Path type validation (file, directory, link, object)</li> <li> <p>Project type detection (git, vscode, hands projects)</p> </li> <li> <p>Compression Types:</p> </li> <li>Enum value validation</li> <li> <p>Type listing functionality</p> </li> <li> <p>File Extensions:</p> </li> <li>Simple extensions (<code>.txt</code>, <code>.py</code>)</li> <li>Complex extensions (<code>.tar.gz</code>, <code>.drawio.png</code>)</li> <li> <p>Edge cases and special handling</p> </li> <li> <p>System Integration:</p> </li> <li>Executable discovery with <code>which()</code></li> <li>Environment variable checking</li> <li>Filter operations with glob patterns</li> </ul> <p>Example test: <pre><code>@pytest.mark.parametrize(\"filename,expected\", [\n    (\"file.txt\", \"txt\"),\n    (\"archive.tar.gz\", \"tar.gz\"),\n    (\"drawing.drawio.png\", \"drawio.png\"),\n    (\"no_extension\", \"\"),\n])\ndef test_get_file_extension(filename, expected):\n    assert get_file_extension(filename) == expected\n</code></pre></p>"},{"location":"user-guide/testing/#running-tests","title":"Running Tests","text":""},{"location":"user-guide/testing/#basic-test-execution","title":"Basic Test Execution","text":"<pre><code># Run all tests\npytest\n\n# Run specific test module\npytest tests/commands/test_file_commands.py\n\n# Run with verbose output\npytest -v\n\n# Run with coverage\npytest --cov=hands_scaphoid\n</code></pre>"},{"location":"user-guide/testing/#advanced-test-options","title":"Advanced Test Options","text":"<pre><code># Run tests matching pattern\npytest -k \"test_archive\"\n\n# Run tests for specific functionality\npytest tests/commands/test_core_commands.py::test_get_file_extension\n\n# Run with detailed output\npytest --tb=long -v\n</code></pre>"},{"location":"user-guide/testing/#test-fixtures","title":"Test Fixtures","text":"<p>The test suite uses pytest fixtures defined in <code>conftest.py</code>:</p> <pre><code>@pytest.fixture\ndef temp_dir():\n    \"\"\"Create a temporary directory for tests.\"\"\"\n    with tempfile.TemporaryDirectory() as temp_dir:\n        yield Path(temp_dir)\n\n@pytest.fixture\ndef shell_with_temp_dir(temp_dir):\n    \"\"\"Create a Shell instance with a temporary directory.\"\"\"\n    return ShellExecutable(cwd=str(temp_dir))\n</code></pre>"},{"location":"user-guide/testing/#mocking-strategy","title":"Mocking Strategy","text":"<p>For external dependencies, the tests use comprehensive mocking:</p>"},{"location":"user-guide/testing/#archive-libraries","title":"Archive Libraries","text":"<pre><code>@patch('hands_scaphoid.commands.archive_commands.py7zr')\ndef test_create_7z_archive(self, mock_py7zr, tmp_path):\n    \"\"\"Test creating 7Z archives with mocked library.\"\"\"\n    mock_archive = MagicMock()\n    mock_py7zr.SevenZipFile.return_value.__enter__.return_value = mock_archive\n    # Test implementation...\n</code></pre>"},{"location":"user-guide/testing/#system-commands","title":"System Commands","text":"<pre><code>@patch('hands_scaphoid.commands.archive_commands.subprocess.run')\ndef test_create_rar_archive(self, mock_run, tmp_path):\n    \"\"\"Test RAR creation with mocked subprocess.\"\"\"\n    mock_run.return_value.returncode = 0\n    # Test implementation...\n</code></pre>"},{"location":"user-guide/testing/#test-categories","title":"Test Categories","text":""},{"location":"user-guide/testing/#unit-tests","title":"Unit Tests","text":"<ul> <li>Individual function testing</li> <li>Edge case handling</li> <li>Error condition validation</li> <li>Input validation</li> </ul>"},{"location":"user-guide/testing/#integration-tests","title":"Integration Tests","text":"<ul> <li>File system operations</li> <li>Archive format handling</li> <li>Cross-module functionality</li> </ul>"},{"location":"user-guide/testing/#security-tests","title":"Security Tests","text":"<ul> <li>Path validation</li> <li>File access controls</li> <li>Command execution safety</li> </ul>"},{"location":"user-guide/testing/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/testing/#test-organization","title":"Test Organization","text":"<ul> <li>One test class per module</li> <li>Descriptive test method names</li> <li>Comprehensive docstrings</li> <li>Parametrized tests for variations</li> </ul>"},{"location":"user-guide/testing/#error-testing","title":"Error Testing","text":"<pre><code>def test_read_nonexistent_file(self, tmp_path):\n    \"\"\"Test reading a file that doesn't exist.\"\"\"\n    nonexistent_file = tmp_path / \"nonexistent.txt\"\n    result = read(nonexistent_file)\n    assert result == \"\"\n</code></pre>"},{"location":"user-guide/testing/#performance-testing","title":"Performance Testing","text":"<pre><code>def test_performance_with_large_directory(self, tmp_path):\n    \"\"\"Test performance with larger directory structures.\"\"\"\n    test_dir = tmp_path / \"large_dir\"\n    test_dir.mkdir()\n\n    # Create 100 test files\n    for i in range(100):\n        (test_dir / f\"file_{i:03d}.txt\").write_text(f\"content {i}\")\n\n    # Test filtering performance\n    txt_files = filter(test_dir, \"*.txt\")\n    assert len(txt_files) == 100\n</code></pre>"},{"location":"user-guide/testing/#platform-compatibility","title":"Platform Compatibility","text":"<pre><code>def test_symlink_operations(self, tmp_path):\n    \"\"\"Test operations with symbolic links.\"\"\"\n    try:\n        link.symlink_to(original)\n        # Test symlink operations...\n    except OSError:\n        pytest.skip(\"Symbolic links not supported on this system\")\n</code></pre>"},{"location":"user-guide/testing/#future-test-enhancements","title":"Future Test Enhancements","text":""},{"location":"user-guide/testing/#planned-test-areas","title":"Planned Test Areas","text":"<ul> <li>File Commands: Complete testing when remaining functions are implemented</li> <li>Performance: Load testing with large file sets</li> <li>Concurrency: Multi-threaded operation testing  </li> <li>Platform: Enhanced Windows/macOS specific testing</li> </ul>"},{"location":"user-guide/testing/#test-metrics-goals","title":"Test Metrics Goals","text":"<ul> <li>Coverage: &gt;95% code coverage</li> <li>Performance: Sub-second test suite execution</li> <li>Reliability: Zero flaky tests</li> <li>Documentation: 100% test documentation coverage</li> </ul>"},{"location":"user-guide/testing/#continuous-integration","title":"Continuous Integration","text":"<p>The test suite integrates with CI/CD pipelines:</p> <pre><code># GitHub Actions example\n- name: Run Tests\n  run: |\n    pytest --cov=hands_scaphoid --cov-report=xml\n\n- name: Upload Coverage\n  uses: codecov/codecov-action@v1\n  with:\n    file: ./coverage.xml\n</code></pre> <p>This comprehensive test coverage ensures that Hands Scaphoid maintains high quality and reliability across all supported operations and platforms.</p>"}]}